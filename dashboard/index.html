<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LookingGlassSim Dashboard</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    .grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    .card { border: 1px solid #ddd; border-radius: 8px; padding: 12px; }
    h2 { margin: 0 0 8px 0; font-size: 18px; }
    table { border-collapse: collapse; width: 100%; }
    th, td { border: 1px solid #eee; padding: 6px 8px; text-align: left; font-size: 12px; }
    .score { font-weight: bold; }
    canvas { width: 100% !important; height: 280px !important; }
    .diagram { display: flex; align-items: center; justify-content: center; }
    .box { padding: 6px 10px; border: 1px solid #999; border-radius: 4px; margin: 4px; font-size: 12px; }
    .arrow { margin: 0 6px; font-size: 16px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>LookingGlassSim Results</h1>
  <p>Run: <code>python examples/test.py --json out/test_summary.json</code> then open this page and select the JSON.</p>

  <input type="file" id="file" accept="application/json" />
  <div style="margin:8px 0;">
    <button id="btn-run">Run Retest</button>
    <label style="margin-left:8px;">Trials <input id="inp-trials" type="number" value="300" style="width:80px;"/></label>
    <label style="margin-left:8px;">Seed <input id="inp-seed" type="number" value="123" style="width:80px;"/></label>
    <label style="margin-left:8px;">Base Window ns <input id="inp-window" type="number" value="10" step="0.5" style="width:80px;"/></label>
    <label style="margin-left:8px;"><input id="chk-vote" type="checkbox" checked/> Vote3</label>
    <label style="margin-left:8px;"><input id="chk-autotune" type="checkbox" checked/> Autotune</label>
    <label style="margin-left:8px;"><input id="chk-sens" type="checkbox"/> Sensitivity</label>
    <label style="margin-left:8px;"><input id="chk-neigh" type="checkbox"/> Neighbor CT</label>
  </div>
  <div class="card" style="margin:8px 0;">
    <h2>Worker Log</h2>
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
      <span>Connection:</span>
      <span id="conn" style="width:10px;height:10px;border-radius:50%;background:#f44336;display:inline-block;"></span>
      <span id="connText" style="font-size:12px;color:#555;">Inactive</span>
    </div>
    <pre id="log" style="white-space:pre-wrap;height:160px;overflow:auto;border:1px solid #eee;padding:8px;"></pre>
  </div>

  <div class="grid" style="margin-top:12px;">
    <div class="card">
      <h2>Summary KPIs</h2>
      <table id="table-summary"></table>
    </div>
    <div class="card">
      <h2>Realism Heuristics</h2>
      <table id="table-realism"></table>
    </div>
    <div class="card">
      <h2>Calibrated Baseline KPIs</h2>
      <table id="table-calibrated"></table>
    </div>
    <div class="card">
      <h2>Per-tile BER</h2>
      <canvas id="tileHeat"></canvas>
    </div>
    <div class="card">
      <h2>Per-tile BER (after calibration)</h2>
      <canvas id="tileHeatAfter"></canvas>
    </div>
    <div class="card">
      <h2>Window Sweep (p50 BER)</h2>
      <canvas id="winChart"></canvas>
    </div>
    <div class="card">
      <h2>Voting & Calibration</h2>
      <table id="table-calib"></table>
    </div>
    <div class="card">
      <h2>Diag Crosstalk Sweep</h2>
      <canvas id="diagChart"></canvas>
    </div>
    <div class="card">
      <h2>Drift vs Time</h2>
      <canvas id="driftChart"></canvas>
    </div>
    <div class="card">
      <h2>Autotuner Result</h2>
      <table id="table-autotune"></table>
    </div>
    <div class="card">
      <h2>System Diagram</h2>
      <div class="diagram">
        <div class="box">Emitter</div><div class="arrow">→</div>
        <div class="box">Optics</div><div class="arrow">→</div>
        <div class="box">Camera</div><div class="arrow">→</div>
        <div class="box">TIA</div><div class="arrow">→</div>
        <div class="box">Comparator</div>
      </div>
      <p style="font-size:12px;color:#555;">Clock controls window & jitter. Thermal drift perturbs comparator threshold and optics transmittance.</p>
    </div>
    <div class="card">
      <h2>Pack Parameters</h2>
      <table id="table-packs"></table>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('file');
    let winChart, tileChart;

    function renderTable(table, obj) {
      const keys = Object.keys(obj || {});
      let html = '<tr><th>Key</th><th>Value</th></tr>';
      for (const k of keys) {
        let v = obj[k];
        if (typeof v === 'object') v = JSON.stringify(v);
        html += `<tr><td>${k}</td><td>${v}</td></tr>`;
      }
      table.innerHTML = html;
    }

    function renderPacks(table, packs) {
      let html = '<tr><th>Pack</th><th>Params</th></tr>';
      for (const [name, vals] of Object.entries(packs || {})) {
        html += `<tr><td>${name}</td><td><pre style="white-space:pre-wrap;">${JSON.stringify(vals, null, 2)}</pre></td></tr>`;
      }
      table.innerHTML = html;
    }

    function drawHeatmap(canvas, matrix) {
      if (tileChart) tileChart.destroy();
      // Flatten matrix into dataset per row; color via gradient plugin surrogate (Chart.js lacks heatmap natively)
      // We'll approximate using stacked bar per column with opacity by value.
      const labels = matrix[0].map((_, i) => 'x'+i);
      const datasets = matrix.map((row, r) => ({
        label: 'y'+r,
        data: row,
        backgroundColor: row.map(v => `rgba(33,150,243,${Math.min(1, Math.max(0.05, v))})`),
        borderWidth: 0
      }));
      tileChart = new Chart(canvas.getContext('2d'), {
        type: 'bar',
        data: { labels, datasets },
        options: {
          responsive: true,
          scales: { x: { stacked: true }, y: { stacked: true, suggestedMax: 1.0 } },
          plugins: { legend: { display: false } }
        }
      });
    }

    function drawLine(canvas, xs, ys, label) {
      if (winChart) winChart.destroy();
      winChart = new Chart(canvas.getContext('2d'), {
        type: 'line',
        data: { labels: xs, datasets: [{ label, data: ys, borderColor: '#4caf50', fill: false }] },
        options: { responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1 } } }
      });
    }

    fileInput.addEventListener('change', (e) => {
      const f = e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          renderTable(document.getElementById('table-summary'), {
            p50_ber: data?.baseline?.p50_ber,
            p50_energy_pj: data?.baseline?.p50_energy_pj,
            window_ns: data?.baseline?.window_ns,
            p50_snr_emit: data?.baseline?.p50_snr_emit,
            p50_snr_pd: data?.baseline?.p50_snr_pd,
            p50_snr_tia: data?.baseline?.p50_snr_tia,
          });
          renderTable(document.getElementById('table-realism'), (data?.realism)||{});
          renderTable(document.getElementById('table-calibrated'), {
            p50_ber: data?.baseline_calibrated?.p50_ber,
            p50_energy_pj: data?.baseline_calibrated?.p50_energy_pj,
            window_ns: data?.baseline_calibrated?.window_ns,
            p50_snr_emit: data?.baseline_calibrated?.p50_snr_emit,
            p50_snr_pd: data?.baseline_calibrated?.p50_snr_pd,
            p50_snr_tia: data?.baseline_calibrated?.p50_snr_tia,
          });
          renderPacks(document.getElementById('table-packs'), data?.packs || {});
          const hm = data?.ber_per_tile;
          if (hm && hm.length) drawHeatmap(document.getElementById('tileHeat'), hm);
          const hma = data?.ber_per_tile_after;
          if (hma && hma.length) drawHeatmap(document.getElementById('tileHeatAfter'), hma);
          const xs = data?.window_sweep?.x_window_ns || [];
          const ys = data?.window_sweep?.p50_ber || [];
          if (xs.length && ys.length) drawLine(document.getElementById('winChart'), xs, ys, 'p50 BER');
          const dx = data?.sensitivity?.diag_crosstalk_sweep?.x_ct_diag_db || [];
          const dy = data?.sensitivity?.diag_crosstalk_sweep?.p50_ber || [];
          if (dx.length && dy.length) drawLine(document.getElementById('diagChart'), dx, dy, 'p50 BER vs ct_diag_db');
          const dno = data?.drift?.no_cal || {};
          const dfix = data?.drift?.with_cal || {};
          if ((dno?.x_frame?.length||0) && (dfix?.x_frame?.length||0)) {
            const ctx = document.getElementById('driftChart').getContext('2d');
            new Chart(ctx, {
              type: 'line',
              data: {
                labels: dno.x_frame,
                datasets: [
                  { label: 'No Cal', data: dno.p50_ber, borderColor: '#f44336', fill: false },
                  { label: 'With Cal', data: dfix.p50_ber, borderColor: '#2196f3', fill: false }
                ]
              },
              options: { responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1 } } }
            });
          }
          renderTable(document.getElementById('table-calib'), {
            vote3_p50_ber: data?.vote3_p50_ber,
            spatial_oversample_p50_ber: data?.spatial_oversample_p50_ber,
            lockin_p50_ber: data?.lockin_p50_ber,
            chop_p50_ber: data?.chop_p50_ber,
            avg_frames_p50_ber: data?.avg_frames_p50_ber,
            soft_thresh_p50_ber: data?.soft_thresh_p50_ber,
            mitigated_p50_ber: data?.mitigated_p50_ber,
            vth_suggest_mV: data?.calibration?.vth_suggest_mV,
            ber_before: data?.calibration?.ber_before,
            ber_after: data?.calibration?.ber_after,
            ber_delta: data?.calibration?.ber_delta,
          });
          if (data?.autotune) {
            renderTable(document.getElementById('table-autotune'), {
              best_ber: data.autotune.best_ber,
              best_summary: JSON.stringify(data.autotune.best_summary),
              tuned_clock_window_ns: data.autotune.params?.clock?.window_ns,
              tuned_emitter_power_mw_per_ch: data.autotune.params?.emitter?.power_mw_per_ch,
              tuned_tia_gain_kohm: data.autotune.params?.tia?.tia_transimpedance_kohm,
              tuned_tia_bw_mhz: data.autotune.params?.tia?.bw_mhz,
              tuned_comp_hysteresis_mV: data.autotune.params?.comparator?.hysteresis_mV,
              tuned_optics_ct_db: data.autotune.params?.optics?.crosstalk_db,
              tuned_optics_ct_neighbor_db: data.autotune.params?.optics?.ct_neighbor_db,
              tuned_optics_ct_diag_db: data.autotune.params?.optics?.ct_diag_db,
            });
          }
        } catch (err) {
          alert('Invalid JSON');
        }
      };
      reader.readAsText(f);
    });

    // Retest controls
    const logEl = document.getElementById('log');
    function appendLog(obj) {
      logEl.textContent += (typeof obj === 'string' ? obj : JSON.stringify(obj)) + "\n";
      logEl.scrollTop = logEl.scrollHeight;
    }
    const evtSrc = new EventSource('/api/events');
    evtSrc.onmessage = (ev) => {
      try {
        const data = JSON.parse(ev.data);
        if (data.msg === 'connected') {
          document.getElementById('conn').style.background = '#4caf50';
          document.getElementById('connText').textContent = 'Active';
          return;
        }
        if (data.ping) return; // quiet heartbeat
        appendLog(data);
      } catch { appendLog(ev.data); }
    };
    evtSrc.addEventListener('done', (ev) => {
      try {
        const data = JSON.parse(ev.data);
        // Auto-load the finished JSON
        renderTable(document.getElementById('table-summary'), {
          p50_ber: data?.baseline?.p50_ber,
          p50_energy_pj: data?.baseline?.p50_energy_pj,
          window_ns: data?.baseline?.window_ns,
          p50_snr_emit: data?.baseline?.p50_snr_emit,
          p50_snr_pd: data?.baseline?.p50_snr_pd,
          p50_snr_tia: data?.baseline?.p50_snr_tia,
        });
        renderTable(document.getElementById('table-realism'), (data?.realism)||{});
        renderTable(document.getElementById('table-calibrated'), {
          p50_ber: data?.baseline_calibrated?.p50_ber,
          p50_energy_pj: data?.baseline_calibrated?.p50_energy_pj,
          window_ns: data?.baseline_calibrated?.window_ns,
          p50_snr_emit: data?.baseline_calibrated?.p50_snr_emit,
          p50_snr_pd: data?.baseline_calibrated?.p50_snr_pd,
          p50_snr_tia: data?.baseline_calibrated?.p50_snr_tia,
        });
        const hm = data?.ber_per_tile;
        if (hm && hm.length) drawHeatmap(document.getElementById('tileHeat'), hm);
        const hma = data?.ber_per_tile_after;
        if (hma && hma.length) drawHeatmap(document.getElementById('tileHeatAfter'), hma);
        const xs = data?.window_sweep?.x_window_ns || [];
        const ys = data?.window_sweep?.p50_ber || [];
        if (xs.length && ys.length) drawLine(document.getElementById('winChart'), xs, ys, 'p50 BER');
        renderTable(document.getElementById('table-calib'), {
          vote3_p50_ber: data?.vote3_p50_ber,
          spatial_oversample_p50_ber: data?.spatial_oversample_p50_ber,
          lockin_p50_ber: data?.lockin_p50_ber,
          chop_p50_ber: data?.chop_p50_ber,
          avg_frames_p50_ber: data?.avg_frames_p50_ber,
          soft_thresh_p50_ber: data?.soft_thresh_p50_ber,
          mitigated_p50_ber: data?.mitigated_p50_ber,
          vth_suggest_mV: data?.calibration?.vth_suggest_mV,
          ber_before: data?.calibration?.ber_before,
          ber_after: data?.calibration?.ber_after,
          ber_delta: data?.calibration?.ber_delta,
        });
        if (data?.autotune) {
          renderTable(document.getElementById('table-autotune'), {
            best_ber: data.autotune.best_ber,
            tuned_clock_window_ns: data.autotune.params?.clock?.window_ns,
            tuned_emitter_power_mw_per_ch: data.autotune.params?.emitter?.power_mw_per_ch,
            tuned_tia_gain_kohm: data.autotune.params?.tia?.tia_transimpedance_kohm,
            tuned_tia_bw_mhz: data.autotune.params?.tia?.bw_mhz,
            tuned_comp_hysteresis_mV: data.autotune.params?.comparator?.hysteresis_mV,
            tuned_optics_ct_db: data.autotune.params?.optics?.crosstalk_db,
            tuned_optics_ct_neighbor_db: data.autotune.params?.optics?.ct_neighbor_db,
            tuned_optics_ct_diag_db: data.autotune.params?.optics?.ct_diag_db,
          });
        }
        const dx = data?.sensitivity?.diag_crosstalk_sweep?.x_ct_diag_db || [];
        const dy = data?.sensitivity?.diag_crosstalk_sweep?.p50_ber || [];
        if (dx.length && dy.length) drawLine(document.getElementById('diagChart'), dx, dy, 'p50 BER vs ct_diag_db');
        const dno = data?.drift?.no_cal || {};
        const dfix = data?.drift?.with_cal || {};
        if ((dno?.x_frame?.length||0) && (dfix?.x_frame?.length||0)) {
          const ctx = document.getElementById('driftChart').getContext('2d');
          new Chart(ctx, { type: 'line', data: { labels: dno.x_frame, datasets: [ { label: 'No Cal', data: dno.p50_ber, borderColor: '#f44336', fill: false }, { label: 'With Cal', data: dfix.p50_ber, borderColor: '#2196f3', fill: false } ] }, options: { responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1 } } } });
        }
      } catch (e) { appendLog({ error: String(e) }); }
    });
    document.getElementById('btn-run').onclick = async () => {
      const trials = document.getElementById('inp-trials').value;
      const seed = document.getElementById('inp-seed').value;
      const windowNs = document.getElementById('inp-window').value;
      const vote = document.getElementById('chk-vote').checked ? '1':'0';
      const auto = document.getElementById('chk-autotune').checked ? '1':'0';
      const sens = document.getElementById('chk-sens').checked ? '1':'0';
      const neigh = document.getElementById('chk-neigh').checked ? '1':'0';
      appendLog({ msg: 'requesting run' });
      try {
        const r = await fetch(`/api/run?trials=${trials}&seed=${seed}&base_window_ns=${windowNs}&vote3=${vote}&autotune=${auto}&sensitivity=${sens}&neighbor_ct=${neigh}`);
        appendLog(await r.json());
      } catch (err) { appendLog({ error: String(err) }); }
    };
  </script>
</body>
</html>

