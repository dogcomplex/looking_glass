
-----------------------

.\examples\test.py
"""
Usage examples (PowerShell-friendly):

  # default run
  python examples/test.py

  # more trials and fixed seed
  python examples/test.py --trials 300 --seed 123

  # sensitivity mode (amplify effects):
  python examples/test.py --sensitivity

  # custom windows and ranges
  python examples/test.py --windows 5,10,15,20,25 --rin-range "-170:-130:9" --ct-range "-40:-15:9"

  # save JSON output
  python examples/test.py --json out/test_summary.json
"""

import os, sys
sys.path.append(os.path.dirname(os.path.dirname(__file__)))

import json
from dataclasses import replace
from statistics import median
import argparse

from looking_glass.orchestrator import Orchestrator, SystemParams
from looking_glass.sim.emitter import EmitterParams
from looking_glass.sim.cold_storage import ColdParams, ColdReader
from looking_glass.sim.optics import OpticsParams
from looking_glass.sim.sensor import PDParams
from looking_glass.sim.tia import TIAParams
from looking_glass.sim.comparator import ComparatorParams
from looking_glass.sim.clock import ClockParams


def _parse_csv_floats(csv: str | None):
    if not csv:
        return []
    if isinstance(csv, (list, tuple)):
        return [float(x) for x in csv]
    return [float(x) for x in str(csv).replace(';', ',').split(',') if str(x).strip()]


def run_trials(orch: Orchestrator, trials: int):
    # Minimal per-trial retention to avoid large in-memory logs
    out = []
    for _ in range(trials):
        r = orch.step()
        out.append({
            "ber": r.get("ber"),
            "energy_pj": r.get("energy_pj"),
            "window_ns": r.get("window_ns"),
            "n_bits": r.get("n_bits"),
            "n_err": r.get("n_err"),
        })
    return out


def med_ber(rows):
    return float(median([r["ber"] for r in rows])) if rows else None

def _wilson_ci(n_err: int, n_bits: int, z: float = 1.96):
    try:
        n = int(n_bits)
        k = int(n_err)
        if n <= 0:
            return None, None
        p = k / n
        denom = 1 + (z*z)/n
        center = (p + (z*z)/(2*n)) / denom
        half = (z * ((p*(1-p)/n + (z*z)/(4*n*n)) ** 0.5)) / denom
        lo = max(0.0, center - half)
        hi = min(1.0, center + half)
        return float(lo), float(hi)
    except Exception:
        return None, None

def mean_ber(rows):
    return (float(sum(r["ber"] for r in rows)/len(rows)) if rows else None)


def quick_window_sweep(orch: Orchestrator, trials: int, windows):
    xs, ys = [], []
    for w in windows:
        orch.clk.p.window_ns = float(w)
        rows = run_trials(orch, trials)
        xs.append(w)
        ys.append(med_ber(rows))
    # Expect BER non-increasing with window
    monotone = all(ys[i] >= ys[i+1] for i in range(len(ys)-1))
    return xs, ys, bool(monotone)


def quick_rin_sweep(
    base_sys: SystemParams,
    trials: int,
    starts,
    stops,
    steps,
    *,
    tia_bw_mhz: float,
    comp_noise_mV: float,
    emit_ext_db: float | None = None,
    emit_power_mw: float | None = None,
    tia_R_kohm: float | None = None,
    comp_vth_mV: float | None = None,
):
    xs, ys = [], []
    for i in range(steps):
        x = starts + i*(stops-starts)/(steps-1)
        # Rebuild orchestrator per point to keep RNG state comparable
        emit = EmitterParams(channels=base_sys.channels, rin_dbhz=float(x))
        if emit_ext_db is not None:
            emit.extinction_db = float(emit_ext_db)
        if emit_power_mw is not None:
            emit.power_mw_per_ch = float(emit_power_mw)
        optx = OpticsParams()
        pd = PDParams()
        tia = TIAParams(bw_mhz=tia_bw_mhz, tia_transimpedance_kohm=(tia_R_kohm if tia_R_kohm is not None else 10.0))
        comp = ComparatorParams(input_noise_mV_rms=comp_noise_mV, vth_mV=(comp_vth_mV if comp_vth_mV is not None else 5.0))
        clk = ClockParams(window_ns=base_sys.window_ns, jitter_ps_rms=10.0)
        orch = Orchestrator(base_sys, emit, optx, pd, tia, comp, clk)
        rows = run_trials(orch, trials)
        xs.append(x)
        ys.append(med_ber(rows))
    # Expect BER non-decreasing when RIN gets worse (less negative)
    monotone = all(ys[i] <= ys[i+1] for i in range(len(ys)-1))
    return xs, ys, bool(monotone)


def quick_crosstalk_sweep(base_sys: SystemParams, trials: int, starts, stops, steps, *, tia_bw_mhz: float, comp_noise_mV: float, opt_contrast: tuple[float, float] | None = None, opt_transmittance: float | None = None):
    xs, ys = [], []
    for i in range(steps):
        x = starts + i*(stops-starts)/(steps-1)
        emit = EmitterParams(channels=base_sys.channels)
        optx = OpticsParams(crosstalk_db=float(x))
        if opt_contrast is not None:
            optx.w_plus_contrast, optx.w_minus_contrast = float(opt_contrast[0]), float(opt_contrast[1])
        if opt_transmittance is not None:
            optx.transmittance = float(opt_transmittance)
        pd = PDParams()
        tia = TIAParams(bw_mhz=tia_bw_mhz)
        comp = ComparatorParams(input_noise_mV_rms=comp_noise_mV)
        clk = ClockParams(window_ns=base_sys.window_ns, jitter_ps_rms=10.0)
        orch = Orchestrator(base_sys, emit, optx, pd, tia, comp, clk)
        rows = run_trials(orch, trials)
        xs.append(x)
        ys.append(med_ber(rows))
    # Crosstalk less negative (towards 0) => worse; expect BER non-decreasing with x
    monotone = all(ys[i] <= ys[i+1] for i in range(len(ys)-1))
    return xs, ys, bool(monotone)

def quick_neighbor_ct_sweep(
    base_sys: SystemParams,
    trials: int,
    starts,
    stops,
    steps,
    *,
    tia_bw_mhz: float,
    comp_noise_mV: float,
    opt_contrast: tuple[float, float] | None = None,
    emit_power_mw: float | None = None,
    tia_R_kohm: float | None = None,
    comp_vth_mV: float | None = None,
):
    xs, ys = [], []
    for i in range(steps):
        x = starts + i*(stops-starts)/(steps-1)
        emit = EmitterParams(channels=base_sys.channels)
        if emit_power_mw is not None:
            emit.power_mw_per_ch = float(emit_power_mw)
        optx = OpticsParams(ct_model="neighbor", ct_neighbor_db=float(x))
        if opt_contrast is not None:
            optx.w_plus_contrast, optx.w_minus_contrast = float(opt_contrast[0]), float(opt_contrast[1])
        pd = PDParams()
        tia = TIAParams(bw_mhz=tia_bw_mhz, tia_transimpedance_kohm=(tia_R_kohm if tia_R_kohm is not None else 10.0))
        comp = ComparatorParams(input_noise_mV_rms=comp_noise_mV, vth_mV=(comp_vth_mV if comp_vth_mV is not None else 5.0))
        clk = ClockParams(window_ns=base_sys.window_ns, jitter_ps_rms=10.0)
        orch = Orchestrator(base_sys, emit, optx, pd, tia, comp, clk)
        rows = run_trials(orch, trials)
        xs.append(x)
        ys.append(med_ber(rows))
    monotone = all(ys[i] <= ys[i+1] for i in range(len(ys)-1))
    return xs, ys, bool(monotone)

def quick_diag_ct_sweep(
    base_sys: SystemParams,
    trials: int,
    starts,
    stops,
    steps,
    *,
    tia_bw_mhz: float,
    comp_noise_mV: float,
    opt_contrast: tuple[float, float] | None = None,
    emit_power_mw: float | None = None,
    tia_R_kohm: float | None = None,
    comp_vth_mV: float | None = None,
):
    xs, ys = [], []
    for i in range(steps):
        x = starts + i*(stops-starts)/(steps-1)
        emit = EmitterParams(channels=base_sys.channels)
        if emit_power_mw is not None:
            emit.power_mw_per_ch = float(emit_power_mw)
        optx = OpticsParams(ct_model="neighbor", ct_diag_db=float(x))
        if opt_contrast is not None:
            optx.w_plus_contrast, optx.w_minus_contrast = float(opt_contrast[0]), float(opt_contrast[1])
        pd = PDParams()
        tia = TIAParams(bw_mhz=tia_bw_mhz, tia_transimpedance_kohm=(tia_R_kohm if tia_R_kohm is not None else 10.0))
        comp = ComparatorParams(input_noise_mV_rms=comp_noise_mV, vth_mV=(comp_vth_mV if comp_vth_mV is not None else 5.0))
        clk = ClockParams(window_ns=base_sys.window_ns, jitter_ps_rms=10.0)
        orch = Orchestrator(base_sys, emit, optx, pd, tia, comp, clk)
        rows = run_trials(orch, trials)
        xs.append(x)
        ys.append(med_ber(rows))
    monotone = all(ys[i] <= ys[i+1] for i in range(len(ys)-1))
    return xs, ys, bool(monotone)


def _compute_pathb_return_map(sys_p: SystemParams, emit_p: EmitterParams, optx_p: OpticsParams, pd_p: PDParams, tia_p: TIAParams, comp_p: ComparatorParams, clk_p: ClockParams, depth: int, passes: int, deadzone_mw: float, *, seed_offset: int = 0, stage_gains_db: list[float] | None = None, vth_schedule_mV: list[float] | None = None):
    import numpy as _np
    depth = int(depth)
    passes = max(1, int(passes))
    if depth <= 0:
        return {
            "levels": [],
            "stage_slopes": [],
            "deadzone_fraction": [],
            "rail_positive_fraction": [],
            "rail_negative_fraction": [],
        }
    deadzone_mw = max(1e-9, float(deadzone_mw))
    stage_gains_db = list(stage_gains_db or [])
    vth_schedule_mV = list(vth_schedule_mV or [])
    results = {
        "levels": [],
        "stage_slopes": [],
        "deadzone_fraction": [],
        "rail_positive_fraction": [],
        "rail_negative_fraction": [],
        "stage_diff_in": [],
        "stage_diff_out": [],
    }
    eps = 1e-9
    levels = [-1, 0, 1]
    for lvl in levels:
        level_slopes = [[] for _ in range(depth)]
        level_dead = [[] for _ in range(depth)]
        level_pos = [[] for _ in range(depth)]
        level_neg = [[] for _ in range(depth)]
        level_diff_in = [[] for _ in range(depth)]
        level_diff_out = [[] for _ in range(depth)]
        for pidx in range(passes):
            sys_clone = SystemParams(**sys_p.__dict__)
            sys_clone.seed = int(sys_clone.seed) + seed_offset + pidx + 1
            emit_clone = EmitterParams(**emit_p.__dict__)
            optx_clone = OpticsParams(**optx_p.__dict__)
            pd_clone = PDParams(**pd_p.__dict__)
            tia_clone = TIAParams(**tia_p.__dict__)
            comp_clone = ComparatorParams(**comp_p.__dict__)
            clk_clone = ClockParams(**clk_p.__dict__)
            orch = Orchestrator(sys_clone, emit_clone, optx_clone, pd_clone, tia_clone, comp_clone, clk_clone)
            dt = float(orch.clk.sample_window())
            tern = _np.full(sys_clone.channels, lvl, dtype=int)
            plus, minus = orch.emit.simulate(tern, dt, orch.sys.temp_C)
            base_vth_vec = None
            if vth_schedule_mV:
                existing = getattr(orch.comp, '_vth_per_ch', None)
                if existing is not None:
                    base_vth_vec = _np.array(existing, dtype=float)
                else:
                    base_vth_vec = _np.full(orch.sys.channels, float(orch.comp.p.vth_mV), dtype=float)
            for stage in range(depth):
                diff_in = plus - minus
                plus, minus, _, _ = orch.optx.simulate(plus, minus, dt)
                if stage_gains_db:
                    gain_idx = stage if stage < len(stage_gains_db) else len(stage_gains_db) - 1
                    gain_db = float(stage_gains_db[gain_idx])
                    scale = 10 ** (-gain_db / 10.0)
                    plus = plus * scale
                    minus = minus * scale
                if vth_schedule_mV:
                    vth_idx = stage if stage < len(vth_schedule_mV) else len(vth_schedule_mV) - 1
                    stage_vth = float(vth_schedule_mV[vth_idx])
                    orch.comp.set_vth_per_channel(_np.full(orch.sys.channels, stage_vth, dtype=float))
                diff_out = plus - minus
                ratio = _np.abs(diff_out) / _np.clip(_np.abs(diff_in), eps, None)
                level_slopes[stage].append(float(_np.median(ratio)))
                level_dead[stage].append(float(_np.mean(_np.abs(diff_out) < deadzone_mw)))
                level_diff_in[stage].append(float(_np.median(_np.abs(diff_in))))
                level_diff_out[stage].append(float(_np.median(_np.abs(diff_out))))
                level_pos[stage].append(float(_np.mean(diff_out > deadzone_mw)))
                level_neg[stage].append(float(_np.mean(diff_out < -deadzone_mw)))
            if vth_schedule_mV:
                orch.comp.set_vth_per_channel(_np.full(orch.sys.channels, float(orch.comp.p.vth_mV), dtype=float))
        results["levels"].append(int(lvl))
        results["stage_slopes"].append([float(_np.median(s)) if s else None for s in level_slopes])
        results["deadzone_fraction"].append([float(_np.median(d)) if d else None for d in level_dead])
        results["rail_positive_fraction"].append([float(_np.median(r)) if r else None for r in level_pos])
        results["rail_negative_fraction"].append([float(_np.median(r)) if r else None for r in level_neg])
        results["stage_diff_in"].append([float(_np.median(di)) if di else None for di in level_diff_in])
        results["stage_diff_out"].append([float(_np.median(do)) if do else None for do in level_diff_out])
    flat_slopes = [val for sub in results["stage_slopes"] for val in sub if val is not None]
    if flat_slopes:
        flat_arr = _np.array(flat_slopes, dtype=float)
        results["median_stage_slope"] = float(_np.median(flat_arr))
        results["max_stage_slope"] = float(_np.max(flat_arr))
    else:
        results["median_stage_slope"] = None
        results["max_stage_slope"] = None
    flat_in = [val for sub in results["stage_diff_in"] for val in sub if val is not None]
    flat_out = [val for sub in results["stage_diff_out"] for val in sub if val is not None]
    results["median_diff_in"] = float(_np.median(_np.array(flat_in))) if flat_in else None
    results["median_diff_out"] = float(_np.median(_np.array(flat_out))) if flat_out else None
    return results



def _run_pathb_stage_pass(orch: Orchestrator,
                          ternary,
                          analog_depth: int,
                          stage_gains_db: list[float] | None,
                          vth_schedule_mV: list[float] | None):
    import numpy as _np
    dt = float(orch.clk.sample_window())
    if orch.sys.reset_analog_state_each_frame:
        orch.tia.reset()
        orch.comp.reset()
    Pp, Pm = orch.emit.simulate(ternary, dt, orch.sys.temp_C)
    stage_gains = list(stage_gains_db or [])
    stage_outputs = []
    for stage_idx in range(max(0, analog_depth)):
        diff_in = Pp - Pm
        Pp, Pm, _, _ = orch.optx.simulate(Pp, Pm, dt)
        if stage_gains:
            gain_idx = stage_idx if stage_idx < len(stage_gains) else len(stage_gains) - 1
            gain_db = float(stage_gains[gain_idx])
            scale = 10 ** (-gain_db / 10.0)
            Pp = Pp * scale
            Pm = Pm * scale
        stage_outputs.append((Pp.copy(), Pm.copy(), diff_in.copy(), (Pp - Pm).copy()))
    base_vth_vec = None
    if vth_schedule_mV:
        existing = getattr(orch.comp, '_vth_per_ch', None)
        if existing is not None:
            base_vth_vec = _np.array(existing, dtype=float)
        else:
            base_vth_vec = _np.full(orch.sys.channels, float(orch.comp.p.vth_mV), dtype=float)
    return dt, stage_outputs, base_vth_vec





def _build_fixed_inputs(seed: int, channels: int, count: int):
    import numpy as _np
    rng = _np.random.default_rng(int(seed))
    return [rng.integers(-1, 2, size=channels) for _ in range(count)]


def _med_ber_fixed_inputs(orch: Orchestrator, inputs: list[list[int]]):
    import numpy as _np
    errs = []
    for tern in inputs:
        r = orch.step(force_ternary=_np.asarray(tern, dtype=int))
        errs.append(float(r.get("ber", 0.0)))
    return float(median(errs)) if errs else None


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--trials", type=int, default=200)
    ap.add_argument("--seed", type=int, default=321)
    ap.add_argument("--channels", type=int, default=16, help="Number of logical channels (e.g., 16/32/64)")
    ap.add_argument("--sensitivity", action="store_true")
    ap.add_argument("--windows", type=str, default="3,5,7,9,13,17")
    ap.add_argument("--rin-range", type=str, default="-170:-140:4")
    ap.add_argument("--ct-range", type=str, default="-40:-18:4")
    ap.add_argument("--vote3", action="store_true", help="Enable 3x temporal voting estimate")
    ap.add_argument("--repeat", type=int, default=1, help="Temporal repeats for majority vote estimate (overrides --vote3)")
    ap.add_argument("--classifier",
                    type=str,
                    choices=["auto","adaptive","avg","soft","vote3","vote5","repeat","replicate","replicate2","phys2x","lockin","chop","mitigated"],
                    default=None,
                    help="Classifier used for primary Path A summary when set")
    ap.add_argument("--autotune", action="store_true", help="Run automatic tuner within realistic bounds")
    ap.add_argument("--autotune-budget", type=int, default=60)
    ap.add_argument("--autotune-trials", type=int, default=120)
    ap.add_argument("--neighbor-ct", action="store_true", help="Use neighbor crosstalk model in baseline")
    ap.add_argument("--base-window-ns", type=float, default=20.0, help="Baseline clock window (ns)")
    ap.add_argument("--apply-calibration", action="store_true", help="Apply per-channel vth trims to baseline KPIs")
    ap.add_argument("--mask-bad-channels", type=int, default=0, help="Mask N worst channels (exclude from BER)")
    ap.add_argument("--mask-bad-frac", type=float, default=0.0, help="Mask worst frac of channels (0.0..1.0)")
    ap.add_argument("--calib-mask-trials", type=int, default=200, help="Trials used to estimate bad-channel mask")
    ap.add_argument("--mask-mode", type=str, choices=["error","dvspan"], default="error", help="Mask criterion: error (default) or dvspan (use |pos_mean-neg_mean|)")
    ap.add_argument("--spatial-oversample", type=int, default=1, help="Pseudo spatial oversampling vote (runs per input)")
    ap.add_argument("--lockin", action="store_true", help="Estimate lock-in subtraction by subtracting a dark frame dv")
    ap.add_argument("--chop", action="store_true", help="Chopper stabilization: use +x and -x frames, subtract dv before threshold")
    ap.add_argument("--avg-frames", type=int, default=1, help="Average dv over N frames per input before thresholding (noise ~ 1/sqrt(N))")
    ap.add_argument("--avg-kernel", type=str, choices=["sum", "ewma"], default="sum", help="Averaging kernel for dv over frames: sum or ewma")
    # Simple spatial deblurring (neighbor deconvolution)
    ap.add_argument("--deblur-neigh-alpha", type=float, default=0.0, help="Neighbor deblurring strength alpha; dv' = dv - alpha*(left+right)")
    ap.add_argument("--learn-deblur", action="store_true", help="Learn per-channel neighbor deblur weights (left/right) from calibration dv")
    ap.add_argument("--deblur-l2", type=float, default=0.1, help="Ridge penalty for learned deblur weights")
    ap.add_argument("--deblur-samples", type=int, default=240, help="Samples to gather for learned deblur weights")
    # Confidence gating (selective extra frames for low-margin channels)
    ap.add_argument("--gate-thresh-mV", type=float, default=0.0, help="If |dv| < thresh, take extra frames and add to dv before decision")
    ap.add_argument("--gate-extra-frames", type=int, default=0, help="Number of extra frames to integrate for gated channels")
    ap.add_argument("--avg-ema-alpha", type=float, default=0.6, help="EWMA alpha (0..1], only used when --avg-kernel=ewma")
    ap.add_argument("--use-avg-frames-for-path-a", action="store_true", help="If set and avg_frames>1, use averaged-dv classifier as primary path_a summary")
    ap.add_argument("--permute-repeats", action="store_true", help="Permute logical???physical channel mapping on each repeat and de-permute for voting")
    ap.add_argument("--permute-scheme", type=str, choices=["random","cyclic"], default="random", help="Permutation scheme across repeats")
    ap.add_argument("--soft-thresh", action="store_true", help="Bypass comparator: software threshold dv using per-channel vth (upper bound for Path A)")
    # Option to choose which computed classifier feeds the primary path_a summary
    ap.add_argument("--path-a-mode", type=str, default="auto",
                    choices=["auto", "adaptive", "avg", "soft", "vote3", "lockin", "chop", "mitigated"],
                    help="Select classifier used for path_a summary: auto (default policy), adaptive, averaged dv, software threshold, temporal vote3, lockin, chop, or mitigated pipeline")
    ap.add_argument("--apply-autotuned-params", action="store_true", help="After autotune, re-evaluate path_a using best params and include as path_a_autotuned")
    ap.add_argument("--use-autotuned-as-primary", action="store_true", help="If set, replace primary path_a summary with path_a_autotuned when available")
    ap.add_argument("--path-b-depth", type=int, default=5, help="If >0, run Path B cascaded for N stages and report per-stage BER (default 5)")
    ap.add_argument("--path-b-sweep", action="store_true", help="Run Path B sweeps (amp_gain_db, sat_I_sat) and report BER curves")
    ap.add_argument("--no-path-b-sweep", action="store_true", help="Disable Path B sweeps (default is ON)")
    ap.add_argument("--path-b-servo-eta", type=float, default=0.05, help="Per-iteration comparator bias adjustment for analog Path B servo (mV per unit error)")
    ap.add_argument("--path-b-guard-deadzone-mV", type=float, default=0.0, help="Dead-zone (mV) for hybrid guard; if >0, enforces sign based on dv with zeros inside dead-zone")
    ap.add_argument("--path-b-guard-gain-mW", type=float, default=0.05, help="Guard injection gain (mW) added symmetrically to the optical rails when guard is active")
    ap.add_argument("--path-b-digital-guard", action="store_true", help="Apply digital sign guard after the analog cascade")
    ap.add_argument("--path-b-digital-deadzone-mV", type=float, default=0.1, help="Dead-zone (mV) for the digital guard accumulator; values within the band map to 0")
    ap.add_argument("--path-b-digital-guard-passes", type=int, default=3, help="Number of analog replays to average before applying the digital guard")
    ap.add_argument("--path-b-calibrate-vth", action="store_true", help="Pre-run Path B dv probe to set comparator thresholds per channel")
    ap.add_argument("--path-b-calibrate-vth-scale", type=float, default=0.25, help="Scale factor applied to median |dv| when auto-calibrating comparator thresholds")
    ap.add_argument("--path-b-calibrate-vth-passes", type=int, default=64, help="Calibration samples to estimate comparator thresholds")
    ap.add_argument("--path-b-calibrate-vth-min", type=float, default=1.0, help="Minimum comparator threshold (mV) during auto-calibration")
    ap.add_argument("--path-b-calibrate-vth-max", type=float, default=40.0, help="Maximum comparator threshold (mV) during auto-calibration")
    ap.add_argument("--path-b-calibrate-vth-apply-guard", action="store_true", help="Apply optical guard bias during comparator auto-zero calibration")
    ap.add_argument("--path-b-calibrate-optical", action="store_true", help="Auto-cancel optical bias using calibration data")
    ap.add_argument("--path-b-optical-trim-final-mW", type=str, default=None, help="Comma-separated per-channel optical trim (mW) applied at final stage")
    ap.add_argument("--path-b-return-map", action="store_true", help="Record Path B return map (dv in/out, slopes, histograms)")
    ap.add_argument("--path-b-optical-bias-scale", type=float, default=1.0, help="Scale subtracting measured stage-0 optical bias during analog pass (default 1.0)")
    ap.add_argument("--path-b-amp-type", type=str, choices=['soa', 'edfa'], default=None, help="Override Path B amplifier type (soa|edfa)")
    ap.add_argument("--path-b-vth-schedule", type=str, default=None, help="Comma-separated comparator vth (mV) per Path B stage during analog cascade")
    ap.add_argument("--path-b-stage-gains-db", type=str, default=None, help="Comma-separated post-stage attenuation (dB, positive=loss, negative=gain) applied after each Path B optical stage")
    ap.add_argument("--path-b-enable-amp", action="store_true", help="Force Path B amplifier on after pack overrides")
    ap.add_argument("--path-b-disable-soa", action="store_true", help="Disable SOA dynamics in Path B baseline")
    ap.add_argument("--return-map-passes", type=int, default=36, help="Passes used when computing the Path B return map")
    ap.add_argument("--return-map-deadzone-mW", type=float, default=0.02, help="Dead-zone (mW) threshold for occupancy metrics in the Path B return map")
    ap.add_argument("--path-b-balanced", action="store_true", help="Use balanced photodiode/TIA path for Path B calculations")
    # Sparse activation (Path B): evaluate with only K active channels per trial
    ap.add_argument("--path-b-sparse-active-k", type=int, default=0, help="If >0, force exactly K active channels per trial (others set to 0)")
    ap.add_argument("--path-b-eval-active-only", action="store_true", help="When using sparse-active-k, compute BER on active channels only (models TDM scanning)")
    ap.add_argument("--path-b-sparse-rotate", action="store_true", help="Cycle deterministically through channel subsets (ceil(N/K) groups) rather than random subsets")
    # Optional TDM realism: EO/WSS switching penalties
    ap.add_argument("--tdm-switch-mode", type=str, choices=["emitter","eo_switch"], default="emitter", help="TDM selection mode: emitter (no switch penalty) or eo_switch (adds switch penalties)")
    ap.add_argument("--tdm-switch-t-ns", type=float, default=0.0, help="EO/WSS switching time penalty per subset (ns)")
    ap.add_argument("--tdm-switch-offiso-db", type=float, default=0.0, help="EO/WSS off isolation during inactive state (dB, leakage adds to crosstalk)")
    ap.add_argument("--tdm-switch-extra-il-db", type=float, default=0.0, help="EO/WSS extra insertion loss (dB) when switching is used")
    # TDM re-centering (optional): periodically re-center comparator vth using recent dv statistics
    ap.add_argument("--path-b-tdm-recenter-interval", type=int, default=0, help="If >0, every N trials compute per-channel vth as 0.5*(mean_pos+mean_neg) over recent frames and apply")
    ap.add_argument("--path-b-tdm-recenter-margin-mV", type=float, default=0.0, help="Optional margin added to computed vth during TDM re-centering")
    ap.add_argument("--path-b-analog-depth", type=int, default=-1, help="If -1, use --path-b-depth; if >0, run analog cascade (optics SA+amp per hop, single final threshold)")
    ap.add_argument("--adaptive-input", action="store_true", help="Integrate multiple frames until dv margin met or max frames (default ON)")
    ap.add_argument("--no-adaptive-input", action="store_true", help="Disable adaptive input integration")
    ap.add_argument("--adaptive-max-frames", type=int, default=12, help="Max frames to integrate for adaptive input")
    ap.add_argument("--adaptive-margin-mV", type=float, default=0.8, help="Extra margin above comparator up-threshold before stopping")
    ap.add_argument("--no-path-b", action="store_true", help="Disable Path B baselines")
    ap.add_argument("--no-path-b-analog", action="store_true", help="Disable Path B analog cascade baseline")
    ap.add_argument("--no-cold-input", action="store_true", help="Disable cold-storage input baseline")
    ap.add_argument("--components-mode", type=str, default="auto", help="Components attribution mode: auto|path_a|cold|path_b_analog")
    ap.add_argument("--mitigated", action="store_true", help="Compute mitigated BER using (chop, avg-frames, linear per-channel calibration)")
    ap.add_argument("--quiet", action="store_true", help="Do not print final JSON to stdout (write file only)")
    ap.add_argument("--progress", action="store_true", help="Emit coarse progress messages to stdout")
    ap.add_argument("--json", type=str, default=None)
    ap.add_argument("--endtoend-report", action="store_true", help="Add an end_to_end block combining Path A and Path B (assumes independent errors)")
    ap.add_argument("--light-output", action="store_true", help="Reduce output size by skipping heavy diagnostic blocks (sensitivity, drift, path-b sweeps, large arrays)")
    # Speed/skip flags
    ap.add_argument("--no-sweeps", action="store_true", help="Skip window/RIN/crosstalk sweeps for faster runs")
    ap.add_argument("--no-cal", action="store_true", help="Skip per-tile/calibration passes")
    ap.add_argument("--no-drift", action="store_true", help="Skip drift demo block")
    ap.add_argument("--fast", action="store_true", help="Shortcut: implies --no-sweeps --no-cal --no-drift and uses smaller internal caps")
    ap.add_argument("--lock-optics-ct", action="store_true", help="Constrain autotuner to keep optics ct_neighbor_db/ct_diag_db at initial values (no worsening)")
    # Vendor pack overrides (paths)
    ap.add_argument("--emitter-pack", type=str, default=None)
    ap.add_argument("--optics-pack", type=str, default=None)
    ap.add_argument("--sensor-pack", type=str, default=None)
    ap.add_argument("--tia-pack", type=str, default=None)
    ap.add_argument("--comparator-pack", type=str, default=None)
    ap.add_argument("--camera-pack", type=str, default=None)
    ap.add_argument("--clock-pack", type=str, default=None)
    ap.add_argument("--thermal-pack", type=str, default=None)
    # Normalization/mitigation toggles
    ap.add_argument("--normalize-dv", action="store_true", help="Normalize dv to comparator threshold scale inside orchestrator")
    ap.add_argument("--normalize-eps-v", type=float, default=1e-6, help="Epsilon to avoid divide-by-zero during dv normalization (V)")
    ap.add_argument("--export-vth", type=str, default=None, help="Export per-channel comparator vth (mV) learned during calibration to this JSON file")
    ap.add_argument("--import-vth", type=str, default=None, help="Import per-channel comparator vth (mV) from JSON file and apply to comparator")
    ap.add_argument("--vth-inline", type=str, default=None, help="Comma-separated per-channel vth (mV) to apply (overrides import)")
    ap.add_argument("--vth-scale", type=float, default=1.0, help="Scale factor applied to per-channel vth vector before use")
    ap.add_argument("--vth-bias-mV", type=float, default=0.0, help="Bias (mV) added to per-channel vth vector before use")
    ap.add_argument("--use-linear-calibration", action="store_true", help="Apply per-channel linear dv correction learned during calibration to classifiers")
    ap.add_argument("--force-cal-in-primary", action="store_true", help="Use calibrated dv_lin and vth in primary classifier decisions when available")
    ap.add_argument("--smooth-calibration", action="store_true", help="Spatially smooth per-channel vth/offset/scale with neighbor averaging")
    ap.add_argument("--calib-samples", type=int, default=0, help="Override number of calibration samples (0 = heuristic)")
    # Legacy calibration compatibility toggles
    ap.add_argument("--legacy-baseline-cal", action="store_true", help="Use legacy-style baseline calibration (no smoothing/deblur; comparator hyst=1.0, vth_sigma=0; no normalize in cal)")
    ap.add_argument("--legacy-cal-no-normalize", action="store_true", help="Disable dv normalization during baseline calibration only")
    ap.add_argument("--use-map-thresh", action="store_true", help="Use Gaussian MAP decision with comparator sigma on dv_lin vs vth")
    ap.add_argument("--fuse-decoder", action="store_true", help="Fuse calibrated score with decoder score for final decision")
    ap.add_argument("--fuse-alpha", type=float, default=0.8, help="Fusion weight alpha for calibrated score (0..1)")
    # Per-channel linear optimizer (adjusts lin_offset per channel)
    ap.add_argument("--optimize-linear", action="store_true", help="Greedy coordinate updates to per-channel dv linear offset to reduce BER on a small fixed set")
    ap.add_argument("--opt-lin-iters", type=int, default=6, help="Linear optimizer iterations")
    ap.add_argument("--opt-lin-step-mV", type=float, default=0.1, help="Per-iteration linear offset step (mV)")
    ap.add_argument("--opt-lin-use-mask", action="store_true", help="Restrict linear optimizer to unmasked channels")
    # Simple linear decoder (per-channel linear classifier on dv and neighbors)
    ap.add_argument("--decoder-linear", action="store_true", help="Train a per-channel linear decoder on dv features and use it for decisions")
    ap.add_argument("--decoder-l2", type=float, default=0.1, help="Ridge regularization for decoder training")
    ap.add_argument("--decoder-samples", type=int, default=320, help="Samples used to train decoder")
    ap.add_argument("--use-decoder-for-path-a", action="store_true", help="Use decoder as primary classifier for path_a summary")
    # MLP decoder
    ap.add_argument("--decoder-mlp", action="store_true", help="Train a tiny MLP decoder on dv features and use it for decisions")
    ap.add_argument("--decoder-mlp-hidden", type=int, default=8, help="Hidden units for MLP decoder")
    ap.add_argument("--decoder-mlp-epochs", type=int, default=10, help="Training epochs for MLP decoder")
    ap.add_argument("--decoder-mlp-lr", type=float, default=0.01, help="Learning rate for MLP decoder")
    # Simple ECC (single parity correction within blocks)
    ap.add_argument("--use-ecc", action="store_true", help="Apply single-parity correction within fixed-size channel blocks to decoder outputs")
    ap.add_argument("--ecc-spc-block", type=int, default=4, help="Block size for single-parity correction")
    # Software autotune (decoder/deblur/gating/mask)
    ap.add_argument("--soft-autotune", action="store_true", help="Autotune software params (decoder/deblur/gating/mask/avg/window) and select best")
    ap.add_argument("--soft-budget", type=int, default=60, help="Number of configurations to evaluate in software autotune")
    # Lightweight local autotuner for window/mask/avg
    ap.add_argument("--local-autotune", action="store_true", help="Run a local search over window/mask/avg and report best path_a")
    ap.add_argument("--la-windows", type=str, default="18,19,20,21", help="Comma-separated window ns for local autotune")
    ap.add_argument("--la-mask-fracs", type=str, default="0.0625,0.09375,0.125", help="Comma-separated mask fractions for local autotune")
    ap.add_argument("--la-avg-frames", type=str, default="2,3", help="Comma-separated avg-frames for local autotune")
    # Comparator override knobs
    ap.add_argument("--comp-hysteresis-mV", type=float, default=None, help="Override comparator hysteresis (mV)")
    ap.add_argument("--comp-input-noise-mV", type=float, default=None, help="Override comparator input noise RMS (mV)")
    ap.add_argument("--comp-vth-mV", type=float, default=None, help="Override comparator base vth (mV)")
    ap.add_argument("--comp-vth-sigma-mV", type=float, default=None, help="Override comparator vth sigma (mV)")
    # Per-channel vth optimizer
    ap.add_argument("--optimize-vth", action="store_true", help="Iteratively adjust per-channel vth to reduce classification errors on a small fixed set")
    ap.add_argument("--opt-vth-iters", type=int, default=6, help="Optimizer iterations")
    ap.add_argument("--opt-vth-step-mV", type=float, default=0.2, help="Per-iteration vth step size (mV)")
    ap.add_argument("--opt-vth-margin-mV", type=float, default=0.0, help="Optional margin when deciding errors for optimizer")
    ap.add_argument("--opt-vth-use-mask", action="store_true", help="Restrict vth optimization to unmasked channels (ignore masked)")
    ap.add_argument("--legacy-cal-estimator-soft", action="store_true", help="Compute baseline_calibrated via dv sign vs vth (no comparator deadband)")
    ap.add_argument("--baseline-cal-binary", action="store_true", help="Evaluate calibrated baseline with ??1 truths only (no zeros)")
    args = ap.parse_args()
    # Defaults to run full non-destructive suite
    run_path_b_sweep = (not getattr(args, 'no_path_b_sweep', False)) or getattr(args, 'path_b_sweep', False)
    args.path_b_sweep = bool(run_path_b_sweep)
    if not getattr(args, 'no_adaptive_input', False):
        args.adaptive_input = True

    # Base system from typ packs inline
    sys_p = SystemParams(channels=int(args.channels), window_ns=float(args.base_window_ns), temp_C=25.0, seed=args.seed,
                         normalize_dv=bool(getattr(args, 'normalize_dv', False)),
                         normalize_eps_v=float(getattr(args, 'normalize_eps_v', 1e-6)),
                         balanced_pd=bool(getattr(args, 'path_b_balanced', False)))
    # Build from overrides if provided (simple loader)
    def _load_yaml(path: str | None):
        if not path:
            return {}
        import importlib, pathlib
        text = pathlib.Path(path).read_text(encoding="utf-8")
        try:
            yaml_mod = importlib.import_module("yaml")
            return yaml_mod.safe_load(text) or {}
        except ModuleNotFoundError:
            return {}

    emit = EmitterParams(channels=sys_p.channels, power_mw_per_ch=0.7, power_sigma_pct=2.0, modulation_mode="pushpull", pushpull_alpha=0.9)
    emit_override = _load_yaml(getattr(args, 'emitter_pack', None))
    for k, v in (emit_override or {}).items():
        if hasattr(emit, k): setattr(emit, k, v)

    optx = OpticsParams(ct_model=("neighbor" if args.neighbor_ct else "global"))
    optx_override = _load_yaml(getattr(args, 'optics_pack', None))
    for k, v in (optx_override or {}).items():
        if hasattr(optx, k): setattr(optx, k, v)
    # Map common vendor-pack fields ??? sim params
    try:
        if isinstance(optx_override, dict):
            if 'transmittance_percent' in optx_override:
                tp = float(optx_override['transmittance_percent'])
                optx.transmittance = max(0.0, min(1.0, tp/100.0))
            if 'scatter_angle_deg_FWHM' in optx_override:
                ang = float(optx_override['scatter_angle_deg_FWHM'])
                # Heuristic: wider scatter ??? higher neighbor leakage (less negative dB)
                neigh = -40.0 + (ang - 5.0) * (10.0 / 15.0)  # 5?????-40dB, 20?????-30dB
                neigh = max(-45.0, min(-28.0, neigh))
                diag = neigh - 3.0
                optx.ct_model = 'neighbor'
                optx.ct_neighbor_db = float(neigh)
                optx.ct_diag_db = float(diag)
                # PSF width proxy
                w = 2.0 + max(0.0, (ang - 5.0)) * 0.2
                optx.psf_kernel = f"lorentzian:w={w:.2f}"
    except Exception:
        pass
    # Ensure neighbor/diag crosstalk are effective when neighbor model is active
    try:
        if isinstance(optx_override, dict) and (("ct_neighbor_db" in optx_override) or ("ct_diag_db" in optx_override)):
            optx.ct_model = 'neighbor'
            if getattr(optx, 'ct_neighbor_db', None) is None:
                base = float(getattr(optx, 'crosstalk_db', -30.0))
                optx.ct_neighbor_db = base
            if getattr(optx, 'ct_diag_db', None) is None:
                optx.ct_diag_db = float(optx.ct_neighbor_db) + 3.0
        elif getattr(optx, 'ct_model', 'global') == 'neighbor':
            base = float(getattr(optx, 'crosstalk_db', -30.0))
            if getattr(optx, 'ct_neighbor_db', None) is None:
                optx.ct_neighbor_db = base
            if getattr(optx, 'ct_diag_db', None) is None:
                optx.ct_diag_db = base + 3.0
    except Exception:
        pass

    pd = PDParams()
    pd_override = _load_yaml(getattr(args, 'sensor_pack', None))
    for k, v in (pd_override or {}).items():
        if hasattr(pd, k): setattr(pd, k, v)

    # Sensitivity mode tunes TIA BW and comparator noise to amplify trends
    tia_bw = 30.0 if args.sensitivity else 120.0
    comp_noise = 0.25 if args.sensitivity else 0.3
    tia = TIAParams(bw_mhz=tia_bw, tia_transimpedance_kohm=5.0, in_noise_pA_rthz=3.0, gain_sigma_pct=1.0)
    tia_override = _load_yaml(getattr(args, 'tia_pack', None))
    for k, v in (tia_override or {}).items():
        if hasattr(tia, k): setattr(tia, k, v)

    comp = ComparatorParams(input_noise_mV_rms=comp_noise, vth_mV=5.0, vth_sigma_mV=0.2)
    comp_override = _load_yaml(getattr(args, 'comparator_pack', None))
    for k, v in (comp_override or {}).items():
        if hasattr(comp, k): setattr(comp, k, v)
    # Apply comparator CLI overrides if provided
    try:
        if getattr(args, 'comp_hysteresis_mV', None) is not None:
            comp.hysteresis_mV = float(args.comp_hysteresis_mV)
        if getattr(args, 'comp_input_noise_mV', None) is not None:
            comp.input_noise_mV_rms = float(args.comp_input_noise_mV)
        if getattr(args, 'comp_vth_mV', None) is not None:
            comp.vth_mV = float(args.comp_vth_mV)
        if getattr(args, 'comp_vth_sigma_mV', None) is not None:
            comp.vth_sigma_mV = float(args.comp_vth_sigma_mV)
    except Exception:
        pass

    clk = ClockParams(window_ns=float(args.base_window_ns), jitter_ps_rms=10.0)
    clk_override = _load_yaml(getattr(args, 'clock_pack', None))
    for k, v in (clk_override or {}).items():
        if hasattr(clk, k): setattr(clk, k, v)
    # Ensure CLI --base-window-ns always wins over pack defaults
    try:
        clk.window_ns = float(args.base_window_ns)
    except Exception:
        pass
    orch = Orchestrator(sys_p, emit, optx, pd, tia, comp, clk)

    # Helper: accumulate dv across frames using selected kernel
    deblur_params = {"aL": None, "aR": None}

    # Helper: approximate Gaussian MAP probability using logistic approximation
    def _map_prob_from_dv(dv_lin_vec, vth_vec, sigma_mV):
        import numpy as _np
        s = float(max(1e-6, sigma_mV))
        z = (dv_lin_vec - (vth_vec if vth_vec is not None else 0.0)) / s
        k = 1.8137993642342178  # pi/sqrt(3)
        return 1.0 / (1.0 + _np.exp(-k * z))

    # Helper: compute decoder probability P(+1) given features
    def _decoder_prob_from_feats(feats, dec):
        import numpy as _np
        if dec is None:
            return None
        if bool(dec.get("mlp")):
            Z1 = feats @ dec["W1"] + dec["b1"]
            A1 = _np.tanh(Z1)
            Z2 = A1 @ dec["W2"] + dec["b2"]
            return 1.0 / (1.0 + _np.exp(-Z2.reshape(-1)))
        w = dec.get("w")
        if w is None:
            return None
        score = feats @ w
        return 1.0 / (1.0 + _np.exp(-score))

    # Helper: fuse two probabilities
    def _fuse_probs(p_cal, p_dec, alpha):
        import numpy as _np
        if p_cal is None:
            return p_dec
        if p_dec is None:
            return p_cal
        a = float(_np.clip(alpha, 0.0, 1.0))
        return a * p_cal + (1.0 - a) * p_dec

    # Helper: single-parity correction within blocks; assumes last bit in block is parity
    def _apply_spc(pred_pm1, prob_pos, block_size):
        import numpy as _np
        B = int(max(2, block_size))
        pred_bin = (_np.asarray(pred_pm1, dtype=int) > 0).astype(int)
        out = pred_bin.copy()
        probs = _np.asarray(prob_pos, dtype=float)
        M = pred_bin.shape[0]
        for i in range(0, M, B):
            j = min(M, i + B)
            if (j - i) < B:
                continue
            blk = pred_bin[i:j]
            # expected parity: XOR of first B-1 equals last bit
            exp_par = 0
            if B > 1:
                exp_par = int(_np.bitwise_xor.reduce(blk[:-1]))
            if exp_par != blk[-1]:
                conf = _np.abs(probs[i:j] - 0.5)
                k = int(_np.argmin(conf))
                out[i + k] = 1 - out[i + k]
        return _np.where(out > 0, 1, -1).astype(int)

    def _accumulate_dv_over_frames(_orch, _tern, _N: int, _kernel: str, _alpha: float):
        import numpy as _np
        acc = None
        for _j in range(max(1, int(_N))):
            r = _orch.step(force_ternary=_tern)
            dv = _np.array(r.get("dv_mV", [0]*_orch.sys.channels))
            # Deblur with learned taps if available
            if deblur_params.get("aL") is not None and dv.size > 1:
                l = _np.roll(dv, 1); rr = _np.roll(dv, -1)
                dv = dv - deblur_params["aL"]*l - deblur_params["aR"]*rr
            # Deblur with fixed neighbor taps if enabled
            if float(_alpha) > 0.0 and dv.size > 1:
                dv_l = _np.roll(dv, 1); dv_r = _np.roll(dv, -1)
                dv = dv - float(_alpha)*(dv_l + dv_r)
            if acc is None:
                acc = dv.astype(float)
            else:
                if _kernel == "ewma":
                    acc = float(_alpha)*dv + (1.0-float(_alpha))*acc
                else:  # sum
                    acc = acc + dv
        return acc if acc is not None else _np.zeros(_orch.sys.channels, dtype=float)

    # Parse windows and ranges
    windows = [float(w) for w in args.windows.split(",") if w.strip()]
    rin_s, rin_e, rin_n = [v.strip() for v in args.rin_range.split(":")]
    ct_s, ct_e, ct_n = [v.strip() for v in args.ct_range.split(":")]

    # Short, pragmatic sweeps
    if not (getattr(args, 'no_sweeps', False) or getattr(args, 'fast', False)):
        w_xs, w_ys, w_ok = quick_window_sweep(orch, trials=args.trials, windows=windows)
        r_xs, r_ys, r_ok = quick_rin_sweep(sys_p, trials=args.trials, starts=float(rin_s), stops=float(rin_e), steps=int(rin_n), tia_bw_mhz=tia_bw, comp_noise_mV=comp_noise)
        c_xs, c_ys, c_ok = quick_crosstalk_sweep(sys_p, trials=args.trials, starts=float(ct_s), stops=float(ct_e), steps=int(ct_n), tia_bw_mhz=tia_bw, comp_noise_mV=comp_noise)
    else:
        w_xs, w_ys, w_ok = [float(args.base_window_ns)], [None], True
        r_xs, r_ys, r_ok = [], [], True
        c_xs, c_ys, c_ok = [], [], True

    # Baseline summary at default settings (use same policy for baseline and path_a)
    base_emit = EmitterParams(channels=sys_p.channels, modulation_mode="pushpull", pushpull_alpha=0.9)
    base_optx = OpticsParams(ct_model=("neighbor" if args.neighbor_ct else "global"))
    base_pd = PDParams()
    base_tia = TIAParams(bw_mhz=tia_bw)
    base_comp = ComparatorParams(input_noise_mV_rms=comp_noise, vth_mV=5.0, hysteresis_mV=1.8, vth_sigma_mV=0.2)
    base_clk = ClockParams(window_ns=float(args.base_window_ns), jitter_ps_rms=10.0)
    base_orch = Orchestrator(sys_p, base_emit, base_optx, base_pd, base_tia, base_comp, base_clk)
    # Hoist placeholder for per-channel threshold vector used in primary classifiers
    vth_vec_pa = None
    # Optional: import per-channel vth (mV) and apply to primary and baseline comparators
    try:
        imp_path = getattr(args, 'import_vth', None)
        inline = getattr(args, 'vth_inline', None)
        import numpy as _np
        vec = None
        if isinstance(inline, str) and inline:
            parts = [p.strip() for p in inline.split(',') if p.strip()]
            if parts:
                vec = _np.asarray([float(p) for p in parts], dtype=float)
        elif isinstance(imp_path, str) and imp_path:
            import json as _json, pathlib as _pathlib
            arr = _json.loads(_pathlib.Path(imp_path).read_text(encoding="utf-8"))
            vec = _np.asarray(arr, dtype=float)
        # Apply vector if provided
        if vec is not None:
            # Optional global scale/bias on per-channel vth
            try:
                s = float(getattr(args, 'vth_scale', 1.0)); b = float(getattr(args, 'vth_bias_mV', 0.0))
                vec = s*vec + b
            except Exception:
                pass
            orch.comp.set_vth_per_channel(vec)
            try:
                base_orch.comp.set_vth_per_channel(vec)
            except Exception:
                pass
    except Exception:
        pass
    # Apply per-channel vth from comparator pack if provided (key: vth_per_channel_mV)
    try:
        if isinstance(comp_override, dict) and isinstance(comp_override.get('vth_per_channel_mV'), list):
            import numpy as _np
            v = _np.asarray(comp_override.get('vth_per_channel_mV'), dtype=float)
            orch.comp.set_vth_per_channel(v)
            try:
                base_orch.comp.set_vth_per_channel(v)
            except Exception:
                pass
    except Exception:
        pass
    # Optional adaptive integration for input stage only (baseline)
    if args.adaptive_input:
        import numpy as _np
        errs = []
        T = int(args.trials)
        maxN = max(1, int(args.adaptive_max_frames))
        margin = float(args.adaptive_margin_mV)
        for _ in range(min(T, 400)):
            tern = base_orch.rng.integers(-1, 2, size=base_orch.sys.channels)
            acc = _np.zeros(base_orch.sys.channels, dtype=float)
            for k in range(maxN):
                r = base_orch.step(force_ternary=tern)
                dv = _np.array(r.get("dv_mV", [0]*base_orch.sys.channels))
                if dv.shape[0] != base_orch.sys.channels:
                    dv = dv[:base_orch.sys.channels]
                acc = acc[:dv.shape[0]]
                acc += dv
                up_th = float(base_orch.comp.p.vth_mV) + 0.5*float(base_orch.comp.p.hysteresis_mV)
                if _np.all(_np.abs(acc) >= (up_th + margin)):
                    break
            pred = _np.sign(acc)
            errs.append(float(_np.mean(pred != tern)))
        base_summary = {
            "p50_ber": float(_np.median(errs)) if errs else None,
            "p50_energy_pj": None,
            "window_ns": float(base_orch.clk.p.window_ns),
        }
    else:
        base_summary = base_orch.run(trials=args.trials)
        # Confidence interval for baseline (approximate using aggregated n_bits/n_err from a short rerun)
        try:
            rows_b = run_trials(base_orch, min(args.trials, 200))
            n_bits = sum(int(r.get("n_bits") or 0) for r in rows_b)
            n_err = sum(int(r.get("n_err") or 0) for r in rows_b)
            lo, hi = _wilson_ci(n_err, n_bits)
            if lo is not None:
                base_summary["ber_ci95"] = {"lo": lo, "hi": hi, "n_bits": int(n_bits), "n_err": int(n_err)}
        except Exception:
            pass
    # Add mean_ber to baseline using a lightweight re-run (bounded)
    try:
        _rows_b = run_trials(base_orch, min(args.trials, 200))
        base_summary["mean_ber"] = mean_ber(_rows_b)
    except Exception:
        pass

    # Cold-storage input path (parallel baseline)
    cold_summary = None
    if not getattr(args, 'no_cold_input', False):
        try:
            cold_emit = ColdReader(ColdParams(channels=sys_p.channels))
            cold_orch = Orchestrator(sys_p, EmitterParams(channels=sys_p.channels), base_optx, base_pd, base_tia, base_comp, base_clk, emitter_override=cold_emit)
            cold_summary = cold_orch.run(trials=args.trials)
        except Exception:
            cold_summary = {"error": "cold_input_failed"}

    # Path B estimate (enable saturable absorber + optical amplifier in optics)
    path_b_summary = None
    path_b_chain = None
    path_b_sweeps = None
    path_b_return_map = None
    try:
        b_emit = EmitterParams(**emit.__dict__)
        b_optx = OpticsParams(**optx.__dict__)
        b_optx.channels = int(args.channels)
        b_optx.sat_abs_on = False
        b_optx.amp_on = False
        b_optx.soa_on = True
        b_optx.mzi_on = True
        if getattr(args, 'path_b_enable_amp', False):
            b_optx.amp_on = True
        amp_type = getattr(args, 'path_b_amp_type', None)
        if amp_type:
            b_optx.amp_on = True
            b_optx.amp_type = amp_type.lower()
            if b_optx.amp_type != 'soa':
                b_optx.soa_on = False
            # EDFA nudges: ensure shaping and contraction knobs present
            try:
                if b_optx.amp_type == 'edfa':
                    if float(getattr(b_optx, 'soa_small_signal_gain_db', 0.0)) == 0.0:
                        # Map from generic amp_gain_db if present, else default
                        if hasattr(b_optx, 'amp_gain_db'):
                            b_optx.soa_small_signal_gain_db = float(getattr(b_optx, 'amp_gain_db', 6.0))
                        else:
                            b_optx.soa_small_signal_gain_db = 6.0
                    # Encourage contraction via post-VOA and activation shaping
                    try:
                        if float(getattr(b_optx, 'voa_post_db', 0.0)) < 2.0:
                            b_optx.voa_post_db = 2.0
                    except Exception:
                        pass
                    b_optx.sat_abs_on = True
                    if float(getattr(b_optx, 'sat_I_sat', 0.0)) <= 0.0:
                        b_optx.sat_I_sat = 0.8
                    if float(getattr(b_optx, 'sat_alpha', 0.0)) < 1.0:
                        b_optx.sat_alpha = 1.0
                    # Post-clip to keep rails
                    try:
                        b_optx.post_clip_on = True
                        if float(getattr(b_optx, 'post_clip_sat_mw', 0.0)) <= 0.0:
                            b_optx.post_clip_sat_mw = 0.1
                    except Exception:
                        pass
            except Exception:
                pass
        if getattr(args, 'path_b_disable_soa', False):
            b_optx.soa_on = False
        b_pd = PDParams(**pd.__dict__)
        b_tia = TIAParams(**tia.__dict__)
        b_comp = ComparatorParams(**comp.__dict__)
        b_clk = ClockParams(**clk.__dict__)
        b_orch = Orchestrator(sys_p, b_emit, b_optx, b_pd, b_tia, b_comp, b_clk)
        analog_depth = int(getattr(args, 'path_b_analog_depth', -1))
        if analog_depth == -1:
            analog_depth = int(getattr(args, 'path_b_depth', 0))

        if int(getattr(args, 'path_b_analog_depth', 0)) > 0 or int(getattr(args, 'path_b_depth', 0)) > 0:
            try:
                b_orch.sys.reset_analog_state_each_frame = False
            except AttributeError:
                pass
        if not getattr(args, 'no_path_b', False):
            path_b_summary = b_orch.run(trials=args.trials)

        stage_gain_schedule = _parse_csv_floats(getattr(args, 'path_b_stage_gains_db', None))
        vth_schedule = _parse_csv_floats(getattr(args, 'path_b_vth_schedule', None))



        if analog_depth > 0 and (not getattr(args, 'no_path_b_analog', False)):
            import numpy as _np
            guard_deadzone = float(getattr(args, 'path_b_guard_deadzone_mV', 0.0))
            guard_gain = float(getattr(args, 'path_b_guard_gain_mW', 0.05))
            use_digital_guard = bool(getattr(args, 'path_b_digital_guard', False))
            balanced_pd = bool(getattr(args, 'path_b_balanced', False))
            digital_deadzone = float(getattr(args, 'path_b_digital_deadzone_mV', 0.1))
            guard_passes = max(1, int(getattr(args, 'path_b_digital_guard_passes', 3)) if use_digital_guard else 1)
            eta = float(getattr(args, 'path_b_servo_eta', 0.05))
            if vth_schedule:
                eta = 0.0
            bias_scale = float(getattr(args, 'path_b_optical_bias_scale', 1.0))
            # Sparse activation parameters (optional TDM-style evaluation)
            sparse_k = max(0, int(getattr(args, 'path_b_sparse_active_k', 0)))
            eval_active_only = bool(getattr(args, 'path_b_eval_active_only', False))
            sparse_rotate = bool(getattr(args, 'path_b_sparse_rotate', False))
            sparse_group_idx = 0

            # Calibration and auto-zero for Path B (kept within try/analog block)
            cal_offsets = None
            cal_trim_vec = None
            cal_optical_bias = None
            cal_optical_trim_final = None
            if getattr(args, 'path_b_calibrate_vth', False):
                cal_passes = max(1, min(int(getattr(args, 'path_b_calibrate_vth_passes', 64)), args.trials))
                cal_guard_gain = guard_gain if bool(getattr(args, 'path_b_calibrate_vth_apply_guard', False)) else 0.0
                offset_samples = []
                trim_samples = []
                bias_samples = []
                final_bias_samples = []
                tern_zero = _np.zeros(b_orch.sys.channels, dtype=int)
                tern_plus = _np.ones(b_orch.sys.channels, dtype=int)
                tern_minus = -tern_plus
                for _cal in range(cal_passes):
                    for mode, tern_cal in (("zero", tern_zero), ("plus", tern_plus), ("minus", tern_minus)):
                        dt_cal, stage_outputs_cal, base_vth_vec_cal = _run_pathb_stage_pass(
                            b_orch, tern_cal, analog_depth, stage_gain_schedule, vth_schedule)
                        stage0 = stage_outputs_cal[0]
                        Pp_cal = stage0[0].copy()
                        Pm_cal = stage0[1].copy()
                        diff_opt = Pp_cal - Pm_cal
                        if mode == "zero":
                            bias_samples.append(diff_opt.copy())
                        if cal_guard_gain > 0.0:
                            adjust = cal_guard_gain * _np.sign(diff_opt)
                            if guard_deadzone > 0.0:
                                adjust[_np.abs(diff_opt) < guard_deadzone] = 0.0
                            Pp_cal = _np.clip(Pp_cal + 0.5 * adjust, 0.0, None)
                            Pm_cal = _np.clip(Pm_cal - 0.5 * adjust, 0.0, None)
                        Ip_cal = b_orch.pd.simulate(Pp_cal, dt_cal)
                        Im_cal = b_orch.pd.simulate(Pm_cal, dt_cal)
                        if balanced_pd:
                            diff_current = Ip_cal - Im_cal
                            Ip_cal = diff_current
                            Im_cal = -diff_current
                        Vp_cal = b_orch.tia.simulate(Ip_cal, dt_cal)
                        Vm_cal = b_orch.tia.simulate(Im_cal, dt_cal)
                        dv_cal_mV = (Vp_cal - Vm_cal) * 1e3
                        if mode == "zero":
                            offset_samples.append(dv_cal_mV)
                            trim_samples.append(_np.abs(dv_cal_mV))
                        if mode in ("plus", "minus"):
                            final_bias_samples.append(stage_outputs_cal[-1][3].copy())
                        if vth_schedule and base_vth_vec_cal is not None:
                            b_orch.comp.set_vth_per_channel(base_vth_vec_cal)
                path_b_summary = dict(path_b_summary or {})
                if bias_samples:
                    bias_stack = _np.stack(bias_samples, axis=0)
                    cal_optical_bias = _np.median(bias_stack, axis=0)
                    path_b_summary['calibrated_optical_bias_mW'] = cal_optical_bias.tolist()
                if final_bias_samples:
                    final_bias_stack = _np.stack(final_bias_samples, axis=0)
                    cal_optical_trim_final = _np.median(final_bias_stack, axis=0)
                    path_b_summary['calibrated_optical_trim_final_mW'] = cal_optical_trim_final.tolist()
                if offset_samples:
                    offset_stack = _np.stack(offset_samples, axis=0)
                    cal_offsets = _np.median(offset_stack, axis=0)
                    b_orch.comp.set_offset_per_channel(cal_offsets)
                    path_b_summary['calibrated_offset_mV'] = cal_offsets.tolist()
                if trim_samples:
                    trim_stack = _np.stack(trim_samples, axis=0)
                    scale = float(getattr(args, 'path_b_calibrate_vth_scale', 1.0))
                    min_v = float(getattr(args, 'path_b_calibrate_vth_min', -200.0))
                    max_v = float(getattr(args, 'path_b_calibrate_vth_max', 200.0))
                    cal_trim_vec = _np.clip(_np.median(trim_stack, axis=0) * scale, min_v, max_v)
                    path_b_summary['calibrated_vth_mV'] = cal_trim_vec.tolist()
            if cal_trim_vec is not None and not vth_schedule:
                b_orch.comp.set_vth_per_channel(cal_trim_vec)
            if cal_trim_vec is not None and not vth_schedule:
                b_orch.comp.set_vth_per_channel(cal_trim_vec)
            vth_vec = _np.zeros(b_orch.sys.channels, dtype=float)
            T = min(args.trials, 200)
            recenter_interval = int(getattr(args, 'path_b_tdm_recenter_interval', 0))
            recenter_margin = float(getattr(args, 'path_b_tdm_recenter_margin_mV', 0.0))
            _dv_hist = []  # list of dv arrays
            _truth_hist = []  # list of truth arrays
            _tdm_recenter_events = 0
            errs = []
            _n_bits_acc = 0
            _n_err_acc = 0
            stage_errs_prev = [[] for _ in range(analog_depth)]
            stage_errs_initial = [[] for _ in range(analog_depth)]
            for t_idx in range(T):
                # Base ternary vector
                tern0 = b_orch.rng.integers(-1, 2, size=b_orch.sys.channels)
                active_mask_trial = None
                if sparse_k > 0:
                    # Enforce exactly K active channels; others set to 0
                    N = int(b_orch.sys.channels)
                    k = min(sparse_k, N)
                    if sparse_rotate:
                        groups = max(1, (N + k - 1)//k)
                        g = sparse_group_idx % groups
                        start = g * k
                        idx = list(range(start, min(start + k, N)))
                        # pad if last group smaller
                        if len(idx) < k:
                            idx += list(range(0, k - len(idx)))
                        sparse_group_idx += 1
                    else:
                        idx = b_orch.rng.choice(N, size=k, replace=False)
                    tern0 = _np.zeros(N, dtype=int)
                    tern0[idx] = b_orch.rng.choice(_np.array([-1, 1], dtype=int), size=k, replace=True)
                    active_mask_trial = _np.zeros(N, dtype=bool)
                    active_mask_trial[idx] = True
                dv_pass = []
                out_pass = []
                stage_signs_last = None
                for _rep in range(guard_passes):
                    dt, stage_outputs, base_vth_vec = _run_pathb_stage_pass(
                        b_orch, tern0, analog_depth, stage_gain_schedule, vth_schedule)
                    stage_signs = []
                    for stage_idx, (Pp_stage, Pm_stage, _diff_in, _diff_out) in enumerate(stage_outputs):
                        if cal_optical_bias is not None and stage_idx == 0:
                            bias = cal_optical_bias * bias_scale
                            if bias.shape[0] != Pp_stage.shape[0]:
                                bias = _np.full(Pp_stage.shape[0], float(_np.median(bias)))
                            Pp_stage = _np.clip(Pp_stage - 0.5 * bias, 0.0, None)
                            Pm_stage = _np.clip(Pm_stage + 0.5 * bias, 0.0, None)
                        Ip_stage = b_orch.pd.simulate(Pp_stage.copy(), dt)
                        Im_stage = b_orch.pd.simulate(Pm_stage.copy(), dt)
                        if balanced_pd:
                            diff_current = Ip_stage - Im_stage
                            Ip_stage = diff_current
                            Im_stage = -diff_current
                        if vth_schedule:
                            vth_idx = stage_idx if stage_idx < len(vth_schedule) else len(vth_schedule) - 1
                            stage_vth = float(vth_schedule[vth_idx])
                            target_vth = _np.full(b_orch.sys.channels, stage_vth, dtype=float)
                            if cal_trim_vec is not None:
                                target_vth = target_vth + cal_trim_vec
                            b_orch.comp.set_vth_per_channel(target_vth)
                        elif cal_trim_vec is not None:
                            b_orch.comp.set_vth_per_channel(cal_trim_vec)
                        Vp_stage = b_orch.tia.simulate(Ip_stage, dt)
                        Vm_stage = b_orch.tia.simulate(Im_stage, dt)
                        stage_signs.append(_np.asarray(b_orch.comp.simulate(Vp_stage, Vm_stage, b_orch.sys.temp_C), dtype=int))
                    stage_signs_last = [arr.copy() for arr in stage_signs]
                    Pp_final = stage_outputs[-1][0].copy()
                    Pm_final = stage_outputs[-1][1].copy()
                    if cal_optical_bias is not None:
                        bias = cal_optical_bias * bias_scale
                        if bias.shape[0] != Pp_final.shape[0]:
                            bias = _np.full(Pp_final.shape[0], float(_np.median(bias)))
                        Pp_final = _np.clip(Pp_final - 0.5 * bias, 0.0, None)
                        Pm_final = _np.clip(Pm_final + 0.5 * bias, 0.0, None)
                    if guard_gain > 0.0:
                        diff_opt = Pp_final - Pm_final
                        adjust = guard_gain * _np.sign(diff_opt)
                        if guard_deadzone > 0.0:
                            adjust[_np.abs(diff_opt) < guard_deadzone] = 0.0
                        Pp_final = _np.clip(Pp_final + 0.5 * adjust, 0.0, None)
                        Pm_final = _np.clip(Pm_final - 0.5 * adjust, 0.0, None)
                    Ip = b_orch.pd.simulate(Pp_final, dt)
                    Im = b_orch.pd.simulate(Pm_final, dt)
                    if balanced_pd:
                        diff_current = Ip - Im
                        Ip = diff_current
                        Im = -diff_current
                    if vth_schedule:
                        vth_idx = analog_depth - 1 if analog_depth - 1 < len(vth_schedule) else len(vth_schedule) - 1
                        stage_vth = float(vth_schedule[vth_idx])
                        target_vth = _np.full(b_orch.sys.channels, stage_vth, dtype=float)
                        if cal_trim_vec is not None:
                            target_vth = target_vth + cal_trim_vec
                        b_orch.comp.set_vth_per_channel(target_vth)
                    elif cal_trim_vec is not None:
                        b_orch.comp.set_vth_per_channel(cal_trim_vec)
                    Vp = b_orch.tia.simulate(Ip, dt)
                    Vm = b_orch.tia.simulate(Im, dt)
                    dv_final = (Vp - Vm) * 1e3
                    out = b_orch.comp.simulate(Vp, Vm, b_orch.sys.temp_C)
                    error = _np.asarray(out, dtype=float) - _np.asarray(tern0, dtype=float)
                    if eta > 0.0:
                        vth_vec = _np.clip(vth_vec + eta * error, -15.0, 15.0)
                        update_vth = vth_vec if cal_trim_vec is None else cal_trim_vec + vth_vec
                        b_orch.comp.set_vth_per_channel(update_vth)
                    dv_pass.append(dv_final)
                    out_pass.append(out)
                    if vth_schedule and base_vth_vec is not None:
                        base_target = base_vth_vec
                        if cal_trim_vec is not None:
                            base_target = cal_trim_vec + base_target
                        b_orch.comp.set_vth_per_channel(base_target)
                    elif cal_trim_vec is not None:
                        b_orch.comp.set_vth_per_channel(cal_trim_vec)
                if use_digital_guard:
                    dv_mean = _np.mean(_np.stack(dv_pass), axis=0)
                    guard_out = _np.sign(dv_mean)
                    if digital_deadzone > 0.0:
                        guard_out[_np.abs(dv_mean) < digital_deadzone] = 0.0
                    out_arr = guard_out.astype(int)
                elif guard_gain > 0.0 or guard_deadzone > 0.0:
                    dv_last = dv_pass[-1]
                    guard_out = _np.sign(dv_last)
                    if digital_deadzone > 0.0:
                        guard_out[_np.abs(dv_last) < digital_deadzone] = 0.0
                    out_arr = guard_out.astype(int)
                else:
                    out_arr = _np.asarray(out_pass[-1], dtype=int)
                if active_mask_trial is not None and eval_active_only:
                    am = _np.asarray(active_mask_trial, dtype=bool)
                    if am.any():
                        mism = (out_arr[am] != tern0[am])
                        errs.append(float(_np.mean(mism)))
                        _n_bits_acc += int(_np.sum(am))
                        _n_err_acc += int(_np.sum(mism))
                    else:
                        errs.append(0.0)
                else:
                    mism = (out_arr != tern0)
                    errs.append(float(_np.mean(mism)))
                    _n_bits_acc += int(len(out_arr))
                    _n_err_acc += int(_np.sum(mism))

                # Optional periodic re-centering of comparator vth using recent dv statistics
                try:
                    if recenter_interval > 0:
                        # Use final dv of this iteration
                        dv_for_hist = dv_pass[-1] if dv_pass else None
                        if dv_for_hist is not None:
                            _dv_hist.append(_np.asarray(dv_for_hist, dtype=float))
                            _truth_hist.append(_np.asarray(tern0, dtype=int))
                            # keep only last N
                            if len(_dv_hist) > recenter_interval:
                                _dv_hist = _dv_hist[-recenter_interval:]
                                _truth_hist = _truth_hist[-recenter_interval:]
                        if (t_idx + 1) % recenter_interval == 0 and _dv_hist:
                            dv_stack = _np.stack(_dv_hist, axis=0)
                            tr_stack = _np.stack(_truth_hist, axis=0)
                            with _np.errstate(invalid='ignore'):
                                pos_mask = tr_stack > 0
                                neg_mask = tr_stack < 0
                                pos_vals = _np.where(pos_mask, dv_stack, _np.nan)
                                neg_vals = _np.where(neg_mask, dv_stack, _np.nan)
                                pos_mean = _np.nanmean(pos_vals, axis=0)
                                neg_mean = _np.nanmean(neg_vals, axis=0)
                                v_auto = 0.5 * (pos_mean + neg_mean)
                                v_auto = _np.nan_to_num(v_auto, nan=0.0)
                                if recenter_margin != 0.0:
                                    v_auto = v_auto + float(recenter_margin)
                                # Respect active-only masking if provided
                                if active_mask_trial is not None and eval_active_only:
                                    mask = _np.asarray(active_mask_trial, dtype=bool)
                                    v_apply = _np.where(mask, v_auto, 0.0)
                                else:
                                    v_apply = v_auto
                                if cal_trim_vec is not None:
                                    v_apply = v_apply + cal_trim_vec
                                b_orch.comp.set_vth_per_channel(v_apply)
                                _tdm_recenter_events += 1
                except Exception:
                    pass
                if stage_signs_last is not None:
                    prev_vec = _np.asarray(tern0, dtype=int)
                    for stage_idx, stage_out_vec in enumerate(stage_signs_last):
                        stage_out_vec = _np.asarray(stage_out_vec, dtype=int)
                        prev = prev_vec if stage_idx == 0 else _np.asarray(stage_signs_last[stage_idx - 1], dtype=int)
                        stage_errs_prev[stage_idx].append(float(_np.mean(stage_out_vec != prev)))
                        stage_errs_initial[stage_idx].append(float(_np.mean(stage_out_vec != prev_vec)))
            path_b_summary = dict(path_b_summary or {})
            path_b_summary['analog_depth'] = analog_depth
            path_b_summary['analog_p50_ber'] = float(_np.median(errs)) if errs else None
            # Confidence interval for analog TDM run from accumulated counts
            try:
                _lo, _hi = _wilson_ci(_n_err_acc, _n_bits_acc)
                if _lo is not None:
                    path_b_summary["ber_ci95"] = {"lo": _lo, "hi": _hi, "n_bits": int(_n_bits_acc), "n_err": int(_n_err_acc)}
            except Exception:
                pass
            # Throughput estimate for sparse activation (TDM)
            try:
                if sparse_k > 0:
                    import math as _math
                    subsets = max(1, _math.ceil(int(b_orch.sys.channels) / float(max(1, sparse_k))))
                    micro_passes = int(subsets * max(1, analog_depth) * max(1, guard_passes))
                    symbol_time_ns = float(micro_passes) * float(b_orch.clk.p.window_ns)
                    # Optional EO/WSS switching penalty per subset
                    try:
                        mode = str(getattr(args, 'tdm_switch_mode', 'emitter')).lower()
                        t_sw = float(getattr(args, 'tdm_switch_t_ns', 0.0))
                        if mode == 'eo_switch' and t_sw > 0.0:
                            symbol_time_ns += float(subsets) * t_sw
                    except Exception:
                        pass
                    tdm_symbols_per_s = (1e9 / symbol_time_ns) if symbol_time_ns > 0 else None
                    path_b_summary['sparse_active_k'] = int(sparse_k)
                    path_b_summary['eval_active_only'] = bool(eval_active_only)
                    path_b_summary['window_ns'] = float(b_orch.clk.p.window_ns)
                    path_b_summary['tdm_micro_passes'] = micro_passes
                    path_b_summary['tdm_symbol_time_ns'] = symbol_time_ns
                    path_b_summary['tdm_symbols_per_s'] = float(tdm_symbols_per_s) if tdm_symbols_per_s is not None else None
                    # Record switch realism flags if present
                    try:
                        path_b_summary['tdm_switch_mode'] = str(getattr(args, 'tdm_switch_mode', 'emitter'))
                        path_b_summary['tdm_switch_t_ns'] = float(getattr(args, 'tdm_switch_t_ns', getattr(args, 'tdm_switch_t_ns', 0.0))) if hasattr(args, 'tdm_switch_t_ns') else float(getattr(args, 'tdm_switch_t_ns', 0.0))
                    except Exception:
                        pass
                    # Energy proxy: scale baseline per-trial p50 energy by micro-passes
                    try:
                        base_e = None
                        if isinstance(path_b_summary.get('p50_energy_pj'), (int, float)):
                            base_e = float(path_b_summary.get('p50_energy_pj'))
                        elif isinstance(base_summary.get('p50_energy_pj'), (int, float)):
                            base_e = float(base_summary.get('p50_energy_pj'))
                        if base_e is not None:
                            path_b_summary['tdm_pj_per_symbol_est'] = float(base_e) * float(micro_passes)
                    except Exception:
                        pass
                    # Re-center duty reporting (if enabled)
                    try:
                        if recenter_interval > 0:
                            total_frames = int(len(_dv_hist)) if '_dv_hist' in locals() else 0
                            path_b_summary['tdm_recenter_interval'] = int(recenter_interval)
                            path_b_summary['tdm_recenter_frames_observed'] = total_frames
                            path_b_summary['tdm_recenter_events'] = int(_tdm_recenter_events)
                            path_b_summary['tdm_recenter_duty'] = (float(_tdm_recenter_events) / max(1.0, float(total_frames))) if total_frames > 0 else 0.0
                    except Exception:
                        pass
                    # Record amplifier/activation shaping used (for sweeps/analysis)
                    try:
                        path_b_summary['amp_type'] = str(getattr(b_optx, 'amp_type', 'soa'))
                        path_b_summary['voa_post_db'] = float(getattr(b_optx, 'voa_post_db', 0.0))
                        path_b_summary['sat_abs_on'] = bool(getattr(b_optx, 'sat_abs_on', False))
                        path_b_summary['sat_I_sat'] = float(getattr(b_optx, 'sat_I_sat', 0.0))
                        path_b_summary['sat_alpha'] = float(getattr(b_optx, 'sat_alpha', 0.0))
                    except Exception:
                        pass
            except Exception:
                pass
            path_b_chain = {
                'depth': analog_depth,
                'per_stage_p50_ber_vs_prev': [float(_np.median(e)) if e else None for e in stage_errs_prev],
                'per_stage_p50_ber_vs_initial': [float(_np.median(e)) if e else None for e in stage_errs_initial],
            }

        if getattr(args, 'path_b_return_map', False) and (not getattr(args, 'no_path_b', False)):
            rm_depth = analog_depth if analog_depth > 0 else int(getattr(args, 'path_b_depth', 0))
            if rm_depth > 0:
                rm_passes = max(1, int(getattr(args, 'return_map_passes', 36)))
                deadzone_mw = max(1e-6, float(getattr(args, 'return_map_deadzone_mW', 0.02)))
                try:
                    path_b_return_map = _compute_pathb_return_map(
                        SystemParams(**sys_p.__dict__),
                        EmitterParams(**b_emit.__dict__),
                        OpticsParams(**b_optx.__dict__),
                        PDParams(**b_pd.__dict__),
                        TIAParams(**b_tia.__dict__),
                        ComparatorParams(**b_comp.__dict__),
                        ClockParams(**b_clk.__dict__),
                        rm_depth,
                        rm_passes,
                        deadzone_mw,
                        seed_offset=int(getattr(args, 'seed', 0)) ^ 0x5A5A,
                        stage_gains_db=stage_gain_schedule,
                        vth_schedule_mV=vth_schedule
                    )
                except Exception:
                    path_b_return_map = {"error": "return_map_failed"}

    except Exception as exc:
        import traceback, sys
        print('Path B exception:', exc, file=sys.stderr)
        traceback.print_exc()
        path_b_summary = None

    # Notable effects across sweeps
    def safe_delta(arr):
        return (arr[0] - arr[-1]) if arr and len(arr) > 1 else 0.0
    effects = {
        "window_ber_improvement": safe_delta(w_ys),
        "rin_ber_degradation": (r_ys[-1] - r_ys[0]) if r_ys and len(r_ys) > 1 else 0.0,
        "crosstalk_ber_degradation": (c_ys[-1] - c_ys[0]) if c_ys and len(c_ys) > 1 else 0.0,
    }

    # Per-tile BER heatmap (default run): if tiling is square, compute BER per tile
    per_tile = None
    per_tile_after = None
    vth_suggest = None
    ber_after = None
    lin_scale = None
    lin_offset = None
    cal_summary = None
    try:
        if getattr(args, 'no_cal', False) or getattr(args, 'fast', False):
            raise RuntimeError('skip per-tile/calibration')
        blocks = base_orch.sys.channels
        blocks = int(blocks**0.5)
        if blocks*blocks == base_orch.sys.channels:
            # Run one frame to get tile mapping, then accumulate per-tile BER
            # Use a small additional run to estimate per-tile BER robustly
            cap_rows = min(args.trials, 200 if not getattr(args, 'fast', False) else 60)
            rows = [base_orch.step() for _ in range(int(cap_rows))]
            # Map channel -> tile index
            # Tiles are filled row-major in optics.simulate(); two rails per tile (plus/minus)
            # Here we approximate channel???tile as index // 1 (one channel per tile in current mapping)
            import numpy as _np
            tile_err = _np.zeros((blocks, blocks), dtype=float)
            tile_cnt = _np.zeros((blocks, blocks), dtype=float)
            dv_pos = []
            dv_neg = []
            for r in rows:
                t_out = r.get("t_out", [])
                truth = r.get("truth", [])
                dv = _np.array(r.get("dv_mV", [0]*len(t_out)), dtype=float)
                for ch, (o, z) in enumerate(zip(t_out, truth)):
                    by = ch // blocks
                    bx = ch % blocks
                    tile_err[by, bx] += 1.0 if int(o) != int(z) else 0.0
                    tile_cnt[by, bx] += 1.0
                    if z > 0:
                        dv_pos.append(dv[ch])
                    elif z < 0:
                        dv_neg.append(dv[ch])
            with _np.errstate(divide='ignore', invalid='ignore'):
                per_tile = (tile_err / _np.clip(tile_cnt, 1.0, None)).tolist()
            # Suggest per-channel vth: midpoint between class means (global suggestion for now)
            if dv_pos and dv_neg:
                vth_suggest = float(0.5*(float(_np.mean(dv_pos)) + float(_np.mean(dv_neg))))
            if not getattr(args, 'light_output', False):
                try:
                    from looking_glass.plotting import save_heatmap as _save_hm
                    _save_hm(per_tile, xlabel="tile-x", ylabel="tile-y", out_path="out/ber_per_tile.png", title="Per-tile BER")
                except Exception:
                    pass
            # Calibration pass: collect per-channel dv stats, compute vth per channel, apply and re-run
            # Build a fresh orchestrator to apply trims
            cal_emit = EmitterParams(**emit.__dict__)
            cal_optx = OpticsParams(**optx.__dict__)
            cal_pd = PDParams(**pd.__dict__)
            cal_tia = TIAParams(**tia.__dict__)
            cal_comp = ComparatorParams(**comp.__dict__)
            # Legacy calibration overrides
            if getattr(args, 'legacy_baseline_cal', False):
                try:
                    cal_comp.hysteresis_mV = 1.0
                    cal_comp.vth_sigma_mV = 0.0
                except Exception:
                    pass
            cal_clk = ClockParams(**clk.__dict__)
            # Build calibration orchestrator; optionally disable normalization only for calibration
            cal_sys = SystemParams(**sys_p.__dict__)
            if getattr(args, 'legacy_baseline_cal', False) or getattr(args, 'legacy_cal_no_normalize', False):
                try:
                    cal_sys.normalize_dv = False
                except Exception:
                    pass
            orch_cal = Orchestrator(cal_sys, cal_emit, cal_optx, cal_pd, cal_tia, cal_comp, cal_clk)
            # Gather dv per channel given known ternary patterns
            pos_sum = _np.zeros(sys_p.channels, dtype=float)
            pos_cnt = _np.zeros(sys_p.channels, dtype=float)
            neg_sum = _np.zeros(sys_p.channels, dtype=float)
            neg_cnt = _np.zeros(sys_p.channels, dtype=float)
            total_cal = int(min(args.trials*2, 400 if not getattr(args, 'fast', False) else 120))
            if int(getattr(args, 'calib_samples', 0)) > 0:
                total_cal = int(getattr(args, 'calib_samples'))
            for idx in range(total_cal):
                tern = orch_cal.rng.integers(-1, 2, size=sys_p.channels)
                r = orch_cal.step(force_ternary=tern)
                dv = _np.array(r.get("dv_mV", [0]*sys_p.channels), dtype=float)
                pos = tern > 0
                neg = tern < 0
                pos_sum[pos] += dv[pos]
                pos_cnt[pos] += 1.0
                neg_sum[neg] += dv[neg]
                neg_cnt[neg] += 1.0
                if args.progress and (idx+1) % 50 == 0:
                    print(f"PROGRESS: calibration gather {idx+1}/{total_cal}")
            pos_mean = _np.divide(pos_sum, _np.clip(pos_cnt, 1.0, None))
            neg_mean = _np.divide(neg_sum, _np.clip(neg_cnt, 1.0, None))
            vth_vec = 0.5*(pos_mean + neg_mean)
            # Linear per-channel calibration: scale/offset dv so classes map to ??1
            eps = 1e-6
            lin_scale = 2.0/_np.clip((pos_mean - neg_mean), eps, None)
            lin_offset = -0.5*(pos_mean + neg_mean)
            # Optional smoothing (skip if legacy baseline cal)
            try:
                if getattr(args, 'smooth_calibration', False) and not getattr(args, 'legacy_baseline_cal', False):
                    def _smooth(vec):
                        L = _np.roll(vec, 1); R = _np.roll(vec, -1)
                        return 0.25*L + 0.5*vec + 0.25*R
                    vth_vec = _smooth(vth_vec)
                    lin_scale = _smooth(lin_scale)
                    lin_offset = _smooth(lin_offset)
            except Exception:
                pass
            # Apply per-channel trims
            orch_cal.comp.set_vth_per_channel(vth_vec)
            # Evaluate post-calibration BER and per-tile BER
            rows_after = []
            total_eval = int(min(args.trials, 200 if not getattr(args, 'fast', False) else 60))
            for j in range(total_eval):
                rows_after.append(orch_cal.step())
                if args.progress and (j+1) % 50 == 0:
                    print(f"PROGRESS: calibration evaluate {j+1}/{total_eval}")
            tile_err2 = _np.zeros((blocks, blocks), dtype=float)
            tile_cnt2 = _np.zeros((blocks, blocks), dtype=float)
            for r in rows_after:
                t_out = r.get("t_out", [])
                truth = r.get("truth", [])
                for ch, (o, z) in enumerate(zip(t_out, truth)):
                    by = ch // blocks
                    bx = ch % blocks
                    tile_err2[by, bx] += 1.0 if int(o) != int(z) else 0.0
                    tile_cnt2[by, bx] += 1.0
            with _np.errstate(divide='ignore', invalid='ignore'):
                per_tile_after = (tile_err2 / _np.clip(tile_cnt2, 1.0, None)).tolist()
            # Full-run BER after applying trims
            # Always compute canonical baseline via comparator pipeline
            cal_summary = orch_cal.run(trials=args.trials)
            # Optionally compute alternate estimators without overriding canonical baseline
            if getattr(args, 'legacy_cal_estimator_soft', False):
                errs_soft = []
                for _ in range(min(args.trials, 400)):
                    tern = orch_cal.rng.integers(-1, 2, size=orch_cal.sys.channels)
                    r = orch_cal.step(force_ternary=tern)
                    dv = _np.array(r.get("dv_mV", [0]*orch_cal.sys.channels), dtype=float)
                    pred = _np.where((dv - vth_vec) >= 0.0, 1, -1)
                    errs_soft.append(float(_np.mean(pred != tern)))
                cal_summary_alt_soft = {"p50_ber": float(_np.median(errs_soft)) if errs_soft else None, "window_ns": float(orch_cal.clk.p.window_ns)}
            else:
                cal_summary_alt_soft = None
            if getattr(args, 'baseline_cal_binary', False):
                errs_bin = []
                for _ in range(min(args.trials, 400)):
                    tern = orch_cal.rng.choice([-1, 1], size=orch_cal.sys.channels)
                    r = orch_cal.step(force_ternary=tern)
                    tout = _np.array(r.get("t_out", [0]*orch_cal.sys.channels), dtype=int)
                    errs_bin.append(float(_np.mean(tout != tern)))
                cal_summary_alt_bin = {"p50_ber": float(_np.median(errs_bin)) if errs_bin else None, "window_ns": float(orch_cal.clk.p.window_ns)}
            else:
                cal_summary_alt_bin = None
            ber_after = float(cal_summary.get("p50_ber", None))
            if not getattr(args, 'light_output', False):
                try:
                    from looking_glass.plotting import save_heatmap as _save_hm
                    _save_hm(per_tile_after, xlabel="tile-x", ylabel="tile-y", out_path="out/ber_per_tile_after.png", title="Per-tile BER (after calib)")
                except Exception:
                    pass
    except Exception:
        per_tile = None

    # Per-component BER attribution (toggle one component to an idealized variant)
    components = None
    # Initialize optional calibration outputs in case calibration block fails
    cal_summary_alt_soft = None
    cal_summary_alt_bin = None
    per_tile_after = None
    try:
        import numpy as _np
        fixed_inputs = _build_fixed_inputs(args.seed, sys_p.channels, min(args.trials, 200))
        # Determine baseline orchestrator for attribution based on mode
        comp_mode = (getattr(args, 'components_mode', 'auto') or 'auto').lower()
        base_for_components = base_orch
        base_labeled = "path_a"
        if comp_mode == 'cold' and not getattr(args, 'no_cold_input', False):
            try:
                cold_emit = ColdReader(ColdParams(channels=sys_p.channels))
                base_for_components = Orchestrator(sys_p, EmitterParams(channels=sys_p.channels), base_optx, base_pd, base_tia, base_comp, base_clk, emitter_override=cold_emit)
                base_labeled = "cold"
            except Exception:
                base_for_components = base_orch
                base_labeled = "path_a"
        elif comp_mode in ('path_b_analog', 'path_b') and (not getattr(args, 'no_path_b', False)):
            # Build a Path B baseline orchestrator (with SA+amp on) for attribution
            b_emit = EmitterParams(**emit.__dict__)
            b_optx = OpticsParams(**optx.__dict__)
            b_optx.sat_abs_on = True
            b_optx.amp_on = True
            base_for_components = Orchestrator(sys_p, b_emit, b_optx, base_pd, base_tia, base_comp, base_clk)
            base_labeled = "path_b"
        baseline_med = _med_ber_fixed_inputs(base_for_components, fixed_inputs)

        def clone_orch(e=None, o=None, p=None, t=None, c=None, k=None):
            # Respect the attribution baseline's current packs (so mode follows path specifics)
            be = getattr(base_for_components, 'emit').p if hasattr(base_for_components, 'emit') else base_emit
            bo = getattr(base_for_components, 'optx').p if hasattr(base_for_components, 'optx') else base_optx
            bp = getattr(base_for_components, 'pd').p if hasattr(base_for_components, 'pd') else base_pd
            bt = getattr(base_for_components, 'tia').p if hasattr(base_for_components, 'tia') else base_tia
            bc = getattr(base_for_components, 'comp').p if hasattr(base_for_components, 'comp') else base_comp
            bk = getattr(base_for_components, 'clk').p if hasattr(base_for_components, 'clk') else base_clk
            return Orchestrator(
                sys_p,
                e if e is not None else be,
                o if o is not None else bo,
                p if p is not None else bp,
                t if t is not None else bt,
                c if c is not None else bc,
                k if k is not None else bk,
            )

        # Idealized params per component (keep scales, remove dominant noise terms)
        ideal_emit = replace(base_emit, rin_dbhz=-200.0, extinction_db=max(30.0, getattr(base_emit, 'extinction_db', 20.0)), power_sigma_pct=0.0)
        ideal_optx = replace(base_optx,
                             crosstalk_db=-60.0,
                             ct_model="global",
                             stray_floor_db=-80.0,
                             w_plus_contrast=0.95,
                             w_minus_contrast=0.95)
        ideal_pd = replace(base_pd, dark_current_nA=0.0)
        ideal_tia = replace(base_tia,
                            in_noise_pA_rthz=0.0,
                            bw_mhz=max(1000.0, float(getattr(base_tia, 'bw_mhz', 80.0))),
                            adc_read_noise_mV_rms=0.0,
                            slew_v_per_us=1e9,
                            gain_sigma_pct=0.0)
        ideal_comp = replace(base_comp, input_noise_mV_rms=0.0, hysteresis_mV=0.0, vth_sigma_mV=0.0)

        # Evaluate BER with each component idealized (others baseline)
        ber_emit = _med_ber_fixed_inputs(clone_orch(e=ideal_emit), fixed_inputs)
        ber_optx = _med_ber_fixed_inputs(clone_orch(o=ideal_optx), fixed_inputs)
        ber_pd = _med_ber_fixed_inputs(clone_orch(p=ideal_pd), fixed_inputs)
        ber_tia = _med_ber_fixed_inputs(clone_orch(t=ideal_tia), fixed_inputs)
        ber_comp = _med_ber_fixed_inputs(clone_orch(c=ideal_comp), fixed_inputs)
        components = {
            "baseline_p50_ber": baseline_med,
            "emitter_ideal_p50_ber": ber_emit,
            "optics_ideal_p50_ber": ber_optx,
            "pd_ideal_p50_ber": ber_pd,
            "tia_ideal_p50_ber": ber_tia,
            "comparator_ideal_p50_ber": ber_comp,
            "mode": base_labeled,
            "delta": {
                "emitter": None if (baseline_med is None or ber_emit is None) else float(max(0.0, baseline_med - ber_emit)),
                "optics": None if (baseline_med is None or ber_optx is None) else float(max(0.0, baseline_med - ber_optx)),
                "pd": None if (baseline_med is None or ber_pd is None) else float(max(0.0, baseline_med - ber_pd)),
                "tia": None if (baseline_med is None or ber_tia is None) else float(max(0.0, baseline_med - ber_tia)),
                "comparator": None if (baseline_med is None or ber_comp is None) else float(max(0.0, baseline_med - ber_comp)),
            }
        }
    except Exception:
        components = None

    # Realism heuristic scoring (0.0???1.0)
    def realism_scores():
        scores = {}
        # Emitter: extinction, RIN in plausible range
        rin = float(emit.rin_dbhz if hasattr(emit, 'rin_dbhz') else -150.0)
        ext = float(emit.extinction_db if hasattr(emit, 'extinction_db') else 20.0)
        s_rin = min(1.0, max(0.0, (rin + 180.0) / 30.0))  # -180..-150 ??? 0..1, flatter above
        s_ext = min(1.0, max(0.0, (ext - 10.0) / 20.0))   # 10..30 dB ??? 0..1
        scores["emitter"] = {"score": round(0.6*s_rin + 0.4*s_ext, 3), "rin_dbhz": rin, "extinction_db": ext}
        # Optics: crosstalk and stray floor
        ct = float(optx.crosstalk_db if hasattr(optx, 'crosstalk_db') else -28.0)
        stray = float(optx.stray_floor_db if hasattr(optx, 'stray_floor_db') else -38.0)
        s_ct = min(1.0, max(0.0, (-ct - 18.0) / 20.0))    # -38..-18 ??? 1..0
        s_stray = min(1.0, max(0.0, (-stray - 28.0) / 20.0))
        scores["optics"] = {"score": round(0.7*s_ct + 0.3*s_stray, 3), "crosstalk_db": ct, "stray_floor_db": stray}
        # Camera: read noise and full well
        # Not always present here; approximate typical values
        scores["camera"] = {"score": 0.7, "read_noise_e_rms": 2.0, "full_well_e": 20000.0}
        # TIA: bandwidth and input noise
        bw = float(tia_bw)
        in_n = float(getattr(tia, 'in_noise_pA_rthz', 5.0))
        s_bw = min(1.0, max(0.0, (bw - 20.0) / 100.0))
        s_in = min(1.0, max(0.0, (8.0 - in_n) / 8.0))
        scores["tia"] = {"score": round(0.5*s_bw + 0.5*s_in, 3), "bw_mhz": bw, "in_noise_pA_rthz": in_n}
        # Comparator: noise and drift
        comp_n = float(comp.input_noise_mV_rms)
        s_cn = min(1.0, max(0.0, (1.2 - comp_n) / 1.2))
        scores["comparator"] = {"score": round(s_cn, 3), "input_noise_mV_rms": comp_n}
        return scores

    # Optional temporal voting estimate (repeat > 1)
    vote3_ber = None
    rep = max(3 if args.vote3 else 1, int(args.repeat))
    if rep > 1:
        import numpy as _np
        errs = []
        for _ in range(min(args.trials, 200)):
            # Use a fixed ternary vector per trial to enable meaningful voting
            tern = base_orch.rng.integers(-1, 2, size=base_orch.sys.channels)
            outs = []
            for _j in range(rep):
                outs.append(base_orch.step(force_ternary=tern)["t_out"])
            t = _np.array(tern)
            O = _np.vstack(outs)
            vote = _np.sign(_np.sum(O, axis=0))
            errs.append(float(_np.mean(vote != t)))
        vote3_ber = float(_np.median(errs)) if errs else None

    # Pseudo spatial oversampling (S>1): majority vote across S repeats per input
    spatial_ber = None
    S = max(1, int(args.spatial_oversample))
    if S > 1:
        import numpy as _np
        errs = []
        for _ in range(min(args.trials, 200)):
            tern = base_orch.rng.integers(-1, 2, size=base_orch.sys.channels)
            outs = []
            for _j in range(S):
                outs.append(base_orch.step(force_ternary=tern)["t_out"])
            t = _np.array(tern)
            O = _np.vstack(outs)
            vote = _np.sign(_np.sum(O, axis=0))
            errs.append(float(_np.mean(vote != t)))
        spatial_ber = float(_np.median(errs)) if errs else None

    # Build bad-channel mask BEFORE classifier evaluation so it is applied
    active_mask = None
    masked_count = 0
    try:
        Nmask = int(max(int(getattr(args, 'mask_bad_channels', 0)), float(getattr(args, 'mask_bad_frac', 0.0)) * float(sys_p.channels)))
        if Nmask > 0:
            import numpy as _np
            trials_mask = int(max(50, min(getattr(args, 'calib_mask_trials', 200), 500)))
            ch = sys_p.channels
            err_counts = None
            pos_sum = _np.zeros(ch, dtype=float)
            pos_cnt = _np.zeros(ch, dtype=float)
            neg_sum = _np.zeros(ch, dtype=float)
            neg_cnt = _np.zeros(ch, dtype=float)
            for _ in range(trials_mask):
                tern = orch.rng.integers(-1, 2, size=ch)
                r = orch.step(force_ternary=tern)
                # Prefer comparator outputs for mask (matches classifier); fallback to dv sign
                tout = _np.array(r.get("t_out", []), dtype=int)
                if tout.size == 0:
                    dv = _np.array(r.get("dv_mV", []), dtype=float)
                    tout = _np.sign(dv).astype(int)
                if err_counts is None:
                    err_counts = _np.zeros_like(tout, dtype=float)
                if tout.shape[0] != ch:
                    tern = tern[:tout.shape[0]]
                err_counts += (tout != tern)
                dv_cur = _np.array(r.get("dv_mV", [0]*tout.shape[0]), dtype=float)
                pos = tern > 0; neg = tern < 0
                pos_sum[:dv_cur.shape[0]][pos[:dv_cur.shape[0]]] += dv_cur[pos[:dv_cur.shape[0]]]
                pos_cnt[:dv_cur.shape[0]][pos[:dv_cur.shape[0]]] += 1.0
                neg_sum[:dv_cur.shape[0]][neg[:dv_cur.shape[0]]] += dv_cur[neg[:dv_cur.shape[0]]]
                neg_cnt[:dv_cur.shape[0]][neg[:dv_cur.shape[0]]] += 1.0
            mode = (getattr(args, 'mask_mode', 'error') or 'error')
            if mode == 'dvspan':
                with _np.errstate(divide='ignore', invalid='ignore'):
                    pos_mean = _np.divide(pos_sum, _np.clip(pos_cnt, 1.0, None))
                    neg_mean = _np.divide(neg_sum, _np.clip(neg_cnt, 1.0, None))
                    span = _np.abs(pos_mean - neg_mean)
                idx = _np.argsort(span)[:min(Nmask, span.shape[0])]
            else:
                rates = err_counts / float(max(1, trials_mask))
                idx = _np.argsort(rates)[::-1][:min(Nmask, rates.shape[0])]
            active_mask = _np.ones_like(rates, dtype=bool)
            active_mask[idx] = False
            try:
                masked_count = int((_np.asarray(active_mask) == False).sum())
            except Exception:
                masked_count = int(Nmask)
    except Exception:
        active_mask = None

    def _mask_and_trim(pred_vec, truth_vec):
        import numpy as _np
        M = min(len(pred_vec), len(truth_vec))
        pred = _np.asarray(pred_vec[:M], dtype=int)
        truth = _np.asarray(truth_vec[:M], dtype=int)
        if active_mask is not None:
            mask = _np.asarray(active_mask[:M], dtype=bool)
            pred = pred[mask]
            truth = truth[mask]
        return pred, truth

    def _masked_error(pred_vec, truth_vec):
        import numpy as _np
        pred, truth = _mask_and_trim(pred_vec, truth_vec)
        if truth.size == 0:
            return 0.0
        return float(_np.mean(pred != truth))

    # Lock-in estimate: subtract a dark dv per trial and threshold on sign
    lockin_ber = None
    if args.lockin or (getattr(args, 'classifier', None) == 'lockin'):
        import numpy as _np
        errs = []
        for _ in range(min(args.trials, 200)):
            tern = base_orch.rng.integers(-1, 2, size=base_orch.sys.channels)
            r_sig = base_orch.step(force_ternary=tern)
            r_dark = base_orch.step(force_ternary=_np.zeros_like(tern))
            dv_sig = _np.array(r_sig.get("dv_mV", [0]*base_orch.sys.channels))
            dv_dark = _np.array(r_dark.get("dv_mV", [0]*base_orch.sys.channels))
            dv_diff = dv_sig - dv_dark
            if bool(getattr(args, 'force_cal_in_primary', False)) and (lin_scale is not None) and (lin_offset is not None):
                dv_lin = lin_scale*(dv_diff + lin_offset)
                if vth_vec_pa is not None:
                    pred = _np.sign(dv_lin - vth_vec_pa)
                else:
                    pred = _np.sign(dv_lin)
            else:
                # Optional confidence gating even without calibration
                g_th = float(getattr(args, 'gate_thresh_mV', 0.0)); g_ex = int(getattr(args, 'gate_extra_frames', 0))
                if g_ex > 0 and g_th > 0.0:
                    import numpy as _np
                    ref = (vth_vec_pa if vth_vec_pa is not None else 0.0)
                    low = _np.abs(dv_diff - ref) < g_th
                    if low.any():
                        r_sig2 = base_orch.step(force_ternary=tern)
                        r_dark2 = base_orch.step(force_ternary=_np.zeros_like(tern))
                        dv_sig2 = _np.array(r_sig2.get("dv_mV", [0]*base_orch.sys.channels))
                        dv_dark2 = _np.array(r_dark2.get("dv_mV", [0]*base_orch.sys.channels))
                        dv_diff2 = dv_sig2 - dv_dark2
                        dv_diff[low] = dv_diff[low] + dv_diff2[low]
                pred = _np.sign(dv_diff)
            errs.append(_masked_error(pred, tern))
        lockin_ber = float(_np.median(errs)) if errs else None

    # Chopper stabilization: use +x and -x frames, subtract, then threshold
    chop_ber = None
    if args.chop or (getattr(args, 'classifier', None) == 'chop'):
        import numpy as _np
        errs = []
        for _ in range(min(args.trials, 200)):
            tern = base_orch.rng.integers(-1, 2, size=base_orch.sys.channels)
            r_pos = base_orch.step(force_ternary=tern)
            r_neg = base_orch.step(force_ternary=-tern)
            dv_pos = _np.array(r_pos.get("dv_mV", [0]*base_orch.sys.channels))
            dv_neg = _np.array(r_neg.get("dv_mV", [0]*base_orch.sys.channels))
            dv_diff = dv_pos - dv_neg
            if bool(getattr(args, 'force_cal_in_primary', False)) and (lin_scale is not None) and (lin_offset is not None):
                dv_lin = lin_scale*(dv_diff + lin_offset)
                # confidence gate: one extra frame for small margins
                g_th = float(getattr(args, 'gate_thresh_mV', 0.0)); g_ex = int(getattr(args, 'gate_extra_frames', 0))
                if g_ex > 0 and g_th > 0.0:
                    low = _np.abs(dv_lin - (vth_vec_pa if vth_vec_pa is not None else 0.0)) < g_th
                    if low.any():
                        r_pos2 = base_orch.step(force_ternary=tern)
                        r_neg2 = base_orch.step(force_ternary=-tern)
                        dv_pos2 = _np.array(r_pos2.get("dv_mV", [0]*base_orch.sys.channels)); dv_neg2 = _np.array(r_neg2.get("dv_mV", [0]*base_orch.sys.channels))
                        dv_lin2 = lin_scale*((dv_pos2 - dv_neg2) + lin_offset)
                        dv_lin[low] = dv_lin[low] + dv_lin2[low]
                if vth_vec_pa is not None:
                    pred = _np.sign(dv_lin - vth_vec_pa)
                else:
                    pred = _np.sign(dv_lin)
            else:
                # Optional confidence gating even without calibration
                g_th = float(getattr(args, 'gate_thresh_mV', 0.0)); g_ex = int(getattr(args, 'gate_extra_frames', 0))
                if g_ex > 0 and g_th > 0.0:
                    import numpy as _np
                    ref = (vth_vec_pa if vth_vec_pa is not None else 0.0)
                    low = _np.abs(dv_diff - ref) < g_th
                    if low.any():
                        r_pos2 = base_orch.step(force_ternary=tern)
                        r_neg2 = base_orch.step(force_ternary=-tern)
                        dv_pos2 = _np.array(r_pos2.get("dv_mV", [0]*base_orch.sys.channels)); dv_neg2 = _np.array(r_neg2.get("dv_mV", [0]*base_orch.sys.channels))
                        dv_diff2 = dv_pos2 - dv_neg2
                        dv_diff[low] = dv_diff[low] + dv_diff2[low]
                pred = _np.sign(dv_diff)
            errs.append(_masked_error(pred, tern))
        chop_ber = float(_np.median(errs)) if errs else None

    # Frame averaging on dv: average N frames per input, then threshold
    avg_frames_ber = None
    if (int(args.avg_frames) > 1) or (getattr(args, 'classifier', None) == 'avg'):
        import numpy as _np
        N = int(args.avg_frames)
        errs = []
        for _ in range(min(args.trials, 200)):
            tern = base_orch.rng.integers(-1, 2, size=base_orch.sys.channels)
            acc = _accumulate_dv_over_frames(base_orch, tern, N, str(getattr(args, 'avg_kernel', 'sum')), float(getattr(args, 'avg_ema_alpha', 0.6)))
            # Confidence gating: add extra frames for low-margin channels
            g_th = float(getattr(args, 'gate_thresh_mV', 0.0)); g_ex = int(getattr(args, 'gate_extra_frames', 0))
            if g_ex > 0 and g_th > 0.0:
                low = _np.abs(acc) < g_th
                if low.any():
                    add = _accumulate_dv_over_frames(base_orch, tern, g_ex, str(getattr(args, 'avg_kernel', 'sum')), float(getattr(args, 'avg_ema_alpha', 0.6)))
                    acc[low] = acc[low] + add[low]
            pred = _np.sign(acc)
            errs.append(_masked_error(pred, tern))
        avg_frames_ber = float(_np.median(errs)) if errs else None

    # Software threshold (upper bound Path A): learn per-channel vth, then classify dv
    soft_thresh_ber = None
    if args.soft_thresh:
        import numpy as _np
        # Learn per-channel vth from a short calibration set
        pos_sum = _np.zeros(sys_p.channels, dtype=float)
        pos_cnt = _np.zeros(sys_p.channels, dtype=float)
        neg_sum = _np.zeros(sys_p.channels, dtype=float)
        neg_cnt = _np.zeros(sys_p.channels, dtype=float)
        for _ in range(min(300, max(100, args.trials))):
            tern = base_orch.rng.integers(-1, 2, size=sys_p.channels)
            r = base_orch.step(force_ternary=tern)
            dv = _np.array(r.get("dv_mV", [0]*sys_p.channels), dtype=float)
            pos = tern > 0
            neg = tern < 0
            pos_sum[pos] += dv[pos]; pos_cnt[pos] += 1
            neg_sum[neg] += dv[neg]; neg_cnt[neg] += 1
        pos_mean = _np.divide(pos_sum, _np.clip(pos_cnt, 1.0, None))
        neg_mean = _np.divide(neg_sum, _np.clip(neg_cnt, 1.0, None))
        vth_vec = 0.5*(pos_mean + neg_mean)
        errs = []
        for _ in range(min(args.trials, 200)):
            tern = base_orch.rng.integers(-1, 2, size=sys_p.channels)
            r = base_orch.step(force_ternary=tern)
            dv = _np.array(r.get("dv_mV", [0]*sys_p.channels), dtype=float)
            pred = _np.sign(dv - vth_vec)
            errs.append(_masked_error(pred, tern))
        soft_thresh_ber = float(_np.median(errs)) if errs else None

    # Mitigated pipeline: chopper + frame averaging + linear per-channel calibration, then sign
    mitigated_ber = None
    if args.mitigated and (lin_scale is not None) and (lin_offset is not None):
        import numpy as _np
        errs = []
        N = max(1, int(args.avg_frames))
        for _ in range(min(args.trials, 200)):
            tern = base_orch.rng.integers(-1, 2, size=base_orch.sys.channels)
            acc = _np.zeros(base_orch.sys.channels, dtype=float)
            for _j in range(N):
                if args.chop:
                    r_pos = base_orch.step(force_ternary=tern)
                    r_neg = base_orch.step(force_ternary=-tern)
                    dv = _np.array(r_pos.get("dv_mV", [0]*base_orch.sys.channels)) - _np.array(r_neg.get("dv_mV", [0]*base_orch.sys.channels))
                else:
                    r = base_orch.step(force_ternary=tern)
                    dv = _np.array(r.get("dv_mV", [0]*base_orch.sys.channels))
                if dv.shape[0] != base_orch.sys.channels:
                    dv = dv[:base_orch.sys.channels]
                acc = acc[:dv.shape[0]]
                acc += dv
            dv_avg = acc/float(N)
            dv_lin = lin_scale*(dv_avg + lin_offset)
            pred = _np.sign(dv_lin)
            errs.append(_masked_error(pred, tern))
        mitigated_ber = float(_np.median(errs)) if errs else None

    # Optional quick per-channel calibration to set vth for path_a/baseline even when --no-cal
    # Initialize masking and calibration vectors
    active_mask = None
    try:
        if getattr(args, 'apply_calibration', False):
            import numpy as _np
            calN = int(min(max(120, args.trials), 240))
            pos_sum = _np.zeros(sys_p.channels, dtype=float)
            pos_cnt = _np.zeros(sys_p.channels, dtype=float)
            neg_sum = _np.zeros(sys_p.channels, dtype=float)
            neg_cnt = _np.zeros(sys_p.channels, dtype=float)
            # Use a fresh clone to avoid contaminating main RNG state
            cal_orch = Orchestrator(sys_p, EmitterParams(**emit.__dict__), OpticsParams(**optx.__dict__), PDParams(**pd.__dict__), TIAParams(**tia.__dict__), ComparatorParams(**comp.__dict__), ClockParams(**clk.__dict__))
            for _ in range(calN):
                tern = cal_orch.rng.integers(-1, 2, size=sys_p.channels)
                r = cal_orch.step(force_ternary=tern)
                dv = _np.array(r.get("dv_mV", [0]*sys_p.channels), dtype=float)
                pos = tern > 0
                neg = tern < 0
                pos_sum[pos] += dv[pos]; pos_cnt[pos] += 1
                neg_sum[neg] += dv[neg]; neg_cnt[neg] += 1
            pos_mean = _np.divide(pos_sum, _np.clip(pos_cnt, 1.0, None))
            neg_mean = _np.divide(neg_sum, _np.clip(neg_cnt, 1.0, None))
            vth_vec_pa = 0.5*(pos_mean + neg_mean)
            # Learn deblur taps per channel if requested (skip if legacy baseline cal)
            try:
                if getattr(args, 'learn_deblur', False) and not getattr(args, 'legacy_baseline_cal', False):
                    import numpy as _np
                    M = sys_p.channels
                    S = int(max(120, getattr(args, 'deblur_samples', 240)))
                    lam = float(getattr(args, 'deblur_l2', 0.1))
                    # Gather dv snapshots
                    D = _np.zeros((S, M), dtype=float)
                    for si in range(S):
                        rr = orch_cal.step()
                        D[si, :] = _np.array(rr.get("dv_mV", [0]*M), dtype=float)
                    # Build regression X (left,right), y=dv per channel solved independently with ridge
                    L = _np.roll(D, 1, axis=1); R = _np.roll(D, -1, axis=1)
                    # Solve (X^T X + lam I) w = X^T y where X=[L,R]
                    # Approximate shared taps across channels (global) for stability
                    X = _np.concatenate([L.reshape(-1,1), R.reshape(-1,1)], axis=1)
                    y = D.reshape(-1)
                    XT = X.T
                    A = XT @ X + lam*_np.eye(2)
                    b = XT @ y
                    w = _np.linalg.solve(A, b)
                    deblur_params["aL"], deblur_params["aR"] = float(w[0]), float(w[1])
            except Exception:
                pass
            # Apply to comparator for main orchestrator
            try:
                orch.comp.set_vth_per_channel(vth_vec_pa)
            except Exception:
                pass
            # Optionally export the learned per-channel vth (mV)
            try:
                exp_path = getattr(args, 'export_vth', None)
                if isinstance(exp_path, str) and exp_path:
                    import json as _json, os as _os
                    _os.makedirs(_os.path.dirname(exp_path), exist_ok=True)
                    with open(exp_path, "w", encoding="utf-8") as _f:
                        _json.dump([float(x) for x in vth_vec_pa.tolist()], _f)
            except Exception:
                pass
    except Exception:
        vth_vec_pa = None

    # Optional per-channel vth optimizer (small fixed set, greedy updates)
    try:
        if getattr(args, 'optimize_vth', False):
            import numpy as _np
            K = int(max(1, getattr(args, 'opt_vth_iters', 6)))
            step = float(getattr(args, 'opt_vth_step_mV', 0.2))
            margin = float(getattr(args, 'opt_vth_margin_mV', 0.0))
            use_mask = bool(getattr(args, 'opt_vth_use_mask', False))
            # Initialize from current suggestion if available
            if vth_vec_pa is None:
                # derive quick vth vector from a short calibration set
                pos_sum = _np.zeros(orch.sys.channels, dtype=float)
                pos_cnt = _np.zeros(orch.sys.channels, dtype=float)
                neg_sum = _np.zeros(orch.sys.channels, dtype=float)
                neg_cnt = _np.zeros(orch.sys.channels, dtype=float)
                for _ in range(min(args.trials, 120)):
                    tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
                    r = orch.step(force_ternary=tern)
                    dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels), dtype=float)
                    pos = tern > 0; neg = tern < 0
                    pos_sum[pos] += dv[pos]; pos_cnt[pos] += 1
                    neg_sum[neg] += dv[neg]; neg_cnt[neg] += 1
                pos_mean = _np.divide(pos_sum, _np.clip(pos_cnt, 1.0, None))
                neg_mean = _np.divide(neg_sum, _np.clip(neg_cnt, 1.0, None))
                vth_vec_pa = 0.5*(pos_mean + neg_mean)
            vth = _np.array(vth_vec_pa, dtype=float)
            for _iter in range(K):
                # Evaluate errors and push vth opposite the error direction per channel
                grad = _np.zeros_like(vth)
                cnt = _np.zeros_like(vth)
                for _ in range(min(args.trials, 160)):
                    tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
                    r = orch.step(force_ternary=tern)
                    dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels), dtype=float)
                    # Marginized errors: treat near-threshold as errors to encourage separation
                    err_pos = (tern > 0) & ((dv - vth) < margin)
                    err_neg = (tern < 0) & ((dv - vth) > -margin)
                    grad[err_pos] -= 1.0
                    grad[err_neg] += 1.0
                    cnt += 1.0
                cnt = _np.clip(cnt, 1.0, None)
                upd = (step * grad / cnt)
                if use_mask and (active_mask is not None):
                    M = min(len(active_mask), upd.shape[0])
                    maskv = _np.array(active_mask[:M], dtype=bool)
                    upd[:M] = _np.where(maskv, upd[:M], 0.0)
                vth = vth + upd
            # Apply tuned vector
            orch.comp.set_vth_per_channel(vth)
            try:
                base_orch.comp.set_vth_per_channel(vth)
            except Exception:
                pass
            vth_vec_pa = vth
    except Exception:
        pass

    # Optional per-channel linear offset optimizer for dv (uses lin_scale baseline, tunes lin_offset per channel)
    try:
        if getattr(args, 'optimize_linear', False) and (lin_scale is not None):
            import numpy as _np
            K = int(max(1, getattr(args, 'opt_lin_iters', 6)))
            step = float(getattr(args, 'opt_lin_step_mV', 0.1))
            use_mask = bool(getattr(args, 'opt_lin_use_mask', False))
            # Initialize lin_offset if missing
            if lin_offset is None:
                lin_offset = _np.zeros(orch.sys.channels, dtype=float)
            lo = _np.array(lin_offset, dtype=float)
            for _iter in range(K):
                grad = _np.zeros_like(lo)
                cnt = _np.zeros_like(lo)
                for _ in range(min(args.trials, 160)):
                    tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
                    r = orch.step(force_ternary=tern)
                    dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels), dtype=float)
                    dv_lin = lin_scale*(dv + lo)
                    pred = _np.sign(dv_lin)
                    err = (pred != tern)
                    grad += _np.where(err, -_np.sign(dv_lin), 0.0)
                    cnt += 1.0
                cnt = _np.clip(cnt, 1.0, None)
                upd = (step * grad / cnt)
                if use_mask and (active_mask is not None):
                    M = min(len(active_mask), upd.shape[0])
                    maskv = _np.array(active_mask[:M], dtype=bool)
                    upd[:M] = _np.where(maskv, upd[:M], 0.0)
                lo = lo + upd
            # Apply tuned linear offset (keep scale)
            lin_offset = lo
    except Exception:
        pass

    # Optional simple linear decoder (per-channel) trained on dv features
    decoder = None
    try:
        if getattr(args, 'decoder_linear', False):
            import numpy as _np
            S = int(max(100, getattr(args, 'decoder_samples', 320)))
            lam = float(getattr(args, 'decoder_l2', 0.1))
            Xs = []; Ys = []
            for _ in range(S):
                tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
                r = orch.step(force_ternary=tern)
                dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels), dtype=float)
                # Features: [dv, left, right, |dv|, dv^2]
                l = _np.roll(dv, 1); rr = _np.roll(dv, -1)
                feats = _np.stack([dv, l, rr, _np.abs(dv), dv*dv], axis=1)
                Xs.append(feats)
                Ys.append(tern)
            X = _np.vstack(Xs)
            y = _np.concatenate(Ys)
            # Ridge regression for each channel independently (shared weights approximated by pooled solution)
            # Solve (X^T X + lam I)w = X^T y
            XT = X.T
            A = XT @ X + lam*_np.eye(X.shape[1])
            b = XT @ y
            w = _np.linalg.solve(A, b)
            decoder = {"w": w}
        if getattr(args, 'decoder_mlp', False):
            import numpy as _np
            S = int(max(200, getattr(args, 'decoder_samples', 400)))
            H = int(max(4, getattr(args, 'decoder_mlp_hidden', 8)))
            epochs = int(max(5, getattr(args, 'decoder_mlp_epochs', 10)))
            lr = float(max(1e-4, getattr(args, 'decoder_mlp_lr', 0.01)))
            # Build training set
            Xs = []; Ys = []
            for _ in range(S):
                tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
                r = orch.step(force_ternary=tern)
                dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels), dtype=float)
                l = _np.roll(dv, 1); rr = _np.roll(dv, -1)
                feats = _np.stack([dv, l, rr, _np.abs(dv), dv*dv], axis=1)
                Xs.append(feats)
                Ys.append(tern)
            X = _np.vstack(Xs)  # [S*ch, F]
            y = _np.where(_np.concatenate(Ys) > 0, 1.0, 0.0)  # map {-1,+1}???{0,1}
            F = X.shape[1]
            rng = _np.random.default_rng(int(args.seed))
            W1 = rng.normal(0, 0.1, size=(F, H)); b1 = _np.zeros(H)
            W2 = rng.normal(0, 0.1, size=(H, 1)); b2 = _np.zeros(1)
            def sigmoid(z): return 1.0/(1.0+_np.exp(-z))
            for _ in range(epochs):
                # Forward
                Z1 = X @ W1 + b1
                A1 = _np.tanh(Z1)
                Z2 = A1 @ W2 + b2
                P = sigmoid(Z2).reshape(-1)
                # Gradients (log-loss)
                dZ2 = (P - y).reshape(-1,1)
                dW2 = A1.T @ dZ2 / X.shape[0]
                db2 = dZ2.mean(axis=0)
                dA1 = dZ2 @ W2.T
                dZ1 = dA1 * (1.0 - A1*A1)
                dW1 = X.T @ dZ1 / X.shape[0]
                db1 = dZ1.mean(axis=0)
                # Update
                W1 -= lr * dW1; b1 -= lr * db1
                W2 -= lr * dW2; b2 -= lr * db2
            decoder = {"mlp": True, "W1": W1, "b1": b1, "W2": W2, "b2": b2}
    except Exception:
        decoder = None

    # Path A summary with configured packs (reflects vendor overrides)
    # If classifier is explicitly chosen, honor it; otherwise precedence: soft > avg > adaptive > default
    cls_choice = getattr(args, 'classifier', None)
    if cls_choice in ('vote3','vote5','repeat'):
        import numpy as _np
        errs = []
        if cls_choice == 'vote3':
            repN = 3
        elif cls_choice == 'vote5':
            repN = 5
        else:
            repN = max(1, int(getattr(args, 'repeat', 1)))
        for _ in range(min(args.trials, 200)):
            tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
            votes = None
            for j in range(repN):
                # Optional permutation diversity across repeats
                if getattr(args, 'permute_repeats', False):
                    if args.permute_scheme == 'cyclic':
                        perm = _np.roll(_np.arange(orch.sys.channels), j)
                    else:
                        perm = _np.array(orch.rng.permutation(orch.sys.channels))
                    inv = _np.argsort(perm)
                    # Apply permutation to input channels
                    tern_perm = tern[perm]
                    r = orch.step(force_ternary=tern_perm)
                    tout = _np.array(r.get("t_out", [0]*orch.sys.channels), dtype=int)
                    # De-permute t_out back to logical order
                    tout = tout[inv]
                else:
                    r = orch.step(force_ternary=tern)
                    tout = _np.array(r.get("t_out", [0]*orch.sys.channels), dtype=int)
                # Apply bad-channel mask if present
                if active_mask is not None:
                    M = min(len(active_mask), tout.shape[0])
                    tout = tout[:M]; tsel = tern[:M]; am = active_mask[:M]
                    tout = tout[am]; tcur = tsel[am]
                else:
                    tcur = tern
                # Initialize votes matrix on first repeat with effective length
                if votes is None:
                    votes = _np.zeros((repN, len(tcur)), dtype=int)
                votes[j, :len(tout)] = _np.sign(tout)
            # Tie-break zeros toward +1 to avoid 0 labels
            vote_sum = _np.sum(votes, axis=0)
            pred = _np.where(vote_sum >= 0, 1, -1)
            errs.append(float(_np.mean(pred != tcur)))
        path_a_summary = {
            "p50_ber": float(_np.median(errs)) if errs else None,
            "p50_energy_pj": None,
            "window_ns": float(orch.clk.p.window_ns),
        }
    elif cls_choice == 'replicate2':
        import numpy as _np
        errs = []
        ch = orch.sys.channels
        # Two complementary permutations: identity and half-rotate (for even channels)
        base_perm = _np.arange(ch)
        if ch % 2 == 0:
            alt_perm = _np.roll(base_perm, ch//2)
        else:
            alt_perm = _np.array(orch.rng.permutation(ch))
        inv_base = _np.argsort(base_perm)
        inv_alt = _np.argsort(alt_perm)
        for _ in range(min(args.trials, 200)):
            tern = orch.rng.integers(-1, 2, size=ch)
            # Pass 1: identity
            r1 = orch.step(force_ternary=tern[base_perm])
            dv1 = _np.array(r1.get("dv_mV", [0]*ch))[inv_base]
            # Pass 2: alternate permutation
            r2 = orch.step(force_ternary=tern[alt_perm])
            dv2 = _np.array(r2.get("dv_mV", [0]*ch))[inv_alt]
            dv_sum = dv1 + dv2
            tcur = tern
            if active_mask is not None:
                M = min(len(active_mask), dv_sum.shape[0])
                dv_sum = dv_sum[:M]; tcur = tcur[:M]; am = active_mask[:M]
                dv_sum = dv_sum[am]; tcur = tcur[am]
            if vth_vec_pa is not None:
                vv = vth_vec_pa
                if active_mask is not None:
                    vv = vv[:M][am]
                pred = _np.sign(dv_sum - 2.0*vv)
            else:
                pred = _np.sign(dv_sum)
            errs.append(float(_np.mean(pred != tcur)))
        path_a_summary = {
            "p50_ber": float(_np.median(errs)) if errs else None,
            "p50_energy_pj": None,
            "window_ns": float(orch.clk.p.window_ns),
        }
    elif cls_choice == 'replicate':
        import numpy as _np
        errs = []
        ch = orch.sys.channels
        repN = max(2, int(getattr(args, 'repeat', 2)))
        for _ in range(min(args.trials, 200)):
            tern = orch.rng.integers(-1, 2, size=ch)
            dv_acc = _np.zeros(ch, dtype=float)
            for j in range(repN):
                if getattr(args, 'permute_repeats', False):
                    if args.permute_scheme == 'cyclic':
                        perm = _np.roll(_np.arange(ch), j)
                    else:
                        perm = _np.array(orch.rng.permutation(ch))
                    inv = _np.argsort(perm)
                    r = orch.step(force_ternary=tern[perm])
                    dv = _np.array(r.get("dv_mV", [0]*ch))[inv]
                else:
                    r = orch.step(force_ternary=tern)
                    dv = _np.array(r.get("dv_mV", [0]*ch))
                dv_acc += dv
            tcur = tern
            if active_mask is not None:
                M = min(len(active_mask), dv_acc.shape[0])
                dv_acc = dv_acc[:M]; tcur = tcur[:M]; am = active_mask[:M]
                dv_acc = dv_acc[am]; tcur = tcur[am]
            if vth_vec_pa is not None:
                vv = vth_vec_pa
                if active_mask is not None:
                    vv = vv[:M][am]
                # Compare against scaled threshold and tie-break zeros to +1
                pred = _np.where((dv_acc - float(repN)*vv) >= 0.0, 1, -1)
            else:
                pred = _np.where(dv_acc >= 0.0, 1, -1)
            errs.append(float(_np.mean(pred != tcur)))
        path_a_summary = {
            "p50_ber": float(_np.median(errs)) if errs else None,
            "p50_energy_pj": None,
            "window_ns": float(orch.clk.p.window_ns),
        }
    elif cls_choice == 'phys2x':
        # Simulate 2x physical redundancy: each logical channel is read from two physical tiles simultaneously
        # Implementation: run once on tern, then again on a half-rotated channel assignment and sum dv
        import numpy as _np
        errs = []
        ch = orch.sys.channels
        base_perm = _np.arange(ch)
        if ch % 2 == 0:
            alt_perm = _np.roll(base_perm, ch//2)
        else:
            alt_perm = _np.array(orch.rng.permutation(ch))
        inv_base = _np.argsort(base_perm)
        inv_alt = _np.argsort(alt_perm)
        for _ in range(min(args.trials, 200)):
            tern = orch.rng.integers(-1, 2, size=ch)
            r1 = orch.step(force_ternary=tern[base_perm])
            dv1 = _np.array(r1.get("dv_mV", [0]*ch))[inv_base]
            r2 = orch.step(force_ternary=tern[alt_perm])
            dv2 = _np.array(r2.get("dv_mV", [0]*ch))[inv_alt]
            dv_sum = dv1 + dv2
            if vth_vec_pa is not None:
                pred = _np.sign(dv_sum - 2.0*vth_vec_pa)
            else:
                pred = _np.sign(dv_sum)
            errs.append(_masked_error(pred, tern))
        path_a_summary = {
            "p50_ber": float(_np.median(errs)) if errs else None,
            "p50_energy_pj": None,
            "window_ns": float(orch.clk.p.window_ns),
        }
    elif cls_choice == 'lockin' and (lockin_ber is not None):
        path_a_summary = {"p50_ber": lockin_ber, "p50_energy_pj": None, "window_ns": float(orch.clk.p.window_ns)}
    elif cls_choice == 'chop' and (chop_ber is not None):
        path_a_summary = {"p50_ber": chop_ber, "p50_energy_pj": None, "window_ns": float(orch.clk.p.window_ns)}
    elif cls_choice == 'mitigated' and (mitigated_ber is not None):
        path_a_summary = {"p50_ber": mitigated_ber, "p50_energy_pj": None, "window_ns": float(orch.clk.p.window_ns)}
    elif cls_choice == 'soft' or getattr(args, 'soft_thresh', False):
        import numpy as _np
        errs = []
        for _ in range(min(args.trials, 200)):
            tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
            r = orch.step(force_ternary=tern)
            dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels))
            tcur = tern
            if active_mask is not None:
                M = min(len(active_mask), dv.shape[0])
                dv = dv[:M]; tcur = tcur[:M]; am = active_mask[:M]
                dv = dv[am]; tcur = tcur[am]
            if vth_vec_pa is not None:
                vv = vth_vec_pa
                if active_mask is not None:
                    vv = vv[:M][am]
                pred = _np.where((dv - vv) >= 0.0, 1, -1)
            else:
                pred = _np.where(dv >= 0.0, 1, -1)
            errs.append(float(_np.mean(pred != tcur)))
        path_a_summary = {
            "p50_ber": float(_np.median(errs)) if errs else None,
            "p50_energy_pj": None,
            "window_ns": float(orch.clk.p.window_ns),
        }
    elif cls_choice == 'avg' or (getattr(args, 'use_avg_frames_for_path_a', False) and int(args.avg_frames) > 1):
        import numpy as _np
        N = int(args.avg_frames)
        errs = []
        for _ in range(min(args.trials, 200)):
            tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
            acc = _accumulate_dv_over_frames(orch, tern, N, str(getattr(args, 'avg_kernel', 'sum')), float(getattr(args, 'avg_ema_alpha', 0.6)))
            if bool(getattr(args, 'force_cal_in_primary', False)) and (lin_scale is not None) and (lin_offset is not None):
                dv_lin = lin_scale*(acc + lin_offset)
                # confidence gate
                g_th = float(getattr(args, 'gate_thresh_mV', 0.0)); g_ex = int(getattr(args, 'gate_extra_frames', 0))
                if g_ex > 0 and g_th > 0.0:
                    low = _np.abs(dv_lin - (vth_vec_pa if vth_vec_pa is not None else 0.0)) < g_th
                    if low.any():
                        add = _accumulate_dv_over_frames(orch, tern, g_ex, str(getattr(args, 'avg_kernel', 'sum')), float(getattr(args, 'avg_ema_alpha', 0.6)))
                        dv_lin[low] = dv_lin[low] + (lin_scale[low] * add[low])
                if vth_vec_pa is not None:
                    pred = _np.sign(dv_lin - vth_vec_pa)
                else:
                    pred = _np.sign(dv_lin)
            else:
                if vth_vec_pa is not None:
                    pred = _np.sign(acc - vth_vec_pa)
                else:
                    pred = _np.sign(acc)
            errs.append(_masked_error(pred, tern))
        path_a_summary = {
            "p50_ber": float(_np.median(errs)) if errs else None,
            "p50_energy_pj": None,
            "window_ns": float(orch.clk.p.window_ns),
        }
    elif cls_choice == 'adaptive' or args.adaptive_input:
        import numpy as _np
        errs = []
        T = int(args.trials)
        maxN = max(1, int(args.adaptive_max_frames))
        margin = float(args.adaptive_margin_mV)
        for _ in range(min(T, 400)):
            tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
            acc = _np.zeros(orch.sys.channels, dtype=float)
            for k in range(maxN):
                r = orch.step(force_ternary=tern)
                dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels))
                if dv.shape[0] != orch.sys.channels:
                    dv = dv[:orch.sys.channels]
                acc = acc[:dv.shape[0]]
                acc += dv
                dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels))
                if dv.shape[0] != orch.sys.channels:
                    dv = dv[:orch.sys.channels]
                acc = acc[:dv.shape[0]]
                acc += dv
                up_th = float(orch.comp.p.vth_mV) + 0.5*float(orch.comp.p.hysteresis_mV)
                if _np.all(_np.abs(acc) >= (up_th + margin)):
                    break
            if vth_vec_pa is not None:
                pred = _np.sign(acc - vth_vec_pa)
            else:
                pred = _np.sign(acc)
            errs.append(_masked_error(pred, tern))
        path_a_summary = {
            "p50_ber": float(_np.median(errs)) if errs else None,
            "p50_energy_pj": None,
            "window_ns": float(orch.clk.p.window_ns),
        }
    elif getattr(args, 'use_decoder_for_path_a', False) and decoder is not None:
        import numpy as _np
        errs = []
        fuse = bool(getattr(args, 'fuse_decoder', False))
        alpha = float(getattr(args, 'fuse_alpha', 0.8))
        _sigma_arg = getattr(args, 'comp_input_noise_mV', None)
        sigma = float(orch.comp.p.input_noise_mV_rms if _sigma_arg is None else _sigma_arg)
        blk = int(getattr(args, 'ecc_spc_block', 4))
        use_ecc = bool(getattr(args, 'use_ecc', False))
        N = int(max(1, getattr(args, 'avg_frames', 1)))
        for _ in range(min(args.trials, 200)):
            tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
            if N > 1:
                acc = _accumulate_dv_over_frames(orch, tern, N, str(getattr(args, 'avg_kernel', 'sum')), float(getattr(args, 'avg_ema_alpha', 0.6)))
                dv = _np.array(acc, dtype=float)
            else:
                r = orch.step(force_ternary=tern)
                dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels), dtype=float)
            l = _np.roll(dv, 1); rr = _np.roll(dv, -1)
            feats = _np.stack([dv, l, rr, _np.abs(dv), dv*dv], axis=1)
            p_dec = _decoder_prob_from_feats(feats, decoder)
            # Optional calibrated probability using dv_lin and vth
            p_cal = None
            if bool(getattr(args, 'force_cal_in_primary', False)) and (lin_scale is not None) and (lin_offset is not None):
                dv_lin = lin_scale*(dv + (lin_offset if lin_offset is not None else 0.0))
                p_cal = _map_prob_from_dv(dv_lin, vth_vec_pa, sigma)
            p_fused = p_dec if not fuse else _fuse_probs(p_cal, p_dec, alpha)
            pred = _np.where(p_fused >= 0.5, 1, -1)
            if use_ecc:
                pred = _apply_spc(pred, p_fused, blk)
            if active_mask is not None:
                M = min(len(active_mask), pred.shape[0])
                am = _np.array(active_mask[:M], dtype=bool)
                pred = pred[:M][am]; tcur = tern[:M][am]
            else:
                tcur = tern
            errs.append(float(_np.mean(pred != tcur)))
        path_a_summary = {
            "p50_ber": float(_np.median(errs)) if errs else None,
            "p50_energy_pj": None,
            "window_ns": float(orch.clk.p.window_ns),
        }
    else:
        path_a_summary = orch.run(trials=args.trials)
    # Add mean_ber to path_a using a lightweight re-run (bounded)
    try:
        _rows_a = run_trials(orch, min(args.trials, 200))
        path_a_summary["mean_ber"] = mean_ber(_rows_a)
    except Exception:
        pass

    # (Mask already built above; no-op here)

    summary = {
        "config": {
            "trials": args.trials,
            "seed": args.seed,
            "sensitivity": args.sensitivity,
            "vote3": (rep == 3 and args.vote3),
            "repeat": rep,
            "neighbor_ct": bool(args.neighbor_ct),
            "base_window_ns": float(args.base_window_ns),
            "applied_calibration": bool(args.apply_calibration),
            "adaptive_input": bool(args.adaptive_input),
            "adaptive_max_frames": int(args.adaptive_max_frames),
            "adaptive_margin_mV": float(args.adaptive_margin_mV),
            "avg_frames": int(args.avg_frames),
            "classifier": (cls_choice or "auto"),
            "mask_bad_channels_req": int(getattr(args, 'mask_bad_channels', 0)),
            "mask_bad_frac_req": float(getattr(args, 'mask_bad_frac', 0.0)),
            "mask_applied_count": int(masked_count),
        },
        "baseline": base_summary,
        "path_a": path_a_summary,
        "path_b": path_b_summary,
        "path_b_chain": path_b_chain,
        "path_b_sweeps": path_b_sweeps,
        "path_b_return_map": path_b_return_map,
        "cold_input": cold_summary,
        "packs": {
            "emitter": emit.__dict__,
            "optics": optx.__dict__,
            "tia": tia.__dict__,
            "comparator": comp.__dict__,
            "clock": clk.__dict__,
        },
        "realism": realism_scores(),
        "components": components,
        "ber_per_tile": per_tile,
        "ber_per_tile_after": per_tile_after,
        "baseline_calibrated": (cal_summary or {}),
        "baseline_calibrated_alt": {
            "soft": (cal_summary_alt_soft or {}),
            "binary": (cal_summary_alt_bin or {}),
        },
        "vote3_p50_ber": vote3_ber,
        "spatial_oversample_p50_ber": spatial_ber,
        "lockin_p50_ber": lockin_ber,
        "chop_p50_ber": chop_ber,
        "avg_frames_p50_ber": avg_frames_ber,
        "soft_thresh_p50_ber": soft_thresh_ber,
        "mitigated_p50_ber": mitigated_ber,
        "sanity": {
            "window_non_increasing": w_ok,
            "rin_non_decreasing": r_ok,
            "crosstalk_non_decreasing": c_ok,
        },
        "effects": effects,
        "window_sweep": {"x_window_ns": w_xs, "p50_ber": w_ys},
        "rin_sweep": {"x_rin_dbhz": r_xs, "p50_ber": r_ys},
        "crosstalk_sweep": {"x_crosstalk_db": c_xs, "p50_ber": c_ys},
        "calibration": {
            "vth_suggest_mV": vth_suggest,
            "ber_before": base_summary.get("p50_ber"),
            "ber_after": ber_after,
            "ber_delta": (None if (ber_after is None or base_summary.get("p50_ber") is None) else float(ber_after - base_summary.get("p50_ber")))
        }
    }

    # Optionally apply calibration to make calibrated KPIs the baseline
    if args.apply_calibration and cal_summary:
        summary["baseline_raw"] = summary["baseline"]
        summary["baseline"] = cal_summary

    # Sensitivity block (skip entirely in light-output mode)
    if not getattr(args, 'light_output', False):
        sens_tia_bw = 30.0
        sens_comp_noise = 0.3
        sens_windows = [3, 6, 10, 15, 20, 30]
        sens_rin = (-170.0, -130.0, 9)
        sens_ct = (-40.0, -15.0, 9)
        sens_emit = EmitterParams(channels=sys_p.channels, power_mw_per_ch=0.05, modulation_mode="pushpull", pushpull_alpha=0.9)
        sens_optx = OpticsParams()
        sens_pd = PDParams()
        sens_tia = TIAParams(bw_mhz=sens_tia_bw, tia_transimpedance_kohm=1.0)
        sens_comp = ComparatorParams(input_noise_mV_rms=sens_comp_noise, vth_mV=5.0)
        sens_clk = ClockParams(window_ns=10.0, jitter_ps_rms=10.0)
        sens_orch = Orchestrator(sys_p, sens_emit, sens_optx, sens_pd, sens_tia, sens_comp, sens_clk)
        sw_xs, sw_ys, sw_ok = quick_window_sweep(sens_orch, trials=args.trials, windows=sens_windows)
        sr_xs, sr_ys, sr_ok = quick_rin_sweep(
            sys_p,
            trials=args.trials,
            starts=sens_rin[0],
            stops=sens_rin[1],
            steps=sens_rin[2],
            tia_bw_mhz=sens_tia_bw,
            comp_noise_mV=sens_comp_noise,
            emit_ext_db=6.0,
            emit_power_mw=0.05,
            tia_R_kohm=1.0,
            comp_vth_mV=5.0,
        )
        sc_xs, sc_ys, sc_ok = quick_crosstalk_sweep(
            sys_p,
            trials=args.trials,
            starts=sens_ct[0],
            stops=sens_ct[1],
            steps=sens_ct[2],
            tia_bw_mhz=sens_tia_bw,
            comp_noise_mV=sens_comp_noise,
            opt_contrast=(0.8, 0.78),
            opt_transmittance=0.6,
        )
        nct_range = (-40.0, -20.0, 5)
        sn_xs, sn_ys, sn_ok = quick_neighbor_ct_sweep(
            sys_p,
            trials=args.trials,
            starts=nct_range[0],
            stops=nct_range[1],
            steps=nct_range[2],
            tia_bw_mhz=sens_tia_bw,
            comp_noise_mV=sens_comp_noise,
            opt_contrast=(0.8, 0.78),
            emit_power_mw=0.05,
            tia_R_kohm=1.0,
            comp_vth_mV=5.0,
        )
        # Diagonal crosstalk sweep
        dct_range = (-45.0, -20.0, 6)
        sd_xs, sd_ys, sd_ok = quick_diag_ct_sweep(
            sys_p,
            trials=args.trials,
            starts=dct_range[0],
            stops=dct_range[1],
            steps=dct_range[2],
            tia_bw_mhz=sens_tia_bw,
            comp_noise_mV=sens_comp_noise,
            opt_contrast=(0.8, 0.78),
            emit_power_mw=0.05,
            tia_R_kohm=1.0,
            comp_vth_mV=5.0,
        )
        sens_effects = {
            "window_ber_improvement": safe_delta(sw_ys),
            "rin_ber_degradation": (sr_ys[-1] - sr_ys[0]) if sr_ys and len(sr_ys) > 1 else 0.0,
            "crosstalk_ber_degradation": (sc_ys[-1] - sc_ys[0]) if sc_ys and len(sc_ys) > 1 else 0.0,
            "neighbor_crosstalk_ber_degradation": (sn_ys[-1] - sn_ys[0]) if sn_ys and len(sn_ys) > 1 else 0.0,
        }
        summary["sensitivity"] = {
            "config": {
                "tia_bw_mhz": sens_tia_bw,
                "comp_input_noise_mV_rms": sens_comp_noise,
                "windows": sens_windows,
                "rin_range": sens_rin,
                "ct_range": sens_ct,
                "neighbor_ct_range": nct_range,
            },
            "sanity": {
                "window_non_increasing": sw_ok,
                "rin_non_decreasing": sr_ok,
                "crosstalk_non_decreasing": sc_ok,
                "neighbor_crosstalk_non_decreasing": sn_ok,
            },
            "effects": sens_effects,
            "window_sweep": {"x_window_ns": sw_xs, "p50_ber": sw_ys},
            "rin_sweep": {"x_rin_dbhz": sr_xs, "p50_ber": sr_ys},
            "crosstalk_sweep": {"x_crosstalk_db": sc_xs, "p50_ber": sc_ys},
            "neighbor_crosstalk_sweep": {"x_ct_neighbor_db": sn_xs, "p50_ber": sn_ys},
            "diag_crosstalk_sweep": {"x_ct_diag_db": sd_xs, "p50_ber": sd_ys},
        }
        # Optional: Per-tile heatmap in sensitivity mode if tiling is square (blocks^2 == channels)
        try:
            if not getattr(args, 'light_output', False):
                from looking_glass.plotting import save_heatmap
                _one = sens_orch.step()
                plus = (_one.get("per_tile", {}) or {}).get("plus")
                minus = (_one.get("per_tile", {}) or {}).get("minus")
                if isinstance(plus, list) and isinstance(minus, list) and plus and minus and isinstance(plus[0], list):
                    save_heatmap(plus, xlabel="tile-x", ylabel="tile-y", out_path="out/per_tile_plus.png", title="Per-tile Plus Intensity")
                    save_heatmap(minus, xlabel="tile-x", ylabel="tile-y", out_path="out/per_tile_minus.png", title="Per-tile Minus Intensity")
        except (ImportError, RuntimeError, ValueError, Exception):
            pass
    else:
        summary["sensitivity"] = None

    # Drift calibration demo (skip in light mode): BER vs time with/without periodic vth re-centering
    try:
        if getattr(args, 'light_output', False) or getattr(args, 'no_drift', False) or getattr(args, 'fast', False):
            raise RuntimeError('skip drift in light output')
        import numpy as _np
        from looking_glass.sim.thermal import ThermalParams as _Therm
        drift_frames = 600
        chunk = 30
        # No calibration
        orch_drift = Orchestrator(
            sys_p,
            EmitterParams(channels=sys_p.channels, power_mw_per_ch=0.7),
            OpticsParams(),
            PDParams(),
            TIAParams(bw_mhz=tia_bw, tia_transimpedance_kohm=5.0),
            ComparatorParams(input_noise_mV_rms=comp_noise),
            ClockParams(window_ns=10.0, jitter_ps_rms=10.0),
            cam_p=None,
            thermal_p=_Therm(drift_scale=0.05, corner_hz=0.01),
        )
        ber_no = []
        xs_no = []
        tmp = []
        for i in range(drift_frames):
            tmp.append(orch_drift.step()["ber"])
            if (i+1) % chunk == 0:
                ber_no.append(float(_np.median(tmp))); xs_no.append(i+1); tmp = []
        # With periodic re-centering
        orch_fix = Orchestrator(
            sys_p,
            EmitterParams(channels=sys_p.channels, power_mw_per_ch=0.7),
            OpticsParams(),
            PDParams(),
            TIAParams(bw_mhz=tia_bw, tia_transimpedance_kohm=5.0),
            ComparatorParams(input_noise_mV_rms=comp_noise),
            ClockParams(window_ns=10.0, jitter_ps_rms=10.0),
            cam_p=None,
            thermal_p=_Therm(drift_scale=0.05, corner_hz=0.01),
        )
        ber_fix = []
        xs_fix = []
        tmp = []
        calib_interval = 5  # chunks
        for i in range(drift_frames):
            tmp.append(orch_fix.step()["ber"])
            if (i+1) % chunk == 0:
                k = (i+1)//chunk
                # periodic re-centering using last chunk's dv
                rows = [orch_fix.step() for _ in range(100)]
                dv = _np.array([r.get("dv_mV", [0]*sys_p.channels) for r in rows])
                truth = _np.array([r.get("truth", [0]*sys_p.channels) for r in rows])
                pos_mean = _np.mean(_np.where(truth>0, dv, _np.nan), axis=0)
                neg_mean = _np.mean(_np.where(truth<0, dv, _np.nan), axis=0)
                vth_vec = _np.nan_to_num(0.5*(pos_mean + neg_mean))
                orch_fix.comp.set_vth_per_channel(vth_vec)
                ber_fix.append(float(_np.median(tmp))); xs_fix.append(i+1); tmp = []
        summary["drift"] = {
            "no_cal": {"x_frame": xs_no, "p50_ber": ber_no},
            "with_cal": {"x_frame": xs_fix, "p50_ber": ber_fix},
        }
    except Exception:
        pass

    # Autotuner (optional)
    _auto_tune_func = None
    constraints: dict[tuple[str, str], dict] = {}
    if args.autotune:
        from looking_glass.tuner import auto_tune as _auto_tune_func
        if args.progress:
            print("PROGRESS: autotune start")
        # Build tuning constraints from packs if provided
        def _merge_constraints(prefix: str, pack: dict | None):
            if not pack: return
            t = pack.get('tuning') or {}
            allowed = t.get('allowed_params') or []
            for item in allowed:
                # item like {'comparator.hysteresis_mV': {min:.., max:..}} or {'tia.bw_mhz': {choices:[..]}}
                for k, v in item.items():
                    if isinstance(k, str) and isinstance(v, dict):
                        if '.' in k:
                            comp, param = k.split('.', 1)
                            constraints[(comp, param)] = v
        _merge_constraints('emitter', emit_override)
        _merge_constraints('optics', optx_override)
        _merge_constraints('sensor', pd_override)
        _merge_constraints('tia', tia_override)
        _merge_constraints('comparator', comp_override)
        _merge_constraints('clock', clk_override)
        # Optional locks: keep optics neighbor/diag CT fixed at initial values
        try:
            if getattr(args, 'lock_optics_ct', False) and getattr(optx, 'ct_model', 'global') == 'neighbor':
                if getattr(optx, 'ct_neighbor_db', None) is not None:
                    constraints[("optics", "ct_neighbor_db")] = {"min": float(optx.ct_neighbor_db), "max": float(optx.ct_neighbor_db)}
                if getattr(optx, 'ct_diag_db', None) is not None:
                    constraints[("optics", "ct_diag_db")] = {"min": float(optx.ct_diag_db), "max": float(optx.ct_diag_db)}
        except Exception:
            pass
    # Local autotune (window/mask/avg)
    local_best = None
    try:
        if getattr(args, 'local_autotune', False):
            import numpy as _np
            la_w = [float(w) for w in str(getattr(args, 'la_windows', '18,19,20,21')).split(',') if w.strip()]
            la_m = [float(m) for m in str(getattr(args, 'la_mask_fracs', '0.0625,0.09375,0.125')).split(',') if m.strip()]
            la_a = [int(a) for a in str(getattr(args, 'la_avg_frames', '2,3')).split(',') if a.strip()]
            best = {"ber": 1.0, "window_ns": None, "mask_frac": None, "avg_frames": None}
            T = int(min(args.trials, 160))
            for w in la_w:
                orch.clk.p.window_ns = float(w)
                for mf in la_m:
                    for af in la_a:
                        # Build a short-run evaluation using current classifier
                        errs = []
                        for _ in range(T):
                            tern = orch.rng.integers(-1, 2, size=orch.sys.channels)
                            r = orch.step(force_ternary=tern)
                            dv = _np.array(r.get("dv_mV", [0]*orch.sys.channels))
                            # Apply avg frames if requested
                            if af > 1:
                                acc = dv.copy().astype(float)
                                for _j in range(af-1):
                                    r2 = orch.step(force_ternary=tern)
                                    acc += _np.array(r2.get("dv_mV", [0]*orch.sys.channels))
                                dv_eff = acc
                            else:
                                dv_eff = dv
                            # Apply mask fraction (select best channels only)
                            M = orch.sys.channels
                            keep = int(max(0, M - int(round(mf*M))))
                            if keep > 0 and keep < M:
                                # Score by |dv|; keep largest
                                idx = _np.argsort(_np.abs(dv_eff))[::-1][:keep]
                                dv_sel = dv_eff[idx]
                                t_sel = tern[idx]
                            else:
                                dv_sel = dv_eff
                                t_sel = tern
                            pred = _np.sign(dv_sel)
                            errs.append(float(_np.mean(pred != t_sel)))
                        med = float(_np.median(errs)) if errs else None
                        if (med is not None) and (med < best["ber"]):
                            best = {"ber": med, "window_ns": float(w), "mask_frac": float(mf), "avg_frames": int(af)}
            local_best = best
            summary["local_autotune"] = best
            # Optionally override primary path_a with local best estimate
            try:
                if getattr(args, 'use_autotuned_as_primary', False) and best.get("ber") is not None:
                    summary["path_a"] = {"p50_ber": best["ber"], "window_ns": best["window_ns"], "note": "local_autotune"}
            except Exception:
                pass
    except Exception:
        pass

    if args.autotune and _auto_tune_func is not None:
        tune_res = _auto_tune_func(
            sys_p,
            EmitterParams(**emit.__dict__),
            OpticsParams(**optx.__dict__),
            PDParams(**pd.__dict__),
            TIAParams(**tia.__dict__),
            ComparatorParams(**comp.__dict__),
            ClockParams(**clk.__dict__),
            trials=int(args.autotune_trials),
            budget=int(args.autotune_budget),
            seed=int(args.seed),
            use_calibration=True,
            constraints=constraints,
        )
        summary["autotune"] = tune_res
        if args.progress:
            print("PROGRESS: autotune done")
        # Optional: re-evaluate path_a with tuned params
        try:
            if getattr(args, 'apply_autotuned_params', False):
                best = (tune_res.get("params") or {})
                def _apply(dobj, key):
                    upd = (best.get(key) or {})
                    if not isinstance(upd, dict):
                        return dobj
                    # keep only attributes that exist on the dataclass
                    filt = {k: v for k, v in upd.items() if hasattr(dobj, k)}
                    return replace(dobj, **filt) if filt else dobj
                sys_t = _apply(sys_p, "system")
                emit_t = _apply(EmitterParams(**emit.__dict__), "emitter")
                optx_t = _apply(OpticsParams(**optx.__dict__), "optics")
                pd_t = _apply(PDParams(**pd.__dict__), "sensor")
                tia_t = _apply(TIAParams(**tia.__dict__), "tia")
                comp_t = _apply(ComparatorParams(**comp.__dict__), "comparator")
                clk_t = _apply(ClockParams(**clk.__dict__), "clock")
                orch_t = Orchestrator(sys_t, emit_t, optx_t, pd_t, tia_t, comp_t, clk_t)
                if args.adaptive_input:
                    import numpy as _np
                    errs = []
                    T = int(args.trials)
                    maxN = max(1, int(args.adaptive_max_frames))
                    margin = float(args.adaptive_margin_mV)
                    for _ in range(min(T, 400)):
                        tern = orch_t.rng.integers(-1, 2, size=orch_t.sys.channels)
                        acc = _np.zeros(orch_t.sys.channels, dtype=float)
                        for k in range(maxN):
                            r = orch_t.step(force_ternary=tern)
                            dv = _np.array(r.get("dv_mV", [0]*orch_t.sys.channels))
                            acc += dv
                            up_th = float(orch_t.comp.p.vth_mV) + 0.5*float(orch_t.comp.p.hysteresis_mV)
                            if _np.all(_np.abs(acc) >= (up_th + margin)):
                                break
                        pred = _np.sign(acc)
                        errs.append(_masked_error(pred, tern))
                    path_a_auto = {
                        "p50_ber": float(_np.median(errs)) if errs else None,
                        "p50_energy_pj": None,
                        "window_ns": float(orch_t.clk.p.window_ns),
                    }
                else:
                    path_a_auto = orch_t.run(trials=args.trials)
                # Add mean_ber for tuned as well
                try:
                    _rows_at = run_trials(orch_t, min(args.trials, 200))
                    path_a_auto["mean_ber"] = mean_ber(_rows_at)
                except Exception:
                    pass
                summary["path_a_autotuned"] = path_a_auto
                try:
                    if getattr(args, 'use_autotuned_as_primary', False):
                        summary["path_a"] = path_a_auto
                except Exception:
                    pass
        except Exception:
            pass
    if not args.quiet:
        print(json.dumps(summary, indent=2))
    if args.json:
        os.makedirs(os.path.dirname(args.json), exist_ok=True)
        with open(args.json, "w", encoding="utf-8") as f:
            json.dump(summary, f, indent=2)
    # Optional: end-to-end combined KPI (simplified)
    try:
        if getattr(args, 'endtoend_report', False):
            pa = summary.get('path_a') or {}
            pb = summary.get('path_b') or {}
            ber_a = pa.get('p50_ber')
            # Prefer analog_p50_ber (TDM Path B), fallback to baseline p50_ber or digital_p50_ber
            ber_b = pb.get('analog_p50_ber')
            if not isinstance(ber_b, (int, float)):
                ber_b = pb.get('p50_ber') if isinstance(pb.get('p50_ber'), (int, float)) else pb.get('digital_p50_ber')
            e2e = None
            # Combined tokens/s proxy: bottleneck between Path A tokens/s and Path B symbol rate
            tok_a = pa.get('p50_tokens_per_s') if isinstance(pa.get('p50_tokens_per_s'), (int, float)) else None
            tok_b = pb.get('tdm_symbols_per_s') if isinstance(pb.get('tdm_symbols_per_s'), (int, float)) else None
            tok_e2e = None
            if isinstance(ber_a, (int, float)) and isinstance(ber_b, (int, float)):
                # naive independence assumption for quick estimate:
                # probability both correct = (1-ber_a)*(1-ber_b), so combined ber ~ 1 - that
                e2e = 1.0 - ((1.0 - float(ber_a)) * (1.0 - float(ber_b)))
            try:
                if isinstance(tok_a, (int, float)) and isinstance(tok_b, (int, float)):
                    tok_e2e = float(min(tok_a, tok_b))
            except Exception:
                pass
            summary['end_to_end'] = {
                'path_a_p50_ber': ber_a,
                'path_b_p50_ber': ber_b,
                'combined_p50_ber_independent': e2e,
                'tokens_per_s': tok_e2e,
            }
            if not args.quiet:
                print(json.dumps({'end_to_end': summary['end_to_end']}, indent=2))
            if args.json:
                with open(args.json, 'w', encoding='utf-8') as f:
                    json.dump(summary, f, indent=2)
    except Exception:
        pass
    # Exit non-zero if any sanity monotonic checks fail
    if not (w_ok and r_ok and c_ok):
        sys.exit(1)


if __name__ == "__main__":
    main()










-----------------------

.\configs\packs\emitter_typ.yaml
wavelength_nm: 850.0
channels: 16
power_mw_per_ch: 1.0
extinction_db: 20.0
rin_dbhz: -150.0
rise_fall_ns_10_90: 1.0
temp_coeff_pct_per_C: 0.2



-----------------------

.\configs\packs\optics_typ.yaml
transmittance: 0.7
w_plus_contrast: 0.85
w_minus_contrast: 0.84
crosstalk_db: -28.0
stray_floor_db: -38.0
psf_kernel: "lorentzian:w=2.5"
signal_scale: 1.0
amp_on: false
amp_gain_db: 10.0
sat_abs_on: false
sat_I_sat: 1.0
sat_alpha: 0.6



-----------------------

.\configs\packs\sensor_typ.yaml
responsivity_A_per_W: 0.55
dark_current_nA: 2.0
cap_pF: 1.0



-----------------------

.\configs\packs\tia_typ.yaml
tia_transimpedance_kohm: 10.0
bw_mhz: 100.0
in_noise_pA_rthz: 5.0
peaking_q: 0.7



-----------------------

.\configs\packs\comparator_typ.yaml
vth_mV: 5.0
hysteresis_mV: 1.0
input_noise_mV_rms: 0.8
drift_mV_per_C: 0.05
prop_delay_ns: 2.0



-----------------------

.\configs\packs\clock_typ.yaml
window_ns: 10.0
jitter_ps_rms: 10.0



-----------------------

.\configs\packs\thermal_typ.yaml
drift_scale: 1.0
corner_hz: 0.01



-----------------------

.\configs\packs\emitter_optimistic.yaml
wavelength_nm: 850.0
channels: 16
power_mw_per_ch: 1.2
extinction_db: 25.0
rin_dbhz: -160.0
rise_fall_ns_10_90: 0.8
temp_coeff_pct_per_C: 0.15



-----------------------

.\configs\packs\emitter_pessimistic.yaml
wavelength_nm: 850.0
channels: 16
power_mw_per_ch: 0.8
extinction_db: 15.0
rin_dbhz: -140.0
rise_fall_ns_10_90: 1.5
temp_coeff_pct_per_C: 0.3



-----------------------

.\configs\packs\optics_optimistic.yaml
transmittance: 0.8
w_plus_contrast: 0.9
w_minus_contrast: 0.9
crosstalk_db: -35.0
stray_floor_db: -45.0
psf_kernel: "lorentzian:w=2.0"
signal_scale: 1.0
amp_on: false
amp_gain_db: 8.0
sat_abs_on: false
sat_I_sat: 1.0
sat_alpha: 0.6



-----------------------

.\configs\packs\optics_pessimistic.yaml
transmittance: 0.6
w_plus_contrast: 0.8
w_minus_contrast: 0.78
crosstalk_db: -22.0
stray_floor_db: -32.0
psf_kernel: "lorentzian:w=3.0"
signal_scale: 1.0
amp_on: false
amp_gain_db: 12.0
sat_abs_on: false
sat_I_sat: 1.0
sat_alpha: 0.6



-----------------------

.\configs\packs\camera_typ.yaml
qe: 0.6
wavelength_nm: 850.0
full_well_e: 20000.0
read_noise_e_rms: 2.0
dark_current_e_per_s: 50.0
prnu_pct: 0.5
adc_bits: 12
adc_fullscale_e: 20000.0



-----------------------

.\configs\packs\tmp_codex_emitter.yaml
vendor: Coherent
model: OBIS 850 nm
category: emitter
price_usd_est: 5500.0
sources:
- https://www.coherent.com/lasers/laser/obis-lx-ls
notes: Integrated low-noise laser module. Many parameters specified; some estimated.
wavelength_nm: 850
coherence_length_m: 5.0
max_optical_power_mw: 150
spectral_drift_pm_per_K: 20
power_drift_percent_per_hr: 0.02
polarization: linear
beam_quality_M2: 1.1
NA: 0.1
ellipticity_ratio: 1.1
modulation_bw_Hz: 100000000.0
RIN_dBc_per_Hz_vs_freq:
  100k: -160
  1M: -165
ESD_sensitive: true
guessed_fields:
- coherence_length_m
- NA
- ellipticity_ratio
power_mw_per_ch: 0.9
power_sigma_pct: 2.0
extinction_db: 15.5
rin_dbhz: -150.0
rise_fall_ns_10_90: 1.0
temp_coeff_pct_per_C: 0.2



-----------------------

.\configs\packs\tmp_codex_tia.yaml
vendor: Texas Instruments
model: OPA857EVM
category: tia
price_usd_est: 149.0
sources:
- https://www.ti.com/tool/OPA857EVM
notes: "5 k\u03A9 / 20 k\u03A9 selectable; up to ~1 GHz with small PD capacitance."
gain_settings:
- Rf_ohm: 5000.0
  Cf_F: 2.0e-12
  bandwidth_Hz: 1000000000.0
- Rf_ohm: 20000.0
  Cf_F: 2.0e-12
  bandwidth_Hz: 500000000.0
input_bias_current_pA: 1.0
input_referred_voltage_noise_nV_per_sqrtHz: 2.5
supply_V:
- 3.3
- 5.0
output_swing_Vpp: 1.5
stability_margin_deg: 60
min_load_ohm: 1000
guessed_fields:
- stability_margin_deg
- Cf_F
tia_transimpedance_kohm: 10.0
bw_mhz: 75.0
in_noise_pA_rthz: 6.1
peaking_q: 0.7
slew_v_per_us: 500.0
adc_bits: 10
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.0
gain_sigma_pct: 1.0



-----------------------

.\configs\packs\tmp_codex_comparator.yaml
vendor: Analog Devices
model: LTC6752
category: comparator
price_usd_est: 4.0
sources:
- https://www.analog.com/en/products/ltc6752.html
notes: 1.25 ns high-speed comparator; LVDS/CMOS family variants.
min_overdrive_mV: 5.0
input_offset_mV: 1.0
input_common_mode_range_V:
- 0
- 5
prop_delay_ns: 1.25
prop_delay_vs_overdrive_ns:
  5mV: 1.7
  20mV: 1.3
hysteresis_mV: 0.75
output_type: LVDS
supply_range_V:
- 2.4
- 5.25
max_toggle_rate_MHz: 200
guessed_fields:
- max_toggle_rate_MHz
vth_mV: 5.0
input_noise_mV_rms: 0.4
drift_mV_per_C: 0.05
saturate_levels: true
vth_sigma_mV: 0.2



-----------------------

.\configs\packs\tmp_codex_optics.yaml
vendor: Thorlabs
model: "Engineered Diffuser 5\xB0"
category: optics
price_usd_est: 195.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9029
notes: Controlled scatter angle; repeatable PSF.
type: engineered_diffuser
scatter_angle_deg_FWHM: 5.0
transmittance_percent: 90.0
thickness_mm: 2.0
dn_dT_per_K: 1.0e-05
surface_roughness_nm: 5.0
Henyey_Greenstein_g: 0.7
guessed_fields:
- g
- dn_dT
ct_model: neighbor
ct_neighbor_db: -45.0
ct_diag_db: -48.0
transmittance: 0.8
psf_kernel: lorentzian:w=2.0



-----------------------

.\configs\packs\tmp_codex_optics_harsh.yaml
ct_model: neighbor
crosstalk_db: -22.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.6
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.7
pdl_db: 0.7
pdl_step_rad: 0.1
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 25.0
reflection_prob: 0.12
grid_px: 0
ct_neighbor_db: -22.0
ct_diag_db: -25.0
dwdm_passband_ripple_db: 1.5
speckle_time_on: true
speckle_time_sigma: 0.2
speckle_time_tau_frames: 20
xgm_on: true
xgm_coeff: 0.3
xpm_on: true
xpm_coeff: 0.2
fwm_on: true
fwm_coeff: 0.12
pol_scrambler_on: true
pol_scramble_every_frames: 10
amp_on: true
amp_gain_db: 3.0
amp_ase_sigma: 0.05
sat_abs_on: true
sat_I_sat: 0.7
sat_alpha: 0.95



-----------------------

.\configs\packs\tmp_codex_optics_medium.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9



-----------------------

.\configs\packs\tmp_lowcost_emitter.yaml
wavelength_nm: 1550.0
power_mw_per_ch: 8.0
extinction_db: 18.0
rin_dbhz: -140.0
rise_fall_ns_10_90: 8.0
temp_coeff_pct_per_C: 0.15
power_sigma_pct: 4.0
modulation_mode: pushpull
pushpull_alpha: 0.85



-----------------------

.\configs\packs\tmp_lowcost_optics.yaml
transmittance: 0.6
ct_model: neighbor
ct_neighbor_db: -26.0
ct_diag_db: -30.0
stray_floor_db: -55.0
ins_loss_db_mean: 1.2
ins_loss_db_sigma: 0.6
pdl_db: 0.5
pdl_step_rad: 0.07
reflection_event_db: 30.0
reflection_prob: 0.1
speckle_time_on: true
speckle_time_sigma: 0.12
speckle_time_tau_frames: 15



-----------------------

.\configs\packs\tmp_lowcost_tia.yaml
tia_transimpedance_kohm: 4.0
bw_mhz: 80.0
in_noise_pA_rthz: 4.8
slew_v_per_us: 250.0
adc_bits: 9
adc_fullscale_v: 0.8



-----------------------

.\configs\packs\tmp_lowcost_comparator.yaml
vth_mV: 5.0
hysteresis_mV: 1.2
input_noise_mV_rms: 0.45
prop_delay_ns: 1.8
vth_sigma_mV: 0.3



-----------------------

.\configs\packs\tmp_lowcost_emitter_boost.yaml
wavelength_nm: 1550.0
power_mw_per_ch: 12.0
extinction_db: 18.0
rin_dbhz: -140.0
rise_fall_ns_10_90: 8.0
temp_coeff_pct_per_C: 0.15
power_sigma_pct: 4.0
modulation_mode: pushpull
pushpull_alpha: 0.85



-----------------------

.\configs\packs\tmp_lowcost_emitter_boost_13p5.yaml
wavelength_nm: 1550.0
power_mw_per_ch: 13.5
extinction_db: 18.0
rin_dbhz: -140.0
rise_fall_ns_10_90: 8.0
temp_coeff_pct_per_C: 0.15
power_sigma_pct: 4.0
modulation_mode: pushpull
pushpull_alpha: 0.85



-----------------------

.\configs\packs\tmp_lowcost_emitter_boost_15.yaml
wavelength_nm: 1550.0
power_mw_per_ch: 15.0
extinction_db: 18.0
rin_dbhz: -140.0
rise_fall_ns_10_90: 8.0
temp_coeff_pct_per_C: 0.15
power_sigma_pct: 4.0
modulation_mode: pushpull
pushpull_alpha: 0.85



-----------------------

.\configs\packs\tmp_codex_optics_lowct.yaml
ct_model: neighbor
crosstalk_db: -30.0
ct_neighbor_db: -45.0
ct_diag_db: -48.0
transmittance: 0.80
psf_kernel: "lorentzian:w=2.0"
stray_floor_db: -70.0
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9



-----------------------

.\configs\packs\tmp_led_array.yaml
# LED array style emitter pack: broader spectrum, higher RIN, slower drive
wavelength_nm: 1550.0
power_mw_per_ch: 6.0
extinction_db: 8.0
rin_dbhz: -120.0
linewidth_hz: 5.0e9
rise_fall_ns_10_90: 15.0
temp_coeff_pct_per_C: 0.4
power_sigma_pct: 6.0
modulation_mode: intensity
pushpull_alpha: 0.0
coherence_length_m: 0.02
notes: Modeled after budget InGaAs LED bar with integrated driver



-----------------------

.\configs\packs\tmp_budget_sensor.yaml
# Budget InGaAs/PIN sensor with higher noise and lower responsivity
responsivity_A_per_W: 0.65
dark_current_nA: 1.8
capacitance_pf: 1.2
bw_mhz: 45.0
shot_noise_scale: 1.0
thermal_noise_scale: 1.3
read_noise_e_rms: 1200
full_well_e: 12000
temp_coeff_pct_per_C: 0.4
notes: Derived from low-cost 8-ch InGaAs array module, room-temp



-----------------------

.\configs\packs\tmp_led_array_stress.yaml
# LED array stressed: lower power, higher RIN, worse stability
wavelength_nm: 1550.0
power_mw_per_ch: 4.0
extinction_db: 6.0
rin_dbhz: -110.0
linewidth_hz: 1.0e10
rise_fall_ns_10_90: 20.0
temp_coeff_pct_per_C: 0.6
power_sigma_pct: 8.0
modulation_mode: intensity
pushpull_alpha: 0.0
coherence_length_m: 0.01
notes: Stress test for bargain-bin LED tile



-----------------------

.\configs\packs\tmp_budget_tia.yaml
# Budget TIA: lower bandwidth, higher noise
mia_type: discrete
tia_transimpedance_kohm: 8.0
bw_mhz: 40.0
in_noise_pA_rthz: 8.0
peaking_q: 0.5
slew_v_per_us: 300.0
adc_bits: 10
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.5
gain_sigma_pct: 2.0
notes: Represents low-cost transimpedance stage built from commodity op-amp



-----------------------

.\configs\packs\tmp_budget_comparator.yaml
# Budget comparator: higher noise, more drift
vth_mV: 8.0
hysteresis_mV: 1.5
input_noise_mV_rms: 0.8
drift_mV_per_C: 0.15
prop_delay_ns: 2.0
prop_jitter_ps_rms: 40.0
saturate_levels: true
vth_sigma_mV: 0.6
metastable_on: true
metastable_width_mV: 0.3
metastable_flip_prob: 0.1
notes: Cheap CMOS comparator array



-----------------------

.\configs\packs\tmp_budget_clock.yaml
window_ns: 6.0
jitter_ps_rms: 45.0




-----------------------

.\configs\packs\tmp_codex_optics_highct.yaml
ct_model: neighbor
ct_neighbor_db: -25.0
ct_diag_db: -28.0
transmittance: 0.72
stray_floor_db: -55.0
psf_kernel: "lorentzian:w=2.5"
notes: High-crosstalk variant for stress sweeps



-----------------------

.\configs\packs\tmp_thermal_drift_heavy.yaml
drift_scale: 6.0
corner_hz: 0.02
notes: Aggressive thermal drift stress for calibration tests



-----------------------

.\configs\packs\tmp_budget_clock_heavy.yaml
window_ns: 6.0
jitter_ps_rms: 75.0
wander_ps: 30.0
notes: High-jitter reference for stress sweeps



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa4.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 4.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa6.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 6.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_gate.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
eom_gate_on: true
eom_gate_duty: 0.3
eom_gate_jitter_ps: 8.0
eom_gate_hold_noise_mw: 0.02
eom_gate_hold_leak: 0.08



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_edfa.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12

# EDFA-oriented settings
amp_on: true
amp_type: edfa
soa_small_signal_gain_db: 6.0   # maps to EDFA small-signal gain in sim
soa_noise_figure_db: 5.0
obpf_bw_nm: 0.5

# Activation shaping to restore contraction
sat_abs_on: true
sat_I_sat: 0.7
sat_alpha: 1.2
post_clip_on: true
post_clip_sat_mw: 0.1
voa_post_db: 4.0




-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_clip.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
hard_clip_on: true
hard_clip_sat_mw: 0.08
post_clip_on: true
post_clip_sat_mw: 0.05
sat_I_sat: 0.6
sat_alpha: 1.2



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_clipsoft.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
hard_clip_on: true
hard_clip_sat_mw: 0.1
post_clip_on: true
post_clip_sat_mw: 0.06



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_clip_nosa.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
hard_clip_on: true
hard_clip_sat_mw: 0.1
post_clip_on: true
post_clip_sat_mw: 0.05
sat_abs_on: false



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa1.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 1.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_lightSA.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
sat_I_sat: 1.4
sat_alpha: 0.7



-----------------------

.\configs\packs\tmp_codex_optics_medium_amp6_voa35.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
amp_gain_db: 6.0
voa_post_db: 3.5



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_nosa.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
sat_abs_on: false



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_amp0.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
amp_on: false



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa1p5_amp1.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 1.5
amp_gain_db: 1.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_SAstrong.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
sat_I_sat: 0.5
sat_alpha: 1.3



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_contrast.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
w_plus_contrast: 0.95
w_minus_contrast: 0.70



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_highcontrast.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
w_plus_contrast: 0.98
w_minus_contrast: 0.20



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_satlin.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
sat_alpha: 0.3



-----------------------

.\configs\packs\tmp_emitter_highpower.yaml
wavelength_nm: 1550.0
power_mw_per_ch: 12.0
extinction_db: 18.0
rin_dbhz: -140.0
rise_fall_ns_10_90: 8.0
temp_coeff_pct_per_C: 0.15
power_sigma_pct: 4.0
modulation_mode: pushpull
pushpull_alpha: 0.85
power_mw_per_ch: 2.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_satHigh.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
sat_I_sat: 10.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_soa_tuned.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.9
sat_alpha: 0.9
voa_post_db: 2.0
soa_small_signal_gain_db: 3.0
soa_tau_ns: 20.0
soa_psat_mw: 20.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_soa_strongsa.yaml
ct_model: neighbor
crosstalk_db: -30.0
stray_floor_db: -70.0
psf_kernel: none
transmittance: 0.72
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.5
pdl_db: 0.4
pdl_step_rad: 0.05
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
reflection_event_db: 28.0
reflection_prob: 0.08
grid_px: 0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
speckle_time_on: true
speckle_time_sigma: 0.1
speckle_time_tau_frames: 12
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.6
sat_alpha: 1.2
voa_post_db: 2.0
soa_small_signal_gain_db: 3.0
soa_tau_ns: 20.0
soa_psat_mw: 20.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_soa_strongsa_single.yaml
ct_model: neighbor
crosstalk_db: -40.0
stray_floor_db: -80.0
psf_kernel: none
transmittance: 0.72
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.02
sat_abs_on: true
sat_I_sat: 0.5
sat_alpha: 1.2
voa_post_db: 2.0
soa_small_signal_gain_db: 3.0
soa_tau_ns: 20.0
soa_psat_mw: 20.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_soa_strongsa_ch4.yaml
ct_model: neighbor
crosstalk_db: -32.0
ct_neighbor_db: -32.0
ct_diag_db: -35.0
stray_floor_db: -75.0
transmittance: 0.72
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.6
sat_alpha: 1.2
voa_post_db: 2.0
soa_small_signal_gain_db: 3.0
soa_tau_ns: 20.0
soa_psat_mw: 20.0



-----------------------

.\configs\packs\tmp_codex_optics_medium_voa2_soa_strongsa_ch8.yaml
ct_model: neighbor
crosstalk_db: -30.0
ct_neighbor_db: -30.0
ct_diag_db: -33.0
stray_floor_db: -75.0
transmittance: 0.72
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.03
sat_abs_on: true
sat_I_sat: 0.6
sat_alpha: 1.2
voa_post_db: 2.0
soa_small_signal_gain_db: 3.0
soa_tau_ns: 20.0
soa_psat_mw: 20.0



-----------------------

.\configs\packs\vendors\emitters\thorlabs_L850P200_typ.yaml
vendor: Thorlabs
model: L850P200
category: emitter
price_usd_est: 150.0
sources:
- https://www.thorlabs.com/thorproduct.cfm?partnumber=L850P200
notes: 850 nm multimode laser diode. Parameters partly estimated from typical 850
  nm MM LD class.
wavelength_nm: 850
coherence_length_m: 0.001
max_optical_power_mw: 200
spectral_drift_pm_per_K: 300
power_drift_percent_per_hr: 0.2
polarization: random
beam_quality_M2: 3.0
NA: 0.22
ellipticity_ratio: 1.5
modulation_bw_Hz: 5000000.0
RIN_dBc_per_Hz_vs_freq:
  100k: -150
  1M: -155
ESD_sensitive: true
guessed_fields:
- coherence_length_m
- power_drift_percent_per_hr
- beam_quality_M2
- RIN_dBc_per_Hz_vs_freq
- modulation_bw_Hz
- ellipticity_ratio



-----------------------

.\configs\packs\vendors\emitters\ushio_HL8518MG_typ.yaml
vendor: Ushio
model: HL8518MG
category: emitter
price_usd_est: 120.0
sources:
- https://www.ushio-opto-semiconductors.com/en/products/laser_diode/850nm/
notes: 850 nm high-power single emitter; some fields estimated.
wavelength_nm: 850
coherence_length_m: 0.01
max_optical_power_mw: 150
spectral_drift_pm_per_K: 300
power_drift_percent_per_hr: 0.1
polarization: linear
beam_quality_M2: 2.0
NA: 0.18
ellipticity_ratio: 1.7
modulation_bw_Hz: 10000000.0
RIN_dBc_per_Hz_vs_freq:
  100k: -150
  1M: -155
ESD_sensitive: true
guessed_fields:
- coherence_length_m
- beam_quality_M2
- RIN_dBc_per_Hz_vs_freq
- modulation_bw_Hz
- ellipticity_ratio



-----------------------

.\configs\packs\vendors\emitters\coherent_OBIS-850-nm_typ.yaml
vendor: Coherent
model: OBIS 850 nm
category: emitter
price_usd_est: 5500.0
sources:
- https://www.coherent.com/lasers/laser/obis-lx-ls
notes: Integrated low-noise laser module. Many parameters specified; some estimated.
wavelength_nm: 850
coherence_length_m: 5.0
max_optical_power_mw: 150
spectral_drift_pm_per_K: 20
power_drift_percent_per_hr: 0.02
polarization: linear
beam_quality_M2: 1.1
NA: 0.1
ellipticity_ratio: 1.1
modulation_bw_Hz: 100000000.0
RIN_dBc_per_Hz_vs_freq:
  100k: -160
  1M: -165
ESD_sensitive: true
guessed_fields:
- coherence_length_m
- NA
- ellipticity_ratio



-----------------------

.\configs\packs\vendors\emitters\ams_osram_SPL-PL85_typ.yaml
vendor: ams OSRAM
model: SPL PL85
category: emitter
price_usd_est: 35.0
sources:
- https://ams-osram.com/products/laser-diodes/spl-pl85
notes: Pulsed 850 nm LD; intended for high-peak LiDAR pulses; CW use limited.
wavelength_nm: 850
coherence_length_m: 0.005
max_optical_power_mw: 1.0
peak_power_W: 25.0
pulse_width_ns: 10.0
rep_rate_kHz: 100
spectral_drift_pm_per_K: 300
polarization: linear
modulation_bw_Hz: 50000000.0
ESD_sensitive: true
guessed_fields:
- coherence_length_m
- CW safe power
- modulation_bw_Hz



-----------------------

.\configs\packs\vendors\emitters\broadcom_VCSEL-12-ch-850-nm-array_typ.yaml
vendor: Broadcom
model: VCSEL 12-ch 850 nm array
category: emitter
price_usd_est: 200.0
sources:
- https://www.broadcom.com/products/optoelectronics/visible-vcsel/
notes: Representative 12-channel VCSEL array; exact model TBD; fields approximated.
wavelength_nm: 850
channels: 12
coherence_length_m: 0.02
max_optical_power_mw_per_ch: 10
spectral_drift_pm_per_K: 70
polarization: linear
beam_quality_M2: 1.2
modulation_bw_Hz: 1000000000.0
RIN_dBc_per_Hz_vs_freq:
  10M: -155
  100M: -160
ESD_sensitive: true
guessed_fields:
- coherence_length_m
- RIN_dBc_per_Hz_vs_freq
- beam_quality_M2



-----------------------

.\configs\packs\vendors\modulators\texas_instruments_DLPLCR4500EVM_typ.yaml
vendor: Texas Instruments
model: DLPLCR4500EVM
category: modulator
price_usd_est: 999.0
sources:
- https://www.ti.com/tool/DLPLCR4500EVM
notes: LightCrafter 4500 DMD; 912x1140; up to ~4 kHz binary patterns; visible window
  (usable at 850 nm with reduced efficiency).
type: DMD
resolution:
- 912
- 1140
max_binary_rate_Hz: 4000
wavelength_band_nm:
- 420
- 700
fill_factor_percent: 85
trigger_latency_us: 50
trigger_jitter_ns: 500
guessed_fields:
- trigger_latency_us
- trigger_jitter_ns



-----------------------

.\configs\packs\vendors\modulators\texas_instruments_DLP2010NIR-EVM_typ.yaml
vendor: Texas Instruments
model: DLP2010NIR EVM
category: modulator
price_usd_est: 799.0
sources:
- https://www.ti.com/tool/DLPNIRNANOEVM
notes: "NIR micromirror modulator; 854x480; band 700\u20132500 nm."
type: DMD
resolution:
- 854
- 480
max_binary_rate_Hz: 4000
wavelength_band_nm:
- 700
- 2500
fill_factor_percent: 92
trigger_latency_us: 40
trigger_jitter_ns: 300
guessed_fields:
- trigger_latency_us
- trigger_jitter_ns



-----------------------

.\configs\packs\vendors\modulators\vialux_V-7000-(DLP7000)_typ.yaml
vendor: Vialux
model: V-7000 (DLP7000)
category: modulator
price_usd_est: 8000.0
sources:
- https://www.vialux.de/en/
notes: High-speed DMD controller for DLP7000; tens of kHz binary patterns.
type: DMD
resolution:
- 1024
- 768
max_binary_rate_Hz: 32000
wavelength_band_nm:
- 400
- 700
fill_factor_percent: 92
trigger_latency_us: 10
trigger_jitter_ns: 100
guessed_fields:
- trigger_latency_us
- trigger_jitter_ns
- max_binary_rate_Hz



-----------------------

.\configs\packs\vendors\modulators\holoeye_LETO-3_typ.yaml
vendor: HOLOEYE
model: LETO-3
category: modulator
price_usd_est: 13000.0
sources:
- https://holoeye.com/spatial-light-modulators/leto/
notes: "Reflective phase SLM 1920x1080; 420\u20131100 nm; kHz range."
type: SLM_phase
resolution:
- 1920
- 1080
phase_depth_rad: 6.28
max_analog_rate_Hz: 1500
wavelength_band_nm:
- 420
- 1100
fill_factor_percent: 93
trigger_latency_us: 200
trigger_jitter_ns: 1000
guessed_fields:
- max_analog_rate_Hz
- trigger figures



-----------------------

.\configs\packs\vendors\modulators\meadowlark_optics_1920x1152-SLM-(VIS)_typ.yaml
vendor: Meadowlark Optics
model: 1920x1152 SLM (VIS)
category: modulator
price_usd_est: 28000.0
sources:
- https://www.meadowlark.com/spatial-light-modulators
notes: High-performance phase SLM; analog phase; fast response.
type: SLM_phase
resolution:
- 1920
- 1152
phase_depth_rad: 6.28
max_analog_rate_Hz: 2000
wavelength_band_nm:
- 400
- 1100
fill_factor_percent: 95
trigger_latency_us: 150
trigger_jitter_ns: 800
guessed_fields:
- max_analog_rate_Hz
- trigger figures



-----------------------

.\configs\packs\vendors\cameras\teledyne_flir_BFS-U3-51S5M-C_typ.yaml
vendor: Teledyne FLIR
model: BFS-U3-51S5M-C
category: camera
price_usd_est: 700.0
sources:
- https://www.flir.com/products/blackfly-s-usb3/
notes: Sony IMX250 5MP GS; generalist. QE at 850 nm estimated from IMX250 curves.
pixel_pitch_um: 3.45
resolution:
- 2448
- 2048
sensor_format: 2/3"
global_shutter: true
bit_depth_modes:
- 8
- 10
- 12
max_fps: 75.0
exposure_min_us: 10.0
exposure_max_ms: 1000.0
qe_at_850nm: 0.25
read_noise_e: 2.5
fixed_pattern_noise_e: 1.0
analog_gain_range_dB:
- 0
- 24
trigger_latency_us: 20
trigger_jitter_ns: 200
ir_cut_filter: false
notes_additional: Use NIR AR lens; disable auto-exposure for deterministic timing.
guessed_fields:
- qe_at_850nm
- trigger figures



-----------------------

.\configs\packs\vendors\cameras\basler_acA1920-155um_typ.yaml
vendor: Basler
model: acA1920-155um
category: camera
price_usd_est: 850.0
sources:
- https://www.baslerweb.com/en/products/cameras/area-scan-cameras/ace/
notes: Sony IMX174 2.3MP GS; high fps; large pixels; great full-well.
pixel_pitch_um: 5.86
resolution:
- 1920
- 1200
sensor_format: 1/1.2"
global_shutter: true
bit_depth_modes:
- 8
- 12
max_fps: 155.0
exposure_min_us: 12.0
exposure_max_ms: 1000.0
qe_at_850nm: 0.2
read_noise_e: 3.0
fixed_pattern_noise_e: 1.2
analog_gain_range_dB:
- 0
- 24
trigger_latency_us: 15
trigger_jitter_ns: 150
ir_cut_filter: false
guessed_fields:
- qe_at_850nm
- trigger figures



-----------------------

.\configs\packs\vendors\cameras\allied_vision_Alvium-1800-U-2040_typ.yaml
vendor: Allied Vision
model: Alvium 1800 U-2040
category: camera
price_usd_est: 500.0
sources:
- https://www.alliedvision.com/en/products/cameras/alvium/
notes: High-resolution option (20 MP variants); fps lower; great for spatial MoE.
pixel_pitch_um: 2.4
resolution:
- 5472
- 3648
sensor_format: 1"
global_shutter: true
bit_depth_modes:
- 8
- 10
max_fps: 17.0
exposure_min_us: 20.0
exposure_max_ms: 1000.0
qe_at_850nm: 0.22
read_noise_e: 2.8
fixed_pattern_noise_e: 1.2
analog_gain_range_dB:
- 0
- 18
trigger_latency_us: 30
trigger_jitter_ns: 300
ir_cut_filter: false
guessed_fields:
- qe_at_850nm
- read_noise
- trigger



-----------------------

.\configs\packs\vendors\cameras\ids_UI-3280CP-Rev.2_typ.yaml
vendor: IDS
model: UI-3280CP Rev.2
category: camera
price_usd_est: 700.0
sources:
- https://en.ids-imaging.com/store/products/cameras/ui-3280cp-rev2.html
notes: IMX264/265 class GS; robust SDK; mid fps.
pixel_pitch_um: 3.45
resolution:
- 2448
- 2048
sensor_format: 2/3"
global_shutter: true
bit_depth_modes:
- 8
- 10
- 12
max_fps: 40.0
exposure_min_us: 15.0
exposure_max_ms: 1000.0
qe_at_850nm: 0.23
read_noise_e: 2.6
fixed_pattern_noise_e: 1.1
analog_gain_range_dB:
- 0
- 24
trigger_latency_us: 25
trigger_jitter_ns: 250
ir_cut_filter: false
guessed_fields:
- qe_at_850nm
- trigger figures



-----------------------

.\configs\packs\vendors\cameras\the_imaging_source_DMK-33UX264_typ.yaml
vendor: The Imaging Source
model: DMK 33UX264
category: camera
price_usd_est: 600.0
sources:
- https://www.theimagingsource.com/products/industrial-cameras/usb-3.0-monochrome/
notes: Sony IMX264 mono GS; good value; NIR usable.
pixel_pitch_um: 3.45
resolution:
- 2448
- 2048
sensor_format: 2/3"
global_shutter: true
bit_depth_modes:
- 8
- 12
max_fps: 35.0
exposure_min_us: 20.0
exposure_max_ms: 1000.0
qe_at_850nm: 0.22
read_noise_e: 3.0
fixed_pattern_noise_e: 1.3
analog_gain_range_dB:
- 0
- 24
trigger_latency_us: 30
trigger_jitter_ns: 300
ir_cut_filter: false
guessed_fields:
- qe_at_850nm
- trigger figures



-----------------------

.\configs\packs\vendors\cameras\teledyne_flir_BFS-U3-51S5M-C_optimistic.yaml
vendor: Teledyne FLIR
model: BFS-U3-51S5M-C
category: camera
price_usd_est: 700.0
sources:
- https://www.flir.com/products/blackfly-s-usb3/
notes: Sony IMX250 5MP GS; generalist. QE at 850 nm estimated from IMX250 curves.
  (optimistic envelope)
pixel_pitch_um: 3.45
resolution:
- 2448
- 2048
sensor_format: 2/3"
global_shutter: true
bit_depth_modes:
- 8
- 10
- 12
max_fps: 97.5
exposure_min_us: 10.0
exposure_max_ms: 1000.0
qe_at_850nm: 0.325
read_noise_e: 1.5
fixed_pattern_noise_e: 0.7
analog_gain_range_dB:
- 0
- 24
trigger_latency_us: 20
trigger_jitter_ns: 200
ir_cut_filter: false
notes_additional: Use NIR AR lens; disable auto-exposure for deterministic timing.
guessed_fields:
- qe_at_850nm
- trigger figures



-----------------------

.\configs\packs\vendors\cameras\teledyne_flir_BFS-U3-51S5M-C_pessimistic.yaml
vendor: Teledyne FLIR
model: BFS-U3-51S5M-C
category: camera
price_usd_est: 700.0
sources:
- https://www.flir.com/products/blackfly-s-usb3/
notes: Sony IMX250 5MP GS; generalist. QE at 850 nm estimated from IMX250 curves.
  (pessimistic envelope)
pixel_pitch_um: 3.45
resolution:
- 2448
- 2048
sensor_format: 2/3"
global_shutter: true
bit_depth_modes:
- 8
- 10
- 12
max_fps: 45.0
exposure_min_us: 10.0
exposure_max_ms: 1000.0
qe_at_850nm: 0.175
read_noise_e: 4.0
fixed_pattern_noise_e: 1.5
analog_gain_range_dB:
- 0
- 24
trigger_latency_us: 20
trigger_jitter_ns: 200
ir_cut_filter: false
notes_additional: Use NIR AR lens; disable auto-exposure for deterministic timing.
guessed_fields:
- qe_at_850nm
- trigger figures



-----------------------

.\configs\packs\vendors\sensors\thorlabs_FDS1010_typ.yaml
vendor: Thorlabs
model: FDS1010
category: sensor
price_usd_est: 108.0
sources:
- https://www.thorlabs.com/thorproduct.cfm?partnumber=FDS1010
notes: "10x10 mm Si PD; large area; high capacitance; 350\u20131100 nm; use at 850\
  \ nm."
responsivity_A_per_W_at_850nm: 0.6
active_area_mm2: 100.0
junction_capacitance_pF_at_Vbias:
  0: 110000
  5: 40000
max_reverse_bias_V: 10
dark_current_nA: 2.0
NEP_W_per_sqrtHz: 8.0e-12
package: TO-8
window_type: AR-coated glass
linearity_percent_FS: 1.0
guessed_fields:
- capacitance curve
- NEP
- linearity



-----------------------

.\configs\packs\vendors\sensors\hamamatsu_S5973_typ.yaml
vendor: Hamamatsu
model: S5973
category: sensor
price_usd_est: 45.0
sources:
- https://www.hamamatsu.com/resources/pdf/ssd/s597x_kspd1024e.pdf
notes: 3x3 mm Si PD; lower Cj; good for MHz BW.
responsivity_A_per_W_at_850nm: 0.55
active_area_mm2: 9.0
junction_capacitance_pF_at_Vbias:
  0: 150
  5: 60
max_reverse_bias_V: 30
dark_current_nA: 0.5
NEP_W_per_sqrtHz: 3.0e-12
package: SMD/TO
window_type: clear
linearity_percent_FS: 0.5



-----------------------

.\configs\packs\vendors\sensors\osi_optoelectronics_PIN-10D_typ.yaml
vendor: OSI Optoelectronics
model: PIN-10D
category: sensor
price_usd_est: 35.0
sources:
- https://www.osioptoelectronics.com/photodiodes/
notes: "10 mm\xB2 Si PD; moderate Cj; general purpose."
responsivity_A_per_W_at_850nm: 0.58
active_area_mm2: 10.0
junction_capacitance_pF_at_Vbias:
  0: 450
  5: 180
max_reverse_bias_V: 20
dark_current_nA: 1.0
NEP_W_per_sqrtHz: 4.0e-12
package: TO-18
window_type: clear
linearity_percent_FS: 1.0
guessed_fields:
- capacitance curve
- NEP



-----------------------

.\configs\packs\vendors\sensors\vishay_BPW34_typ.yaml
vendor: Vishay
model: BPW34
category: sensor
price_usd_est: 2.0
sources:
- https://www.vishay.com/docs/81521/bpw34.pdf
notes: Tiny Si PD; low cost; Cj ~70 pF; good for prototyping.
responsivity_A_per_W_at_850nm: 0.5
active_area_mm2: 7.5
junction_capacitance_pF_at_Vbias:
  0: 70
  5: 15
max_reverse_bias_V: 60
dark_current_nA: 0.1
NEP_W_per_sqrtHz: 1.0e-12
package: leaded
window_type: clear
linearity_percent_FS: 1.0



-----------------------

.\configs\packs\vendors\sensors\thorlabs_PDA20CS2_typ.yaml
vendor: Thorlabs
model: PDA20CS2
category: sensor
price_usd_est: 465.0
sources:
- https://www.thorlabs.com/thorproduct.cfm?partnumber=PDA20CS2
notes: Amplified Si photodetector module 200-1000 nm; includes TIA; use as shortcut.
responsivity_A_per_W_at_850nm: 0.45
active_area_mm2: 10.0
built_in_TIA: true
max_reverse_bias_V: 10
dark_current_nA: 2.0
bandwidth_Hz: 1900000.0
gain_settings:
- 0 dB
- +20 dB
- +40 dB
package: module
window_type: integrated
linearity_percent_FS: 1.0
guessed_fields:
- responsivity
- bandwidth



-----------------------

.\configs\packs\vendors\tias\femto_DLPCA-200_typ.yaml
vendor: FEMTO
model: DLPCA-200
category: tia
price_usd_est: 1750.0
sources:
- https://www.femto.de/products/current-amplifiers/dlpca-200.html
notes: "Variable gain 200 \u03A9 to 2e11 \u03A9; BW from Hz to MHz; lab standard."
gain_settings:
- Rf_ohm: 200
  Cf_F: 1.0e-11
  bandwidth_Hz: 2000000.0
- Rf_ohm: 2000.0
  Cf_F: 1.0e-11
  bandwidth_Hz: 1500000.0
- Rf_ohm: 2000000.0
  Cf_F: 1.0e-11
  bandwidth_Hz: 1000.0
- Rf_ohm: 2000000000.0
  Cf_F: 1.0e-11
  bandwidth_Hz: 1.0
input_bias_current_pA: 5.0
input_referred_voltage_noise_nV_per_sqrtHz: 4.0
supply_V:
- -12
- 12
output_swing_Vpp: 4.0
stability_margin_deg: 45
suggested_input_cap_pF: 1.0
min_load_ohm: 1000
guessed_fields:
- stability_margin_deg
- suggested_input_cap_pF



-----------------------

.\configs\packs\vendors\tias\femto_DHPCA-100_typ.yaml
vendor: FEMTO
model: DHPCA-100
category: tia
price_usd_est: 1950.0
sources:
- https://www.femto.de/products/current-amplifiers/dhpca-100.html
notes: Wideband current amplifier up to 200 MHz; fast loops.
gain_settings:
- transimpedance_V_per_A: 1000.0
  bandwidth_Hz: 200000000.0
- transimpedance_V_per_A: 10000.0
  bandwidth_Hz: 50000000.0
input_bias_current_pA: 10.0
input_referred_voltage_noise_nV_per_sqrtHz: 4.5
supply_V:
- -12
- 12
output_swing_Vpp: 2.0
stability_margin_deg: 40
min_load_ohm: 1000
guessed_fields:
- stability_margin_deg



-----------------------

.\configs\packs\vendors\tias\texas_instruments_OPA857EVM_typ.yaml
vendor: Texas Instruments
model: OPA857EVM
category: tia
price_usd_est: 149.0
sources:
- https://www.ti.com/tool/OPA857EVM
notes: "5 k\u03A9 / 20 k\u03A9 selectable; up to ~1 GHz with small PD capacitance."
gain_settings:
- Rf_ohm: 5000.0
  Cf_F: 2.0e-12
  bandwidth_Hz: 1000000000.0
- Rf_ohm: 20000.0
  Cf_F: 2.0e-12
  bandwidth_Hz: 500000000.0
input_bias_current_pA: 1.0
input_referred_voltage_noise_nV_per_sqrtHz: 2.5
supply_V:
- 3.3
- 5.0
output_swing_Vpp: 1.5
stability_margin_deg: 60
min_load_ohm: 1000
guessed_fields:
- stability_margin_deg
- Cf_F



-----------------------

.\configs\packs\vendors\tias\thorlabs_TIA60_typ.yaml
vendor: Thorlabs
model: TIA60
category: tia
price_usd_est: 365.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=5835
notes: Compact transimpedance amps; mid-band.
gain_settings:
- Rf_ohm: 10000.0
  bandwidth_Hz: 5000000.0
- Rf_ohm: 100000.0
  bandwidth_Hz: 500000.0
input_bias_current_pA: 5.0
input_referred_voltage_noise_nV_per_sqrtHz: 5.0
supply_V:
- -12
- 12
output_swing_Vpp: 4.0
stability_margin_deg: 45
min_load_ohm: 1000
guessed_fields:
- noise
- BW
- stability



-----------------------

.\configs\packs\vendors\tias\analog_devices_AD8015_typ.yaml
vendor: Analog Devices
model: AD8015
category: tia
price_usd_est: 7.0
sources:
- https://www.analog.com/en/products/ad8015.html
notes: TIA for fiber receivers; high speed; requires external design.
gain_settings:
- Rf_ohm: 1000.0
  bandwidth_Hz: 1000000000.0
input_bias_current_pA: 1.0
input_referred_voltage_noise_nV_per_sqrtHz: 2.0
supply_V:
- 5.0
output_swing_Vpp: 1.0
stability_margin_deg: 45
min_load_ohm: 1000
guessed_fields:
- Rf/BW mapping
- noise
- margin



-----------------------

.\configs\packs\vendors\comparators\analog_devices_LTC6752_typ.yaml
vendor: Analog Devices
model: LTC6752
category: comparator
price_usd_est: 4.0
sources:
- https://www.analog.com/en/products/ltc6752.html
notes: 1.25 ns high-speed comparator; LVDS/CMOS family variants.
min_overdrive_mV: 5.0
input_offset_mV: 1.0
input_common_mode_range_V:
- 0
- 5
prop_delay_ns: 1.25
prop_delay_vs_overdrive_ns:
  5mV: 1.7
  20mV: 1.3
hysteresis_mV: 2.0
output_type: LVDS
supply_range_V:
- 2.4
- 5.25
max_toggle_rate_MHz: 200
guessed_fields:
- max_toggle_rate_MHz



-----------------------

.\configs\packs\vendors\comparators\texas_instruments_TLV3501_typ.yaml
vendor: Texas Instruments
model: TLV3501
category: comparator
price_usd_est: 2.5
sources:
- https://www.ti.com/product/TLV3501
notes: 4.5 ns R-R comparator; easy/cheap.
min_overdrive_mV: 10.0
input_offset_mV: 1.5
input_common_mode_range_V:
- 0
- 5
prop_delay_ns: 4.5
prop_delay_vs_overdrive_ns:
  10mV: 5.0
  50mV: 4.3
hysteresis_mV: 5.0
output_type: CMOS
supply_range_V:
- 2.7
- 5.5
max_toggle_rate_MHz: 50



-----------------------

.\configs\packs\vendors\comparators\analog_devices_ADCMP607_typ.yaml
vendor: Analog Devices
model: ADCMP607
category: comparator
price_usd_est: 6.0
sources:
- https://www.analog.com/en/products/adcmp607.html
notes: 1.25 ns; LVDS/CML; precise.
min_overdrive_mV: 5.0
input_offset_mV: 1.0
input_common_mode_range_V:
- 0
- 5
prop_delay_ns: 1.25
output_type: LVDS
supply_range_V:
- 2.7
- 5.5
max_toggle_rate_MHz: 250
hysteresis_mV: 2.0



-----------------------

.\configs\packs\vendors\comparators\texas_instruments_LMH7220_typ.yaml
vendor: Texas Instruments
model: LMH7220
category: comparator
price_usd_est: 4.5
sources:
- https://www.ti.com/product/LMH7220
notes: 800 ps window comparator; LVDS out.
min_overdrive_mV: 5.0
input_offset_mV: 1.0
input_common_mode_range_V:
- 0
- 5
prop_delay_ns: 0.8
output_type: LVDS
supply_range_V:
- 2.7
- 5.0
max_toggle_rate_MHz: 400
hysteresis_mV: 2.0
guessed_fields:
- toggle rate



-----------------------

.\configs\packs\vendors\comparators\maxim_integrated_MAX9601_typ.yaml
vendor: Maxim Integrated
model: MAX9601
category: comparator
price_usd_est: 3.5
sources:
- https://www.analog.com/en/products/max9601.html
notes: 4.5 ns; TTL/CMOS; robust generalist.
min_overdrive_mV: 10.0
input_offset_mV: 2.0
input_common_mode_range_V:
- 0
- 5
prop_delay_ns: 4.5
output_type: CMOS
supply_range_V:
- 2.7
- 5.5
max_toggle_rate_MHz: 60
hysteresis_mV: 5.0



-----------------------

.\configs\packs\vendors\optics\thorlabs_Engineered-Diffuser-5_typ.yaml
vendor: Thorlabs
model: "Engineered Diffuser 5\xB0"
category: optics
price_usd_est: 195.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9029
notes: Controlled scatter angle; repeatable PSF.
type: engineered_diffuser
scatter_angle_deg_FWHM: 5.0
transmittance_percent: 90.0
thickness_mm: 2.0
dn_dT_per_K: 1.0e-05
surface_roughness_nm: 5.0
Henyey_Greenstein_g: 0.7
guessed_fields:
- g
- dn_dT



-----------------------

.\configs\packs\vendors\optics\thorlabs_Engineered-Diffuser-20_typ.yaml
vendor: Thorlabs
model: "Engineered Diffuser 20\xB0"
category: optics
price_usd_est: 195.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9029
notes: Broader scatter for stronger mixing.
type: engineered_diffuser
scatter_angle_deg_FWHM: 20.0
transmittance_percent: 90.0
thickness_mm: 2.0
dn_dT_per_K: 1.0e-05
surface_roughness_nm: 5.0
Henyey_Greenstein_g: 0.6
guessed_fields:
- g
- dn_dT



-----------------------

.\configs\packs\vendors\optics\edmund_optics_Ground-Glass-Diffuser-120-grit_typ.yaml
vendor: Edmund Optics
model: Ground Glass Diffuser 120-grit
category: optics
price_usd_est: 89.0
sources:
- https://www.edmundoptics.com/
notes: Inexpensive random diffuser; more speckle.
type: ground_glass
scatter_angle_deg_FWHM: 10.0
transmittance_percent: 85.0
thickness_mm: 1.5
dn_dT_per_K: 1.0e-05
surface_roughness_nm: 100.0
Henyey_Greenstein_g: 0.5
guessed_fields:
- angle
- roughness
- g



-----------------------

.\configs\packs\vendors\optics\edmund_optics_Light-Shaping-Diffuser-10_typ.yaml
vendor: Edmund Optics
model: "Light Shaping Diffuser 10\xB0"
category: optics
price_usd_est: 135.0
sources:
- https://www.edmundoptics.com/c/light-shaping-diffusers/1430/
notes: Engineered microstructure; repeatable patterns.
type: engineered_diffuser
scatter_angle_deg_FWHM: 10.0
transmittance_percent: 90.0
thickness_mm: 1.0
dn_dT_per_K: 1.0e-05
surface_roughness_nm: 10.0
Henyey_Greenstein_g: 0.65
guessed_fields:
- g
- roughness



-----------------------

.\configs\packs\vendors\optics\generic_K9-glass-cube-25mm_typ.yaml
vendor: Generic
model: K9 glass cube 25mm
category: optics
price_usd_est: 20.0
sources:
- https://www.amazon.com/
notes: Decorative cube; acts as random scattering volume; parameters guessed.
type: volume_scatterer
thickness_mm: 25.0
transmittance_percent: 92.0
group_index: 1.52
GVD_ps_per_nm_km: 100.0
Henyey_Greenstein_g: 0.4
surface_roughness_nm: 20.0
dn_dT_per_K: 1.0e-05
guessed_fields:
- GVD
- g
- roughness



-----------------------

.\configs\packs\vendors\optics\thorlabs_Engineered-Diffuser-10_typ.yaml
vendor: Thorlabs
model: "Engineered Diffuser 10"
category: optics
price_usd_est: 195.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9029
notes: Mid-angle diffuser, compromise between mixing and low neighbor CT.
type: engineered_diffuser
scatter_angle_deg_FWHM: 10.0
transmittance_percent: 90.0
thickness_mm: 2.0
dn_dT_per_K: 1.0e-05
surface_roughness_nm: 5.0
Henyey_Greenstein_g: 0.65
guessed_fields:
- g
- dn_dT





-----------------------

.\configs\packs\vendors\optics\thorlabs_Engineered-Diffuser-15_typ.yaml
vendor: Thorlabs
model: "Engineered Diffuser 15"
category: optics
price_usd_est: 195.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9029
notes: Mid-wide diffuser, stronger mixing, higher neighbor CT than 10.
type: engineered_diffuser
scatter_angle_deg_FWHM: 15.0
transmittance_percent: 90.0
thickness_mm: 2.0
dn_dT_per_K: 1.0e-05
surface_roughness_nm: 5.0
Henyey_Greenstein_g: 0.62
guessed_fields:
- g
- dn_dT





-----------------------

.\configs\packs\vendors\optics\thorlabs_Engineered-Diffuser-3_typ.yaml
vendor: Thorlabs
model: "Engineered Diffuser 3"
category: optics
price_usd_est: 195.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=9029
notes: Narrow-angle diffuser; lowest neighbor crosstalk among this family, tighter PSF.
type: engineered_diffuser
scatter_angle_deg_FWHM: 3.0
transmittance_percent: 90.0
thickness_mm: 2.0
dn_dT_per_K: 1.0e-05
surface_roughness_nm: 5.0
Henyey_Greenstein_g: 0.7
guessed_fields:
- g
- dn_dT





-----------------------

.\configs\packs\vendors\aoms\gooch_&_housego_3080-197_typ.yaml
vendor: Gooch & Housego
model: 3080-197
category: aom
price_usd_est: 2200.0
sources:
- https://www.goochandhousego.com/
notes: "80 MHz center, 700\u2013900 nm; rise/fall ~100 ns class (est)."
center_frequency_MHz: 80.0
aperture_mm: 1.0
rise_time_ns: 100.0
fall_time_ns: 100.0
diff_efficiency_percent_at_full_RF: 80.0
insertion_loss_dB: 3.0
driver_power_W: 2.0
guessed_fields:
- times
- efficiency
- driver_power



-----------------------

.\configs\packs\vendors\aoms\isomet_1205C-1_typ.yaml
vendor: Isomet
model: 1205C-1
category: aom
price_usd_est: 2000.0
sources:
- https://www.isomet.com/
notes: "AOM for 700\u2013900 nm; similar performance."
center_frequency_MHz: 80.0
aperture_mm: 1.0
rise_time_ns: 120.0
fall_time_ns: 120.0
diff_efficiency_percent_at_full_RF: 75.0
insertion_loss_dB: 3.5
driver_power_W: 2.0
guessed_fields:
- times
- efficiency



-----------------------

.\configs\packs\vendors\aoms\g&h_AODRIVER-F-80_typ.yaml
vendor: G&H
model: AODRIVER-F-80
category: aom_driver
price_usd_est: 1200.0
sources:
- https://www.goochandhousego.com/
notes: Matched 80 MHz RF driver.
output_power_W: 3.0
freq_range_MHz:
- 70
- 90
modulation_bw_Hz: 30000000.0



-----------------------

.\configs\packs\vendors\aoms\isomet_232A-2_typ.yaml
vendor: Isomet
model: 232A-2
category: aom_driver
price_usd_est: 1000.0
sources:
- https://www.isomet.com/
notes: RF driver for AOMs.
output_power_W: 2.0
freq_range_MHz:
- 70
- 90
modulation_bw_Hz: 20000000.0



-----------------------

.\configs\packs\vendors\aoms\aa_opto-electronic_MT80-A1_typ.yaml
vendor: AA Opto-Electronic
model: MT80-A1
category: aom
price_usd_est: 2100.0
sources:
- https://www.aaoptoelectronic.com/
notes: "80 MHz AOM; similar performance; 700\u2013900 nm options."
center_frequency_MHz: 80.0
aperture_mm: 1.0
rise_time_ns: 90.0
fall_time_ns: 90.0
diff_efficiency_percent_at_full_RF: 80.0
insertion_loss_dB: 3.0
driver_power_W: 2.0
guessed_fields:
- times
- efficiency



-----------------------

.\configs\packs\vendors\amplifiers\thorlabs_BOA780_typ.yaml
vendor: Thorlabs
model: BOA780
category: soa
price_usd_est: 2395.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=171
notes: "Semiconductor optical amplifier ~780\u2013800 nm; borderline for 850 nm; verify\
  \ gain curve."
band_nm:
- 770
- 810
small_signal_gain_dB: 20.0
noise_figure_dB: 7.0
Psat_out_dBm: 10.0
polarization_dependence_dB: 1.0
ASE_density_nW_per_nm: 50.0
guessed_fields:
- ASE
- NF
- Psat
- PDL



-----------------------

.\configs\packs\vendors\amplifiers\thorlabs_SOA1013S-(C-band)_typ.yaml
vendor: Thorlabs
model: SOA1013S (C-band)
category: soa
price_usd_est: 1995.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=171
notes: C-band SOA; if pivot to 1550 nm; easier ecosystem.
band_nm:
- 1525
- 1565
small_signal_gain_dB: 20.0
noise_figure_dB: 6.0
Psat_out_dBm: 12.0
polarization_dependence_dB: 1.0
ASE_density_nW_per_nm: 40.0



-----------------------

.\configs\packs\vendors\amplifiers\thorlabs_EDFA100P_typ.yaml
vendor: Thorlabs
model: EDFA100P
category: edfa
price_usd_est: 6995.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=1549
notes: "Bench-top EDFA; 20\u201330 dB gain; C-band."
band_nm:
- 1530
- 1565
small_signal_gain_dB: 25.0
noise_figure_dB: 5.0
Psat_out_dBm: 20.0
pump_power_W: 2.0



-----------------------

.\configs\packs\vendors\amplifiers\amonics_AEDFA-23-B-FA_typ.yaml
vendor: Amonics
model: AEDFA-23-B-FA
category: edfa
price_usd_est: 6500.0
sources:
- https://www.amonics.com/product/erbium-doped-fiber-amplifier-edfa/
notes: Bench-top EDFA; telecom-grade.
band_nm:
- 1530
- 1565
small_signal_gain_dB: 23.0
noise_figure_dB: 4.5
Psat_out_dBm: 21.0
pump_power_W: 2.0



-----------------------

.\configs\packs\vendors\amplifiers\batop_SESAM-@-850-nm-(custom)_typ.yaml
vendor: BATOP
model: SESAM @ 850 nm (custom)
category: saturable_absorber
price_usd_est: 1200.0
sources:
- https://www.batop.com/products/saturable-absorbers/
notes: SESAM parameters vary; pick modulation depth and recovery time.
center_wavelength_nm: 850
modulation_depth_percent: 10.0
saturation_fluence_uJ_per_cm2: 50.0
non_saturable_loss_percent: 3.0
recovery_time_ps: 5.0
guessed_fields:
- exact availability at 850 nm
- parameters



-----------------------

.\configs\packs\vendors\fiber\thorlabs_SMF-28-Ultra-5km_typ.yaml
vendor: Thorlabs
model: SMF-28 Ultra 5km
category: fiber
price_usd_est: 1199.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=353
notes: "C-band single-mode; 0.2 dB/km; dispersion ~17 ps/(nm\xB7km)."
type: single_mode
band_nm:
- 1260
- 1625
length_m: 5000
attenuation_dB_per_km: 0.2
dispersion_ps_per_nm_km: 17.0
group_index: 1.468



-----------------------

.\configs\packs\vendors\fiber\thorlabs_SMF-28-Ultra-1000m_typ.yaml
vendor: Thorlabs
model: SMF-28 Ultra 1000m
category: fiber
price_usd_est: 399.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=353
notes: Shorter spool; same params.
type: single_mode
band_nm:
- 1260
- 1625
length_m: 1000
attenuation_dB_per_km: 0.2
dispersion_ps_per_nm_km: 17.0
group_index: 1.468



-----------------------

.\configs\packs\vendors\fiber\generic_OM3-MMF-300m_typ.yaml
vendor: Generic
model: OM3 MMF 300m
category: fiber
price_usd_est: 120.0
sources:
- https://en.wikipedia.org/wiki/Multi-mode_optical_fiber
notes: 850 nm multimode fiber; ~3 dB/km; modal dispersion significant.
type: multimode
band_nm:
- 800
- 900
length_m: 300
attenuation_dB_per_km: 3.0
modal_dispersion_ps_per_km: 1000.0
group_index: 1.49
guessed_fields:
- modal dispersion



-----------------------

.\configs\packs\vendors\fiber\corning_SMF-28e+-1km_typ.yaml
vendor: Corning
model: SMF-28e+ 1km
category: fiber
price_usd_est: 350.0
sources:
- https://www.corning.com/optical-communications/worldwide/en/home/products/fiber/smf-28.html
notes: Classic telecom single-mode.
type: single_mode
band_nm:
- 1260
- 1625
length_m: 1000
attenuation_dB_per_km: 0.2
dispersion_ps_per_nm_km: 17.0
group_index: 1.468



-----------------------

.\configs\packs\vendors\fiber\thorlabs_PM1550-500m_typ.yaml
vendor: Thorlabs
model: PM1550 500m
category: fiber
price_usd_est: 899.0
sources:
- https://www.thorlabs.com/newgrouppage9.cfm?objectgroup_id=252
notes: Polarization-maintaining fiber; useful for coherent loops.
type: PM_single_mode
band_nm:
- 1520
- 1570
length_m: 500
attenuation_dB_per_km: 0.5
dispersion_ps_per_nm_km: 17.0
group_index: 1.468
beat_length_mm: 3.5



-----------------------

.\configs\packs\vendors\thermal\wavelength_electronics_LFI-3751_typ.yaml
vendor: Wavelength Electronics
model: LFI-3751
category: thermal
price_usd_est: 1295.0
sources:
- https://www.teamwavelength.com/product/lfi3751-low-noise-thermoelectric-temperature-controller/
notes: Low-noise TEC controller; excellent stability.
controller_type: PID
temp_setpoint_C: 25.0
settle_time_s: 60.0
TEC_current_max_A: 2.0
sensor_type: 10k NTC
temp_noise_rms_mK: 1.0
ambient_coupling_W_per_K: 0.5



-----------------------

.\configs\packs\vendors\thermal\thorlabs_TED200C_typ.yaml
vendor: Thorlabs
model: TED200C
category: thermal
price_usd_est: 1098.0
sources:
- https://www.thorlabs.com/thorproduct.cfm?partnumber=TED200C
notes: "Bench-top TEC, \xB12 A; lab staple."
controller_type: PID
temp_setpoint_C: 25.0
settle_time_s: 90.0
TEC_current_max_A: 2.0
sensor_type: NTC/RTD
temp_noise_rms_mK: 2.0
ambient_coupling_W_per_K: 0.7



-----------------------

.\configs\packs\vendors\thermal\arroyo_5305-TECSource_typ.yaml
vendor: Arroyo
model: 5305 TECSource
category: thermal
price_usd_est: 1295.0
sources:
- https://arroyo.com/products/5300-series-tecsource/
notes: Bench TEC controller with UI/logging.
controller_type: PID
temp_setpoint_C: 25.0
settle_time_s: 80.0
TEC_current_max_A: 5.0
sensor_type: NTC/RTD
temp_noise_rms_mK: 2.0
ambient_coupling_W_per_K: 0.7



-----------------------

.\configs\packs\vendors\thermal\meerstetter_TEC-1091_typ.yaml
vendor: Meerstetter
model: TEC-1091
category: thermal
price_usd_est: 395.0
sources:
- https://www.meerstetter.ch/
notes: OEM TEC controller; compact; digital control.
controller_type: PID
temp_setpoint_C: 25.0
settle_time_s: 100.0
TEC_current_max_A: 5.0
sensor_type: NTC
temp_noise_rms_mK: 3.0
ambient_coupling_W_per_K: 0.8



-----------------------

.\configs\packs\vendors\thermal\analog_technologies_TEC-A1-5V_typ.yaml
vendor: Analog Technologies
model: TEC-A1-5V
category: thermal
price_usd_est: 69.0
sources:
- https://www.analogtechnologies.com/tec_controller.html
notes: Budget OEM TEC driver; higher noise; good for prototyping.
controller_type: PID
temp_setpoint_C: 25.0
settle_time_s: 150.0
TEC_current_max_A: 1.5
sensor_type: NTC
temp_noise_rms_mK: 5.0
ambient_coupling_W_per_K: 1.0
guessed_fields:
- noise
- settle_time



-----------------------

.\configs\packs\vendors\clocks\pjrc_Teensy-4.1_typ.yaml
vendor: PJRC
model: Teensy 4.1
category: clock
price_usd_est: 29.0
sources:
- https://www.pjrc.com/store/teensy41.html
notes: 600 MHz MCU; GPIO up to ~100+ MHz; good general trigger/clock.
level: TTL_3V3
min_pulse_ns: 10.0
rise_time_ns: 5.0
fanout: 8
skew_ps: 100.0
ext_trig_supported: true



-----------------------

.\configs\packs\vendors\clocks\spincore_PulseBlasterPB24-100-32k_typ.yaml
vendor: SpinCore
model: PulseBlasterPB24-100-32k
category: clock
price_usd_est: 2490.0
sources:
- https://spinapi.com/
notes: Deterministic pulse programmer; sub-ns resolution models available.
level: TTL_5V
min_pulse_ns: 5.0
rise_time_ns: 2.0
fanout: 16
skew_ps: 20.0
ext_trig_supported: true



-----------------------

.\configs\packs\vendors\clocks\national_instruments_USB-6341_typ.yaml
vendor: National Instruments
model: USB-6341
category: clock
price_usd_est: 1999.0
sources:
- https://www.ni.com/en/support/model.usb-6341.html
notes: DAQ timing and IO; moderate-speed triggers.
level: TTL_5V
min_pulse_ns: 20.0
rise_time_ns: 10.0
fanout: 8
skew_ps: 200.0
ext_trig_supported: true



-----------------------

.\configs\packs\vendors\clocks\pico_technology_PicoScope-5444D-(AWG)_typ.yaml
vendor: Pico Technology
model: PicoScope 5444D (AWG)
category: clock
price_usd_est: 1590.0
sources:
- https://www.picotech.com/
notes: Scope with AWG; handy during bring-up.
level: TTL_3V3
min_pulse_ns: 10.0
rise_time_ns: 5.0
fanout: 2
skew_ps: 200.0
ext_trig_supported: true



-----------------------

.\configs\packs\vendors\clocks\analog_devices_AD9910-DDS-Eval-Board_typ.yaml
vendor: Analog Devices
model: AD9910 DDS Eval Board
category: clock
price_usd_est: 350.0
sources:
- https://www.analog.com/en/products/ad9910.html
notes: DDS for precise RF clocking (AOM drive source reference).
level: LVDS
min_pulse_ns: 2.0
rise_time_ns: 1.0
fanout: 4
skew_ps: 50.0
ext_trig_supported: true



-----------------------

.\configs\packs\overlays\comparator_sweep.yaml
# Comparator overlay: keep typ values and constrain tuner to comparator-only micro-sweep
vth_mV: 5.0
hysteresis_mV: 2.0
input_noise_mV_rms: 0.3
drift_mV_per_C: 0.05
prop_delay_ns: 1.25
saturate_levels: true
vth_sigma_mV: 0.2

tuning:
  allowed_params:
    - comparator.hysteresis_mV:
        min: 0.6
        max: 1.0
    - comparator.input_noise_mV_rms:
        min: 0.35
        max: 0.5




-----------------------

.\configs\packs\overlays\tia_sweep.yaml
# TIA overlay: constrain tuner to BW and transimpedance micro-sweep near tuned region
tia_transimpedance_kohm: 10.0
bw_mhz: 70.0
in_noise_pA_rthz: 5.0
peaking_q: 0.7
slew_v_per_us: 500.0
adc_bits: 10
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.0
gain_sigma_pct: 1.0

tuning:
  allowed_params:
    - tia.tia_transimpedance_kohm:
        min: 8.0
        max: 12.0
    - tia.bw_mhz:
        choices: [60, 65, 70, 75, 80]




-----------------------

.\configs\packs\overlays\tuned_tia.yaml
# Tuned TIA overlay for ~0.065 BER Path A recipe
# Derived from successful runs around 1618 ns with OPA857EVM + BPW34
tia_transimpedance_kohm: 10.0
bw_mhz: 75.0
in_noise_pA_rthz: 6.1
peaking_q: 0.7
slew_v_per_us: 500.0
adc_bits: 10
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.0
gain_sigma_pct: 1.0




-----------------------

.\configs\packs\overlays\tuned_comparator.yaml
# Tuned comparator overlay for ~0.065 BER Path A recipe
vth_mV: 5.0
hysteresis_mV: 0.75
input_noise_mV_rms: 0.40
drift_mV_per_C: 0.05
prop_delay_ns: 1.25
saturate_levels: true
vth_sigma_mV: 0.2




-----------------------

.\configs\packs\overlays\tuned_emitter_boost.yaml
# Slight emitter power boost to increase dv margin without changing packs
power_mw_per_ch: 0.90
power_sigma_pct: 2.0
extinction_db: 15.5
rin_dbhz: -150.0
rise_fall_ns_10_90: 1.0
temp_coeff_pct_per_C: 0.2




-----------------------

.\configs\packs\overlays\tia_12k_65.yaml
tia_transimpedance_kohm: 12.0
bw_mhz: 65.0
in_noise_pA_rthz: 6.1




-----------------------

.\configs\packs\overlays\optics_low_ct.yaml
ct_model: neighbor
ct_neighbor_db: -45.0
ct_diag_db: -48.0
transmittance: 0.8
psf_kernel: "lorentzian:w=2.0"




-----------------------

.\configs\packs\overlays\optics_stage_a_hygiene.yaml
ct_model: neighbor
ct_neighbor_db: -50.0
ct_diag_db: -53.0
# Slightly improved enclosure/baffles/diffuser hygiene: modest transmission loss but better PSF
transmittance: 0.85
# Narrower effective PSF via improved baffling and engineered diffuser choice
psf_kernel: "lorentzian:w=1.7"





-----------------------

.\configs\packs\overlays\tia_stage_b_low_noise.yaml
# Stage B: lower input-referred noise and appropriate bandwidth/gain
tia_transimpedance_kohm: 12.0
bw_mhz: 60.0
in_noise_pA_rthz: 4.5
peaking_q: 0.65
slew_v_per_us: 600.0
adc_bits: 12
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.0
gain_sigma_pct: 1.0





-----------------------

.\configs\packs\overlays\comparator_stage_c_trims.yaml
# Stage C: comparator trims and hysteresis tuning
vth_mV: 5.0
hysteresis_mV: 0.6
input_noise_mV_rms: 0.30
vth_sigma_mV: 0.15
prop_delay_ns: 1.1
saturate_levels: true





-----------------------

.\configs\packs\overlays\optics_stage_e_power_mod.yaml
ct_model: neighbor
ct_neighbor_db: -52.0
ct_diag_db: -55.0
transmittance: 0.9
psf_kernel: "lorentzian:w=1.6"
# Effective knobs used by the simulator
signal_scale: 1.30
w_plus_contrast: 0.90
w_minus_contrast: 0.90
stray_floor_db: -42.0





-----------------------

.\configs\packs\overlays\tia_stage_b2_low_noise.yaml
tia_transimpedance_kohm: 15.0
bw_mhz: 55.0
in_noise_pA_rthz: 3.6
peaking_q: 0.6
slew_v_per_us: 700.0
adc_bits: 12
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.0
gain_sigma_pct: 1.0





-----------------------

.\configs\packs\overlays\optics_stage_e2_power_mod.yaml
ct_model: neighbor
ct_neighbor_db: -54.0
ct_diag_db: -57.0
transmittance: 0.92
psf_kernel: "lorentzian:w=1.5"
# Effective knobs used by the simulator
signal_scale: 1.60
w_plus_contrast: 0.92
w_minus_contrast: 0.92
stray_floor_db: -44.0





-----------------------

.\configs\packs\overlays\comparator_stage_c2_trims.yaml
vth_mV: 5.0
hysteresis_mV: 0.5
input_noise_mV_rms: 0.24
vth_sigma_mV: 0.10
prop_delay_ns: 1.0
saturate_levels: true





-----------------------

.\configs\packs\overlays\optics_stage_f_amp.yaml
ct_model: neighbor
ct_neighbor_db: -55.0
ct_diag_db: -58.0
transmittance: 0.9
psf_kernel: "lorentzian:w=1.5"
signal_scale: 1.40
w_plus_contrast: 0.92
w_minus_contrast: 0.92
stray_floor_db: -44.0
amp_on: true
amp_gain_db: 8.0
amp_ase_sigma: 0.006





-----------------------

.\configs\packs\overlays\optics_stage_g_saturable.yaml
ct_model: neighbor
ct_neighbor_db: -55.0
ct_diag_db: -58.0
transmittance: 0.9
psf_kernel: "lorentzian:w=1.5"
signal_scale: 1.30
w_plus_contrast: 0.92
w_minus_contrast: 0.92
stray_floor_db: -44.0
sat_abs_on: true
sat_I_sat: 1.5
sat_alpha: 0.7





-----------------------

.\configs\packs\overlays\comparator_stage_c3_precision.yaml
vth_mV: 5.0
hysteresis_mV: 0.5
input_noise_mV_rms: 0.20
vth_sigma_mV: 0.08
prop_delay_ns: 0.9
saturate_levels: true





-----------------------

.\configs\packs\overlays\tia_stage_b3_precision.yaml
tia_transimpedance_kohm: 18.0
bw_mhz: 50.0
in_noise_pA_rthz: 3.0
peaking_q: 0.55
slew_v_per_us: 800.0
adc_bits: 12
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.0
gain_sigma_pct: 0.8





-----------------------

.\configs\packs\overlays\optics_stress_ct_stray.yaml
ct_model: neighbor
ct_neighbor_db: -38.0
ct_diag_db: -42.0
transmittance: 0.85
psf_kernel: "lorentzian:w=3.0"
signal_scale: 1.0
w_plus_contrast: 0.85
w_minus_contrast: 0.85
stray_floor_db: -36.0





-----------------------

.\configs\packs\overlays\comparator_stress_sigma.yaml
vth_mV: 5.0
hysteresis_mV: 0.5
input_noise_mV_rms: 0.45
vth_sigma_mV: 0.4
prop_delay_ns: 1.5
saturate_levels: true





-----------------------

.\configs\packs\overlays\tia_stress_gainvar.yaml
tia_transimpedance_kohm: 10.0
bw_mhz: 80.0
in_noise_pA_rthz: 7.0
peaking_q: 0.8
slew_v_per_us: 400.0
adc_bits: 10
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.0
gain_sigma_pct: 5.0





-----------------------

.\configs\packs\overlays\optics_speckle_stress.yaml
speckle_on: true
speckle_sigma: 0.15
speckle_corr_px: 11





-----------------------

.\configs\packs\overlays\comparator_metastable_stress.yaml
metastable_on: true
metastable_width_mV: 0.3
metastable_flip_prob: 0.08





-----------------------

.\configs\packs\overlays\optics_stage_fg_amp_sat.yaml
ct_model: neighbor
ct_neighbor_db: -55.0
ct_diag_db: -58.0
transmittance: 0.9
psf_kernel: "lorentzian:w=1.5"
signal_scale: 1.35
w_plus_contrast: 0.92
w_minus_contrast: 0.92
stray_floor_db: -44.0
amp_on: true
amp_gain_db: 6.0
amp_ase_sigma: 0.006
sat_abs_on: true
sat_I_sat: 1.4
sat_alpha: 0.65






-----------------------

.\configs\packs\overlays\optics_projector_low.yaml
ct_model: neighbor
ct_neighbor_db: -40.0
ct_diag_db: -45.0
psf_kernel: "lorentzian:w=3.0"
stray_floor_db: -38.0
transmittance: 0.8
tile_border_px: 1
tile_gain_sigma_pct: 1.0
tile_isolation: false
speckle_on: false





-----------------------

.\configs\packs\overlays\optics_projector_mid.yaml
ct_model: neighbor
ct_neighbor_db: -48.0
ct_diag_db: -52.0
psf_kernel: "lorentzian:w=2.5"
stray_floor_db: -42.0
transmittance: 0.85
tile_border_px: 2
tile_gain_sigma_pct: 0.7
tile_isolation: false
speckle_on: false





-----------------------

.\configs\packs\overlays\optics_projector_strong.yaml
ct_model: neighbor
ct_neighbor_db: -52.0
ct_diag_db: -56.0
psf_kernel: "lorentzian:w=2.0"
stray_floor_db: -45.0
transmittance: 0.9
tile_border_px: 3
tile_gain_sigma_pct: 0.5
tile_isolation: true
speckle_on: false





-----------------------

.\configs\packs\overlays\camera_projector_typ.yaml
qe: 0.25
wavelength_nm: 550.0
read_noise_e_rms: 2.5
prnu_pct: 1.0
adc_bits: 10
adc_fullscale_e: 16000.0





-----------------------

.\configs\packs\overlays\optics_projector_isolated.yaml
ct_model: neighbor
ct_neighbor_db: -60.0
ct_diag_db: -64.0
psf_kernel: "lorentzian:w=2.0"
stray_floor_db: -46.0
transmittance: 0.9
tile_border_px: 4
tile_gain_sigma_pct: 0.8
tile_isolation: true
speckle_on: false
grid_px: 160





-----------------------

.\configs\packs\overlays\optics_projector_iso_strong.yaml
ct_model: neighbor
ct_neighbor_db: -64.0
ct_diag_db: -68.0
psf_kernel: "lorentzian:w=2.0"
stray_floor_db: -48.0
transmittance: 0.92
signal_scale: 1.15
tile_border_px: 6
tile_gain_sigma_pct: 0.5
tile_isolation: true
speckle_on: false
grid_px: 192





-----------------------

.\configs\packs\overlays\optics_projector_dmd_strong.yaml
ct_model: neighbor
ct_neighbor_db: -66.0
ct_diag_db: -70.0
psf_kernel: "lorentzian:w=1.8"
stray_floor_db: -50.0
transmittance: 0.94
signal_scale: 1.35
tile_border_px: 6
tile_gain_sigma_pct: 0.3
tile_isolation: true
speckle_on: false
grid_px: 256





-----------------------

.\configs\packs\overlays\optics_stage_f_amp_g4.yaml
ct_model: neighbor
ct_neighbor_db: -55.0
ct_diag_db: -58.0
transmittance: 0.9
psf_kernel: "lorentzian:w=1.5"
signal_scale: 1.35
w_plus_contrast: 0.92
w_minus_contrast: 0.92
stray_floor_db: -44.0
amp_on: true
amp_gain_db: 4.0
amp_ase_sigma: 0.006





-----------------------

.\configs\packs\overlays\optics_stage_g_saturable_soft.yaml
ct_model: neighbor
ct_neighbor_db: -55.0
ct_diag_db: -58.0
transmittance: 0.9
psf_kernel: "lorentzian:w=1.5"
signal_scale: 1.30
w_plus_contrast: 0.92
w_minus_contrast: 0.92
stray_floor_db: -44.0
sat_abs_on: true
sat_I_sat: 1.8
sat_alpha: 0.55





-----------------------

.\configs\packs\overlays\optics_stage_fg_amp_sat_soft.yaml
ct_model: neighbor
ct_neighbor_db: -60.0
ct_diag_db: -64.0
transmittance: 0.92
psf_kernel: "lorentzian:w=1.8"
signal_scale: 1.35
w_plus_contrast: 0.92
w_minus_contrast: 0.92
stray_floor_db: -46.0
amp_on: true
amp_gain_db: 4.0
amp_ase_sigma: 0.006
sat_abs_on: true
sat_I_sat: 1.8
sat_alpha: 0.55





-----------------------

.\configs\packs\overlays\optics_projector_iso_stronger.yaml
ct_model: neighbor
ct_neighbor_db: -66.0
ct_diag_db: -70.0
psf_kernel: "lorentzian:w=1.8"
stray_floor_db: -50.0
transmittance: 0.92
tile_border_px: 8
tile_gain_sigma_pct: 0.5
tile_isolation: true
grid_px: 256
speckle_on: false





-----------------------

.\configs\packs\overlays\optics_projector_iso_extreme.yaml
ct_model: neighbor
ct_neighbor_db: -72.0
ct_diag_db: -76.0
psf_kernel: "lorentzian:w=1.6"
stray_floor_db: -52.0
transmittance: 0.93
tile_border_px: 10
tile_gain_sigma_pct: 0.4
tile_isolation: true
grid_px: 320
speckle_on: false





-----------------------

.\configs\packs\overlays\optics_iso_boost.yaml
ct_model: neighbor
ct_neighbor_db: -72.0
ct_diag_db: -76.0
psf_kernel: "lorentzian:w=1.6"
stray_floor_db: -52.0
transmittance: 0.94
signal_scale: 1.50
tile_border_px: 10
tile_gain_sigma_pct: 0.4
tile_isolation: true
grid_px: 320
speckle_on: false





-----------------------

.\configs\packs\overlays\optics_ambient_stress.yaml
ct_model: neighbor
ct_neighbor_db: -48.0
ct_diag_db: -52.0
psf_kernel: "lorentzian:w=2.5"
stray_floor_db: -35.0
transmittance: 0.85
tile_border_px: 2
tile_gain_sigma_pct: 1.5
tile_isolation: false
grid_px: 160
speckle_on: false





-----------------------

.\configs\packs\overlays\optics_iso_boost2.yaml
crosstalk_db: -55.0
stray_floor_db: -60.0
psf_kernel: "lorentzian:w=1.5"
signal_scale: 1.45
tile_border_px: 4
tile_isolation: true
tile_gain_sigma_pct: 0.0
grid_px: 256





-----------------------

.\configs\packs\overlays\optics_upper_bound.yaml
crosstalk_db: -70.0
stray_floor_db: -70.0
psf_kernel: "lorentzian:w=1.0"
signal_scale: 1.60
tile_border_px: 4
tile_isolation: true
tile_gain_sigma_pct: 0.0
grid_px: 256





-----------------------

.\configs\packs\overlays\optics_accept_grid256.yaml
psf_kernel: "lorentzian:w=1.5"
signal_scale: 1.20
tile_border_px: 3
tile_isolation: true
tile_gain_sigma_pct: 0.0
grid_px: 256





-----------------------

.\configs\packs\overlays\optics_accept_grid512.yaml
psf_kernel: "lorentzian:w=1.3"
signal_scale: 1.30
tile_border_px: 4
tile_isolation: true
tile_gain_sigma_pct: 0.0
grid_px: 512





-----------------------

.\configs\packs\overlays\emitter_budget_noisy.yaml
wavelength_nm: 850.0
power_mw_per_ch: 50.0
extinction_db: 20.0
rin_dbhz: -135.0
rise_fall_ns_10_90: 10.0
temp_coeff_pct_per_C: 0.15



-----------------------

.\configs\packs\overlays\emitter_vcsel_array_8ch.yaml
wavelength_nm: 850.0
power_mw_per_ch: 8.0
extinction_db: 15.0
rin_dbhz: -130.0
rise_fall_ns_10_90: 2.0
temp_coeff_pct_per_C: 0.20



-----------------------

.\configs\packs\overlays\emitter_cband_dfb_typ.yaml
wavelength_nm: 1550.0
power_mw_per_ch: 20.0
extinction_db: 25.0
rin_dbhz: -150.0
rise_fall_ns_10_90: 5.0
temp_coeff_pct_per_C: 0.08



-----------------------

.\configs\packs\overlays\fiber_cband_loop_typ.yaml
# C-band fiber loop path: losses, low speckle, insertion components
ct_model: none
crosstalk_db: -70.0
stray_floor_db: -70.0
psf_kernel: "none"
transmittance: 0.85
# Aggregate insertion loss for isolator/mux/demux/couplers per pass (dB)
ins_loss_db: 3.0
ins_loss_db_mean: 0.5
ins_loss_db_sigma: 0.3
# Polarization-dependent loss (slow random walk)
pdl_db: 0.2
pdl_step_rad: 0.02
# DWDM passband slope (dB/nm) and group delay ripple (ps pk-pk)
dwdm_slope_db_per_nm: 2.0
gdr_ps_pkpk: 15.0
# Back-reflection spike stress
reflection_event_db: 35.0
reflection_prob: 0.02
# Use grid-less (no projector tiling) semantics
grid_px: 0



-----------------------

.\configs\packs\overlays\edfa_chain_typ.yaml
# EDFA-based loop gain stage with ASE and band-pass filter cleanup
amp_on: true
amp_gain_db: 10.0
amp_ase_sigma: 0.02
# OBPF + VOA effective transmittance
transmittance: 0.75
# Keep crosstalk/stray low in fiber
crosstalk_db: -70.0
stray_floor_db: -65.0



-----------------------

.\configs\packs\overlays\soa_chain_soft.yaml
# SOA-based loop gain stage, softer gain and saturation-like behavior
amp_on: true
amp_gain_db: 4.0
amp_ase_sigma: 0.008
sat_abs_on: true
sat_I_sat: 2.5
sat_alpha: 0.5
transmittance: 0.85
crosstalk_db: -70.0
stray_floor_db: -65.0



-----------------------

.\configs\packs\overlays\receiver_ingaas_typ.yaml
# InGaAs photodiode + TIA characteristics (typical 1550 nm)
responsivity_a_per_w: 0.9
junction_cap_pF: 0.5
dark_current_nA: 5.0
bw_hz: 1.0e9
input_referred_noise_nV_rtHz: 4.0



-----------------------

.\configs\packs\overlays\edfa_chain_stress.yaml
amp_on: true
amp_gain_db: 8.0
amp_ase_sigma: 0.05
transmittance: 0.65
crosstalk_db: -60.0
stray_floor_db: -58.0



-----------------------

.\configs\packs\overlays\soa_chain_stress.yaml
amp_on: true
amp_gain_db: 2.0
amp_ase_sigma: 0.015
sat_abs_on: true
sat_I_sat: 1.5
sat_alpha: 0.7
transmittance: 0.80
crosstalk_db: -60.0
stray_floor_db: -58.0



-----------------------

.\configs\packs\overlays\dwdm_crosstalk_ripple.yaml
# DWDM impairments approximated via crosstalk/stray and transmittance ripple proxy
crosstalk_db: -45.0
stray_floor_db: -55.0
transmittance: 0.80



-----------------------

.\configs\packs\overlays\receiver_ingaas_lowbw.yaml
responsivity_a_per_w: 0.85
junction_cap_pF: 0.8
dark_current_nA: 8.0
bw_hz: 1.5e8
input_referred_noise_nV_rtHz: 6.0



-----------------------

.\configs\packs\overlays\edfa_chain_budget.yaml
amp_on: true
amp_gain_db: 6.0
amp_ase_sigma: 0.08
transmittance: 0.60
crosstalk_db: -55.0
stray_floor_db: -55.0



-----------------------

.\configs\packs\overlays\soa_chain_budget.yaml
amp_on: true
amp_gain_db: 2.5
amp_ase_sigma: 0.02
sat_abs_on: true
sat_I_sat: 1.2
sat_alpha: 0.8
transmittance: 0.78
crosstalk_db: -55.0
stray_floor_db: -55.0



-----------------------

.\configs\packs\overlays\fiber_cband_loop_stress.yaml
# Stress C-band fiber loop overlay: stronger impairments for must-fail checks
transmittance: 0.85
crosstalk_db: -40.0
stray_floor_db: -60.0
psf_kernel: "gaussian:w=0.5"
signal_scale: 1.0
# Per-pass IL variation (sigma in dB)
per_pass_il_sigma_db: 0.3
# Polarization dependent loss (slow drift)
pdl_db_sigma: 0.2
pdl_corr_frames: 10
# DWDM impairments
dwdm_passband_il_db: 2.0
dwdm_passband_ripple_db: 0.5
# Group delay ripple (ps pk-pk) if supported
dwdm_group_delay_ripple_ps: 20.0
# Back-reflection spike stress (supported by optics model)
reflection_event_db: 30.0
reflection_prob: 0.05



-----------------------

.\configs\packs\overlays\comparator_jitter_5ps.yaml
prop_jitter_ps_rms: 5.0



-----------------------

.\configs\packs\overlays\comparator_jitter_15ps.yaml
prop_jitter_ps_rms: 15.0



-----------------------

.\configs\packs\overlays\clock_jitter_8ps.yaml
jitter_ps_rms: 8.0



-----------------------

.\configs\packs\overlays\clock_jitter_20ps.yaml
jitter_ps_rms: 20.0



-----------------------

.\configs\packs\overlays\tia_bw_100mhz_slew.yaml
bw_mhz: 100.0
bw2_mhz: 0.0
slew_v_per_us: 400.0



-----------------------

.\configs\packs\overlays\tia_bw_300mhz_slew.yaml
bw_mhz: 300.0
bw2_mhz: 0.0
slew_v_per_us: 600.0



-----------------------

.\configs\packs\overlays\edfa_ase_tight_obpf.yaml
amp_on: true
amp_gain_db: 12.0
amp_ase_sigma: 0.06
obpf_transmittance: 0.7



-----------------------

.\configs\packs\overlays\edfa_ase_high_tight_obpf.yaml
amp_on: true
amp_gain_db: 12.0
amp_ase_sigma: 0.08
obpf_transmittance: 0.65



-----------------------

.\configs\packs\overlays\soa_gain1p5_sat_strong.yaml
amp_on: true
amp_gain_db: 1.5
amp_ase_sigma: 0.04
sat_abs_on: true
sat_I_sat: 0.8
sat_alpha: 0.9



-----------------------

.\configs\packs\overlays\soa_gain3p0_sat_strong.yaml
amp_on: true
amp_gain_db: 3.0
amp_ase_sigma: 0.05
sat_abs_on: true
sat_I_sat: 0.7
sat_alpha: 0.95



-----------------------

.\configs\packs\overlays\optics_hyperstress_dwdm.yaml
crosstalk_db: -30.0
dwdm_passband_ripple_db: 1.0



-----------------------

.\configs\packs\overlays\optics_harsher_nonlinear.yaml
# Harsher nonlinear optics overlay for multi- stress
speckle_time_on: true
speckle_time_sigma: 0.08
speckle_time_tau_frames: 50
xgm_on: true
xgm_coeff: 0.08
xpm_on: true
xpm_coeff: 0.05
fwm_on: true
fwm_coeff: 0.03



-----------------------

.\configs\packs\overlays\dwdm_adjacent_-28db.yaml
crosstalk_db: -28.0
dwdm_passband_ripple_db: 1.0



-----------------------

.\configs\packs\overlays\optics_harsher_nonlinear_extreme.yaml
# Extreme nonlinear optics overlay (keys aligned to optics.py)
transmittance: 0.65
ins_loss_db_sigma: 0.5
pdl_db: 0.5
pdl_step_rad: 0.05
# DWDM poor adjacent isolation and ripple
crosstalk_db: -25.0
ct_model: neighbor
ct_neighbor_db: -25.0
ct_diag_db: -28.0
dwdm_passband_ripple_db: 1.2
# Slow temporal speckle fading
speckle_time_on: true
speckle_time_sigma: 0.15
speckle_time_tau_frames: 30
# Nonlinear multi- proxies
xgm_on: true
xgm_coeff: 0.2
xpm_on: true
xpm_coeff: 0.12
fwm_on: true
fwm_coeff: 0.08
# Back-reflection spikes
reflection_event_db: 28.0
reflection_prob: 0.08
# Polarization scrambler
pol_scrambler_on: true
pol_scramble_every_frames: 20



-----------------------

.\configs\packs\overlays\dwdm_adjacent_-25db.yaml
crosstalk_db: -25.0
dwdm_passband_ripple_db: 1.2



-----------------------

.\configs\packs\overlays\optics_harsher_nonlinear_ultra.yaml
# Ultra-harsh nonlinear optics overlay
transmittance: 0.6
ins_loss_db_sigma: 0.7
pdl_db: 0.7
pdl_step_rad: 0.1
ct_model: neighbor
ct_neighbor_db: -22.0
ct_diag_db: -25.0
crosstalk_db: -22.0
dwdm_passband_ripple_db: 1.5
speckle_time_on: true
speckle_time_sigma: 0.2
speckle_time_tau_frames: 20
xgm_on: true
xgm_coeff: 0.3
xpm_on: true
xpm_coeff: 0.2
fwm_on: true
fwm_coeff: 0.12
reflection_event_db: 25.0
reflection_prob: 0.12
pol_scrambler_on: true
pol_scramble_every_frames: 10



-----------------------

.\configs\packs\overlays\thermal_ramp_2cph.yaml
drift_scale: 0.5
corner_hz: 0.001



-----------------------

.\configs\packs\overlays\emitter_cband_power_5mw.yaml
power_mw_per_ch: 5.0



-----------------------

.\configs\packs\overlays\emitter_cband_power_40mw.yaml
power_mw_per_ch: 40.0



-----------------------

.\configs\packs\overlays\comparator_metastable_strong.yaml
metastable_on: true
metastable_width_mV: 0.4
metastable_flip_prob: 0.15



-----------------------

.\configs\packs\overlays\clock_jitter_30ps.yaml
jitter_ps_rms: 30.0



-----------------------

.\configs\packs\overlays\connector_apc.yaml
reflection_event_db: 40.0
reflection_prob: 0.01




-----------------------

.\configs\packs\overlays\connector_pc.yaml
reflection_event_db: 30.0
reflection_prob: 0.05




-----------------------

.\configs\packs\overlays\fiber_pm.yaml
pdl_db: 0.2
pdl_step_rad: 0.01




-----------------------

.\configs\packs\overlays\fiber_smf.yaml
pdl_db: 0.6
pdl_step_rad: 0.08




-----------------------

.\configs\packs\overlays\emitter_cband_power_60mw.yaml
power_mw_per_ch: 60.0







-----------------------

.\configs\packs\overlays\tia_bw_3000mhz_slew.yaml
bw_mhz: 3000.0
bw2_mhz: 0.0
slew_v_per_us: 2000.0








-----------------------

.\configs\packs\overlays\soa_fast_tau.yaml
amp_on: true
amp_gain_db: 8.0
amp_ase_sigma: 0.05
memory_tau_frames: 0.2








-----------------------

.\configs\packs\overlays\emitter_dual_wdm.yaml
# Dual-wavelength emitter overlay for 1550 nm WDM sweep
channels: 16
wavelength_nm: 1550.0
wavelengths_nm:
  - 1549.2
  - 1550.8
power_mw_per_ch: 6.5
extinction_db: 10.0
rin_dbhz: -120.0
modulation_mode: intensity
pushpull_alpha: 0.0
rise_fall_ns_10_90: 12.0
temp_coeff_pct_per_C: 0.35



-----------------------

.\configs\packs\overlays\optics_mode_mix_dual.yaml
# Mode-mixing and quantized VOAs for dual-wavelength tile
voa_bits: 6
soa_pattern_alpha: 0.15
dwdm_slope_db_per_nm: 4.0
mode_mix_matrix:
  - [0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
  - [0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
  - [0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00]
  - [0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00]
  - [0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00]
  - [0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00]
  - [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00]
  - [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25]
  - [0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
  - [0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00]
  - [0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00, 0.00]
  - [0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00, 0.00]
  - [0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00, 0.00]
  - [0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00, 0.00]
  - [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75, 0.00]
  - [0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.25, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.00, 0.75]





-----------------------

.\configs\packs\overlays\emitter_quad_wdm.yaml
# Quad-wavelength emitter overlay for WDM stress
channels: 16
wavelength_nm: 1550.0
wavelengths_nm:
  - 1548.8
  - 1549.6
  - 1550.4
  - 1551.2
power_mw_per_ch: 7.0
extinction_db: 9.5
rin_dbhz: -118.0
modulation_mode: intensity
pushpull_alpha: 0.0
rise_fall_ns_10_90: 12.0
temp_coeff_pct_per_C: 0.35



-----------------------

.\configs\packs\overlays\optics_mode_mix_quad.yaml
# Quad-mode coupling optics for WDM tile
voa_bits: 7
soa_pattern_alpha: 0.2
dwdm_slope_db_per_nm: 5.0
mode_mix_matrix:
  - [0.6500, 0.0667, 0.0667, 0.0667, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]
  - [0.0667, 0.6500, 0.0667, 0.0667, 0.0000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]
  - [0.0667, 0.0667, 0.6500, 0.0667, 0.0000, 0.0000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]
  - [0.0667, 0.0667, 0.0667, 0.6500, 0.0000, 0.0000, 0.0000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000]
  - [0.0000, 0.0000, 0.0000, 0.0000, 0.6500, 0.0667, 0.0667, 0.0667, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000]
  - [0.0000, 0.0000, 0.0000, 0.0000, 0.0667, 0.6500, 0.0667, 0.0667, 0.0000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000]
  - [0.0000, 0.0000, 0.0000, 0.0000, 0.0667, 0.0667, 0.6500, 0.0667, 0.0000, 0.0000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000]
  - [0.0000, 0.0000, 0.0000, 0.0000, 0.0667, 0.0667, 0.0667, 0.6500, 0.0000, 0.0000, 0.0000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500]
  - [0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.6500, 0.0667, 0.0667, 0.0667, 0.1000, 0.0000, 0.0000, 0.0000]
  - [0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0667, 0.6500, 0.0667, 0.0667, 0.0000, 0.1000, 0.0000, 0.0000]
  - [0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0667, 0.0667, 0.6500, 0.0667, 0.0000, 0.0000, 0.1000, 0.0000]
  - [0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0667, 0.0667, 0.0667, 0.6500, 0.0000, 0.0000, 0.0000, 0.1000]
  - [0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.6500, 0.0667, 0.0667, 0.0667]
  - [0.0000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0667, 0.6500, 0.0667, 0.0667]
  - [0.0000, 0.0000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0667, 0.0667, 0.6500, 0.0667]
  - [0.0000, 0.0000, 0.0000, 0.1000, 0.0000, 0.0000, 0.0000, 0.0500, 0.0000, 0.0000, 0.0000, 0.0000, 0.0667, 0.0667, 0.0667, 0.6500]




-----------------------

.\configs\packs\overlays\optics_pathb_highsat.yaml
ct_model: neighbor
ct_neighbor_db: -60.0
ct_diag_db: -63.0
transmittance: 0.95
psf_kernel: "lorentzian:w=1.2"
signal_scale: 1.45
w_plus_contrast: 0.94
w_minus_contrast: 0.94
stray_floor_db: -50.0
amp_on: true
amp_gain_db: 8.0
amp_ase_sigma: 0.004
sat_abs_on: true
sat_I_sat: 0.6
sat_alpha: 0.85



-----------------------

.\configs\packs\overlays\emitter_pathb_highpower.yaml
# High-power low-RIN emitter for Path B sweeps
wavelength_nm: 1550.0
power_mw_per_ch: 18.0
extinction_db: 20.0
rin_dbhz: -150.0
linewidth_hz: 5.0e6
rise_fall_ns_10_90: 6.0
temp_coeff_pct_per_C: 0.15
power_sigma_pct: 2.0
modulation_mode: pushpull
pushpull_alpha: 0.9



-----------------------

.\configs\packs\overlays\optics_pathb_highgain.yaml
# High-saturation SA + amplifier for Path B
ct_model: neighbor
ct_neighbor_db: -60.0
ct_diag_db: -63.0
transmittance: 0.95
psf_kernel: "lorentzian:w=1.2"
signal_scale: 1.5
w_plus_contrast: 0.95
w_minus_contrast: 0.95
stray_floor_db: -60.0
amp_on: true
amp_gain_db: 10.0
amp_ase_sigma: 0.003
sat_abs_on: true
sat_I_sat: 0.4
sat_alpha: 0.9
memory_tau_frames: 2.0



-----------------------

.\configs\packs\overlays\comparator_pathb_lowth.yaml
vth_mV: 0.0
hysteresis_mV: 0.2
input_noise_mV_rms: 0.05
vth_sigma_mV: 0.02
prop_delay_ns: 0.8
saturate_levels: true



-----------------------

.\configs\packs\overlays\emitter_pathb_premium.yaml
channels: 8
wavelength_nm: 1550.0
power_mw_per_ch: 25.0
extinction_db: 25.0
rin_dbhz: -160.0
linewidth_hz: 1.0e6
rise_fall_ns_10_90: 4.0
temp_coeff_pct_per_C: 0.1
power_sigma_pct: 1.0
modulation_mode: pushpull
pushpull_alpha: 0.95




-----------------------

.\configs\packs\overlays\optics_pathb_premium.yaml
ct_model: neighbor
ct_neighbor_db: -65.0
ct_diag_db: -68.0
transmittance: 0.98
psf_kernel: "lorentzian:w=1.0"
signal_scale: 1.6
w_plus_contrast: 0.96
w_minus_contrast: 0.96
stray_floor_db: -70.0
amp_on: true
amp_gain_db: 12.0
amp_ase_sigma: 0.002
sat_abs_on: true
sat_I_sat: 0.3
sat_alpha: 0.95
memory_tau_frames: 1.0



-----------------------

.\configs\packs\overlays\tia_pathb_premium.yaml
tia_transimpedance_kohm: 20.0
bw_mhz: 200.0
in_noise_pA_rthz: 2.0
peaking_q: 0.5
slew_v_per_us: 1000.0
adc_bits: 14
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.0
gain_sigma_pct: 0.5



-----------------------

.\configs\packs\overlays\comparator_pathb_premium.yaml
vth_mV: 0.0
hysteresis_mV: 0.1
input_noise_mV_rms: 0.02
vth_sigma_mV: 0.01
prop_delay_ns: 0.5
prop_jitter_ps_rms: 5.0
saturate_levels: true



-----------------------

.\configs\packs\overlays\optics_pathb_extreme.yaml
ct_model: neighbor
ct_neighbor_db: -80.0
ct_diag_db: -85.0
transmittance: 0.99
psf_kernel: "lorentzian:w=0.8"
signal_scale: 2.0
w_plus_contrast: 0.98
w_minus_contrast: 0.98
stray_floor_db: -80.0
amp_on: true
amp_gain_db: 15.0
amp_ase_sigma: 0.0
sat_abs_on: true
sat_I_sat: 0.1
sat_alpha: 0.99
memory_tau_frames: 0.5



-----------------------

.\configs\packs\overlays\sensor_pathb_balanced.yaml
responsivity_A_per_W: 1.0
dark_current_nA: 0.1
cap_pF: 0.2




-----------------------

.\configs\packs\overlays\optics_pathb_soa_mzi.yaml
channels: 8
# 8-ch SOA + MZI limiter configuration
transmittance: 0.95
ct_model: neighbor
ct_neighbor_db: -60.0
ct_diag_db: -63.0
psf_kernel: "lorentzian:w=1.0"
signal_scale: 1.5
w_plus_contrast: 0.96
w_minus_contrast: 0.96
stray_floor_db: -70.0
amp_on: false
sat_abs_on: false
soa_on: true
soa_small_signal_gain_db: 13.0
soa_psat_mw: 8.0
soa_noise_figure_db: 5.5
soa_tau_ns: 0.4
soa_alpha: 4.0
mzi_on: true
mzi_gain: 1.2
mzi_sat_mw: 3.0
mzi_hysteresis_mw: 0.02
mzi_bias_step: 0.015
mzi_bias_leak: 0.005
mzi_bias_target_mw: 0.0
voa_bits: 7
soa_pattern_alpha: 0.1
mode_mix_matrix:
  - [0.95, 0.02, 0.01, 0.01, 0.01, 0.0, 0.0, 0.0]
  - [0.02, 0.95, 0.02, 0.01, 0.0, 0.01, 0.0, 0.0]
  - [0.01, 0.02, 0.95, 0.02, 0.0, 0.0, 0.01, 0.0]
  - [0.01, 0.01, 0.02, 0.95, 0.0, 0.0, 0.0, 0.01]
  - [0.01, 0.0, 0.0, 0.0, 0.95, 0.02, 0.01, 0.01]
  - [0.0, 0.01, 0.0, 0.0, 0.02, 0.95, 0.02, 0.01]
  - [0.0, 0.0, 0.01, 0.0, 0.01, 0.02, 0.95, 0.02]
  - [0.0, 0.0, 0.0, 0.01, 0.01, 0.01, 0.02, 0.95]

servo_on: true
servo_kp: 0.02
servo_ki: 0.001
servo_ref_mw: 0.0
servo_leak: 0.01
servo_max_bias_mw: 4.0



-----------------------

.\configs\packs\overlays\optics_pathb_soa_mzi_clamp.yaml
channels: 8
transmittance: 0.92
ct_model: neighbor
ct_neighbor_db: -62.0
ct_diag_db: -65.0
psf_kernel: "lorentzian:w=0.8"
signal_scale: 2.0
w_plus_contrast: 0.97
w_minus_contrast: 0.97
stray_floor_db: -72.0
amp_on: false
sat_abs_on: false
soa_on: true
soa_small_signal_gain_db: 18.0
soa_psat_mw: 6.0
soa_noise_figure_db: 5.0
soa_tau_ns: 0.8
soa_alpha: 4.0
soa_pattern_alpha: 0.2
mzi_on: true
mzi_gain: 2.6
mzi_sat_mw: 2.2
mzi_hysteresis_mw: 0.05
mzi_bias_step: 0.05
mzi_bias_leak: 0.001
mzi_bias_target_mw: 0.0
voa_bits: 8
mode_mix_matrix:
  - [0.96, 0.015, 0.01, 0.01, 0.0, 0.0, 0.0, 0.0]
  - [0.015, 0.96, 0.015, 0.01, 0.0, 0.0, 0.0, 0.0]
  - [0.01, 0.015, 0.96, 0.015, 0.0, 0.0, 0.0, 0.0]
  - [0.01, 0.01, 0.015, 0.96, 0.0, 0.0, 0.0, 0.0]
  - [0.0, 0.0, 0.0, 0.0, 0.96, 0.015, 0.01, 0.01]
  - [0.0, 0.0, 0.0, 0.0, 0.015, 0.96, 0.015, 0.01]
  - [0.0, 0.0, 0.0, 0.0, 0.01, 0.015, 0.96, 0.015]
  - [0.0, 0.0, 0.0, 0.0, 0.01, 0.01, 0.015, 0.96]

servo_on: true
servo_kp: 0.03
servo_ki: 0.0015
servo_ref_mw: 0.0
servo_leak: 0.01
servo_max_bias_mw: 4.0



-----------------------

.\configs\packs\overlays\optics_pathb_soa_mzi_clean.yaml
channels: 8
transmittance: 0.95
ct_model: neighbor
ct_neighbor_db: -60.0
ct_diag_db: -63.0
psf_kernel: "lorentzian:w=1.0"
signal_scale: 1.0
w_plus_contrast: 0.98
w_minus_contrast: 0.98
stray_floor_db: -75.0
amp_on: false
sat_abs_on: false
soa_on: true
soa_small_signal_gain_db: 16.0
soa_psat_mw: 8.0
soa_noise_figure_db: 5.0
soa_tau_ns: 0.6
soa_alpha: 4.0
soa_pattern_alpha: 0.05
mzi_on: true
mzi_gain: 2.0
mzi_sat_mw: 3.0
mzi_hysteresis_mw: 0.02
mzi_bias_step: 0.02
mzi_bias_leak: 0.002
mzi_bias_target_mw: 0.0
voa_bits: 9
mode_mix_matrix: null

servo_on: true
servo_kp: 0.02
servo_ki: 0.0005
servo_ref_mw: 0.0
servo_leak: 0.01
servo_max_bias_mw: 3.5



-----------------------

.\configs\packs\overlays\optics_pathb_soa_sa.yaml
channels: 8
transmittance: 0.92
ct_model: neighbor
ct_neighbor_db: -65.0
ct_diag_db: -68.0
psf_kernel: "lorentzian:w=0.6"
signal_scale: 2.8
w_plus_contrast: 0.99
w_minus_contrast: 0.99
stray_floor_db: -80.0
amp_on: false
sat_abs_on: true
sat_I_sat: 0.12
sat_alpha: 1.2
soa_on: true
soa_small_signal_gain_db: 24.0
soa_psat_mw: 2.0
soa_noise_figure_db: 4.5
soa_tau_ns: 0.5
soa_alpha: 4.0
soa_pattern_alpha: 0.02
mzi_on: true
mzi_gain: 3.5
mzi_sat_mw: 1.2
mzi_hysteresis_mw: 0.06
mzi_bias_step: 0.06
mzi_bias_leak: 0.004
mzi_bias_target_mw: 0.0
servo_on: true
servo_kp: 0.12
servo_ki: 0.002
servo_alpha: 0.12
servo_ref_mw: 0.0
servo_leak: 0.01
servo_max_bias_mw: 2.5
hard_clip_on: true
hard_clip_sat_mw: 0.06
post_clip_on: true
post_clip_sat_mw: 0.04
voa_bits: 10
mode_mix_matrix: null



-----------------------

.\configs\packs\overlays\optics_pathb_soa_sa_ch1.yaml
channels: 1
transmittance: 0.95
ct_model: global
crosstalk_db: -80.0
signal_scale: 2.5
w_plus_contrast: 0.99
w_minus_contrast: 0.99
stray_floor_db: -80.0
amp_on: false
sat_abs_on: true
sat_I_sat: 0.25
sat_alpha: 0.95
soa_on: true
soa_small_signal_gain_db: 20.0
soa_psat_mw: 2.0
soa_noise_figure_db: 4.5
soa_tau_ns: 0.5
soa_alpha: 4.0
soa_pattern_alpha: 0.02
mzi_on: true
mzi_gain: 3.0
mzi_sat_mw: 1.5
mzi_hysteresis_mw: 0.05
mzi_bias_step: 0.05
mzi_bias_leak: 0.003
mzi_bias_target_mw: 0.0
servo_on: true
servo_kp: 0.1
servo_ki: 0.001
servo_alpha: 0.15
servo_ref_mw: 0.0
servo_leak: 0.01
servo_max_bias_mw: 2.0
voa_bits: 10
mode_mix_matrix: null



-----------------------

.\configs\packs\overlays\emitter_pathb_ch1.yaml
channels: 1
wavelength_nm: 1550.0
power_mw_per_ch: 18.0
extinction_db: 20.0
rin_dbhz: -150.0
linewidth_hz: 1000000.0
wav_drift_nm_per_C: 0.05
rise_fall_ns_10_90: 3.0
temp_coeff_pct_per_C: 0.05
power_sigma_pct: 0.5
modulation_mode: pushpull
pushpull_alpha: 0.98



-----------------------

.\configs\packs\overlays\comparator_pathb_ideal.yaml
vth_mV: 0.0
hysteresis_mV: 0.0
input_noise_mV_rms: 0.0
prop_delay_ns: 0.5
prop_jitter_ps_rms: 0.0
saturate_levels: true



-----------------------

.\configs\packs\overlays\tia_pathb_ideal.yaml
tia_transimpedance_kohm: 40.0
bw_mhz: 500.0
in_noise_pA_rthz: 0.0
peaking_q: 0.7
slew_v_per_us: 2000.0
adc_bits: 16
adc_fullscale_v: 1.0
adc_read_noise_mV_rms: 0.0
gain_sigma_pct: 0.0



-----------------------

.\configs\packs\overlays\sensor_pathb_ideal.yaml
responsivity_A_per_W: 1.2
dark_current_nA: 0.01
cap_pF: 0.05



-----------------------

.\configs\packs\overlays\optics_voa_2db.yaml
voa_post_db: 2.0



-----------------------

.\configs\packs\overlays\optics_voa_4db.yaml
voa_post_db: 4.0



-----------------------

.\configs\packs\overlays\optics_voa_6db.yaml
voa_post_db: 6.0



-----------------------

.\configs\packs\overlays\tuned_comparator_pathb.yaml
# Tuned comparator overlay for ~0.065 BER Path A recipe
vth_mV: 5.0
hysteresis_mV: 0.75
input_noise_mV_rms: 0.40
drift_mV_per_C: 0.05
prop_delay_ns: 1.25
saturate_levels: true
vth_sigma_mV: 0.2

vth_mV: 80.0
hysteresis_mV: 5.0
input_noise_mV_rms: 0.3



-----------------------

.\configs\packs\overlays\tuned_comparator_pathb20.yaml
# Tuned comparator overlay for ~0.065 BER Path A recipe
vth_mV: 5.0
hysteresis_mV: 0.75
input_noise_mV_rms: 0.40
drift_mV_per_C: 0.05
prop_delay_ns: 1.25
saturate_levels: true
vth_sigma_mV: 0.2

vth_mV: 80.0
hysteresis_mV: 5.0
input_noise_mV_rms: 0.3
vth_mV: 20.0
hysteresis_mV: 3.0
input_noise_mV_rms: 0.05



-----------------------

.\configs\packs\overlays\tuned_comparator_pathb10.yaml
# Tuned comparator overlay for ~0.065 BER Path A recipe
vth_mV: 5.0
hysteresis_mV: 0.75
input_noise_mV_rms: 0.40
drift_mV_per_C: 0.05
prop_delay_ns: 1.25
saturate_levels: true
vth_sigma_mV: 0.2

vth_mV: 80.0
hysteresis_mV: 5.0
input_noise_mV_rms: 0.3
vth_mV: 20.0
hysteresis_mV: 3.0
vth_mV: 10.0
hysteresis_mV: 2.0



-----------------------

.\configs\scenarios\basic_typ.yaml
name: basic_typ
channels: 16
trials: 200
emitter_pack: configs/packs/emitter_typ.yaml
optics_pack: configs/packs/optics_typ.yaml
sensor_pack: configs/packs/sensor_typ.yaml
tia_pack: configs/packs/tia_typ.yaml
comparator_pack: configs/packs/comparator_typ.yaml
clock_pack: configs/packs/clock_typ.yaml
thermal_pack: configs/packs/thermal_typ.yaml
camera_pack: configs/packs/camera_typ.yaml



-----------------------

.\configs\scenarios\basic_optimistic.yaml
name: basic_optimistic
channels: 16
trials: 200
emitter_pack: configs/packs/emitter_optimistic.yaml
optics_pack: configs/packs/optics_optimistic.yaml
sensor_pack: configs/packs/sensor_typ.yaml
tia_pack: configs/packs/tia_typ.yaml
comparator_pack: configs/packs/comparator_typ.yaml
clock_pack: configs/packs/clock_typ.yaml
thermal_pack: configs/packs/thermal_typ.yaml



-----------------------

.\configs\scenarios\basic_pessimistic.yaml
name: basic_pessimistic
channels: 16
trials: 200
emitter_pack: configs/packs/emitter_pessimistic.yaml
optics_pack: configs/packs/optics_pessimistic.yaml
sensor_pack: configs/packs/sensor_typ.yaml
tia_pack: configs/packs/tia_typ.yaml
comparator_pack: configs/packs/comparator_typ.yaml
clock_pack: configs/packs/clock_typ.yaml
thermal_pack: configs/packs/thermal_typ.yaml



-----------------------

.\configs\scenarios\pd_only.yaml
name: pd_only
channels: 4
trials: 5
emitter_pack: configs/packs/emitter_typ.yaml
optics_pack: configs/packs/optics_typ.yaml
sensor_pack: configs/packs/sensor_typ.yaml
tia_pack: configs/packs/tia_typ.yaml
comparator_pack: configs/packs/comparator_typ.yaml
clock_pack: configs/packs/clock_typ.yaml



-----------------------

.\configs\scenarios\tdm_mvp_16ch_strongsa_k8.yaml
trials: 240
channels: 16
seed: 6001
temp_C: 25.0
emitter_pack:
  path: configs/packs/tmp_lowcost_emitter_boost.yaml
optics_pack:
  path: configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml
sensor_pack:
  path: configs/packs/overlays/receiver_ingaas_typ.yaml
tia_pack:
  path: configs/packs/overlays/tia_stage_b2_low_noise.yaml
comparator_pack:
  path: configs/packs/overlays/tuned_comparator.yaml
clock_pack:
  path: configs/packs/overlays/clock_jitter_20ps.yaml



-----------------------

.\configs\scenarios\tdm_16_lightsa_k4.yaml
trials: 240
channels: 16
seed: 7001
temp_C: 25.0
emitter_pack:
  path: configs/packs/tmp_lowcost_emitter_boost.yaml
optics_pack:
  path: configs/packs/tmp_codex_optics_medium_voa2_lightSA.yaml
sensor_pack:
  path: configs/packs/overlays/receiver_ingaas_typ.yaml
tia_pack:
  path: configs/packs/overlays/tia_stage_b2_low_noise.yaml
comparator_pack:
  path: configs/packs/overlays/tuned_comparator.yaml
clock_pack:
  path: configs/packs/overlays/clock_jitter_20ps.yaml




-----------------------

.\configs\scenarios\tdm_32_strongsa_k8.yaml
trials: 240
channels: 32
seed: 8001
temp_C: 25.0
emitter_pack:
  path: configs/packs/tmp_lowcost_emitter_boost.yaml
optics_pack:
  path: configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml
sensor_pack:
  path: configs/packs/overlays/receiver_ingaas_typ.yaml
tia_pack:
  path: configs/packs/overlays/tia_stage_b2_low_noise.yaml
comparator_pack:
  path: configs/packs/overlays/tuned_comparator.yaml
clock_pack:
  path: configs/packs/overlays/clock_jitter_20ps.yaml




-----------------------

.\configs\scenarios\tdm_32_lightsa_k8.yaml
trials: 240
channels: 32
seed: 9001
temp_C: 25.0
emitter_pack:
  path: configs/packs/tmp_lowcost_emitter_boost.yaml
optics_pack:
  path: configs/packs/tmp_codex_optics_medium_voa2_lightSA.yaml
sensor_pack:
  path: configs/packs/overlays/receiver_ingaas_typ.yaml
tia_pack:
  path: configs/packs/overlays/tia_stage_b2_low_noise.yaml
comparator_pack:
  path: configs/packs/overlays/tuned_comparator.yaml
clock_pack:
  path: configs/packs/overlays/clock_jitter_20ps.yaml




-----------------------

.\configs\presets\upper_bound_path_a_digital.json
{
  "runs": [
    {
      "trials": [300],
      "seed": [123],
      "windows": [28, 32],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "avg_frames": ["1", "2", "4"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["8", "12"],
      "adaptive_margin_mV": ["0.8", "1.0"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml",
          "configs/packs/vendors/emitters/thorlabs_L850P200_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml",
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-20_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/hamamatsu_S5973_typ.yaml",
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/vendors/tias/femto_DLPCA-200_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}





-----------------------

.\configs\presets\practicalization_path_a_digital.json
{
  "runs": [
    {
      "trials": [300],
      "seed": [123],
      "windows": [28, 26, 24],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["8", "6"],
      "adaptive_margin_mV": ["0.8", "1.0"],
      "avg_frames": ["1", "2"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/vendors/tias/femto_DLPCA-200_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}

{
  "runs": [
    {
      "trials": [300],
      "seed": [123],
      "windows": ["best", "best-2", "best-4"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["0"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["best", "best-2"],
      "adaptive_margin_mV": ["best", "best+0.2"],
      "packs": {
        "emitter_packs": ["configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"],
        "optics_packs": ["configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"],
        "sensor_packs": ["configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"],
        "tia_packs": ["configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"],
        "comparator_packs": ["configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}





-----------------------

.\configs\presets\cold_input_lift.json
{
  "runs": [
    {
      "trials": [300],
      "seed": [123],
      "windows": ["best", "best+2", "best+4"],
      "inputs": ["cold"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["0"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["best", "best+2"],
      "adaptive_margin_mV": ["best", "best+0.2"],
      "packs": {
        "emitter_packs": ["configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"],
        "optics_packs": ["configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"],
        "sensor_packs": ["configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"],
        "tia_packs": ["configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"],
        "comparator_packs": ["configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}





-----------------------

.\configs\presets\path_b_analog_viability.json
{
  "runs": [
    {
      "trials": [300],
      "seed": [123],
      "windows": [20, 24, 28],
      "inputs": ["digital"],
      "outputs": ["path_b_analog"],
      "path_b_analog_depths": [2, 3, 4, 5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["0"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["8"],
      "adaptive_margin_mV": ["0.8"],
      "packs": {
        "emitter_packs": ["configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml",
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-20_typ.yaml"
        ],
        "sensor_packs": ["configs/packs/vendors/sensors/hamamatsu_S5973_typ.yaml"],
        "tia_packs": ["configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"],
        "comparator_packs": ["configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}





-----------------------

.\configs\presets\hold_below_0p1_path_a.json
{
  "runs": [
    {
      "trials": [50],
      "seed": [123],
      "windows": [26, 28, 32],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["6", "8"],
      "adaptive_margin_mV": ["0.8", "1.0"],
      "avg_frames": ["1", "2"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    },
    {
      "trials": [300],
      "seed": [123],
      "windows": [26, 28, 32],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["6", "8"],
      "adaptive_margin_mV": ["0.8", "1.0"],
      "avg_frames": ["1", "2"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/hamamatsu_S5973_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    },
    {
      "trials": [300],
      "seed": [123],
      "windows": [28, 32],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["6", "8"],
      "adaptive_margin_mV": ["0.8", "1.0"],
      "avg_frames": ["1", "2"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/femto_DLPCA-200_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    },
    {
      "trials": [300],
      "seed": [123],
      "windows": [28, 30, 32],
      "inputs": ["cold"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["8", "12"],
      "adaptive_margin_mV": ["1.0", "1.2"],
      "avg_frames": ["1", "2"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}





-----------------------

.\configs\presets\optics_angle_fast_path_a.json
{
  "runs": [
    {
      "trials": [50],
      "seed": [123],
      "windows": [26, 28, 32],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["6", "8"],
      "adaptive_margin_mV": ["0.8", "1.0"],
      "avg_frames": ["1", "2"],
      "fast": ["1"],
      "no_sweeps": ["1"],
      "no_cal": ["1"],
      "no_drift": ["1"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml",
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-10_typ.yaml",
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-15_typ.yaml",
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-20_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p05_backoff_and_alt_chain.json
{
  "runs": [
    {
      "trials": [200],
      "seed": [123],
      "windows": [26, 28],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "apply_autotuned_params": ["1"],
      "autotune_budget": ["60"],
      "autotune_trials": ["120"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["8"],
      "adaptive_margin_mV": ["0.8"],
      "avg_frames": ["1", "2"],
      "use_avg_frames_for_path_a": ["1"],
      "lock_optics_ct": ["1"],
      "fast": ["1"],
      "no_sweeps": ["1"],
      "no_cal": ["1"],
      "no_drift": ["1"],
      "soft_thresh": ["0", "1"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml",
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-3_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    },
    {
      "trials": [200],
      "seed": [123],
      "windows": [28, 30, 32],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "apply_autotuned_params": ["1"],
      "autotune_budget": ["60"],
      "autotune_trials": ["120"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["8"],
      "adaptive_margin_mV": ["0.8"],
      "avg_frames": ["1", "2"],
      "use_avg_frames_for_path_a": ["1"],
      "lock_optics_ct": ["1"],
      "fast": ["1"],
      "no_sweeps": ["1"],
      "no_cal": ["1"],
      "no_drift": ["1"],
      "soft_thresh": ["0", "1"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml",
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-3_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/hamamatsu_S5973_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/femto_DLPCA-200_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p065_tuned_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["16", "18", "20", "22", "24"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["1"],
      "autotune": ["1"],
      "apply_autotuned_params": ["1"],
      "use_autotuned_as_primary": ["1"],
      "autotune_budget": ["40"],
      "autotune_trials": ["100"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],
      "lock_optics_ct": ["1"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "adaptive_max_frames": ["12"],
      "adaptive_margin_mV": ["0.8"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],

      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["48"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p065_tuned_no_autotune_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["1"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],
      "use_autotuned_as_primary": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["16"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p05_probe_path_a.json
{
  "runs": [
    {
      "trials": [120],
      "seed": [123],
      "windows": [26, 28, 30],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": [5],
      "vote3": ["1"],
      "autotune": ["1"],
      "apply_autotuned_params": ["1"],
      "autotune_budget": ["40"],
      "autotune_trials": ["100"],
      "sensitivity": ["0"],
      "neighbor_ct": ["1"],
      "apply_calibration": ["1"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["8", "12"],
      "adaptive_margin_mV": ["0.9", "1.2"],
      "avg_frames": ["1", "2", "4"],
      "lockin": ["0", "1"],
      "chop": ["0", "1"],
      "use_avg_frames_for_path_a": ["1"],
      "soft_thresh": ["0", "1"],
      "lock_optics_ct": ["1"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],
      "fast": ["1"],
      "no_sweeps": ["1"],
      "no_cal": ["1"],
      "no_drift": ["1"],
      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml",
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-3_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml",
          "configs/packs/vendors/sensors/hamamatsu_S5973_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/vendors/tias/femto_DLPCA-200_typ.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p06_comp_sweep_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["1"],
      "autotune": ["1"],
      "apply_autotuned_params": ["1"],
      "use_autotuned_as_primary": ["1"],
      "autotune_budget": ["40"],
      "autotune_trials": ["100"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],
      "lock_optics_ct": ["1"],
      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "normalize_dv": ["0"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["24"],

      "packs": {
        "emitter_packs": ["configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"],
        "optics_packs": ["configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"],
        "sensor_packs": ["configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"],
        "tia_packs": ["configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml",
          "configs/packs/overlays/comparator_sweep.yaml"
        ],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p06_tia_sweep_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["1"],
      "autotune": ["1"],
      "apply_autotuned_params": ["1"],
      "use_autotuned_as_primary": ["1"],
      "autotune_budget": ["40"],
      "autotune_trials": ["100"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],
      "lock_optics_ct": ["1"],
      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "normalize_dv": ["0"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["24"],

      "packs": {
        "emitter_packs": ["configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"],
        "optics_packs": ["configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"],
        "sensor_packs": ["configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tia_sweep.yaml"
        ],
        "comparator_packs": ["configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p06_optics_3deg_vs_5deg_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["1"],
      "autotune": ["1"],
      "apply_autotuned_params": ["1"],
      "use_autotuned_as_primary": ["1"],
      "autotune_budget": ["40"],
      "autotune_trials": ["100"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],
      "lock_optics_ct": ["1"],
      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "normalize_dv": ["0"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["24"],

      "packs": {
        "emitter_packs": ["configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml",
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-3_typ.yaml"
        ],
        "sensor_packs": ["configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"],
        "tia_packs": ["configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"],
        "comparator_packs": ["configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"],
        "camera_packs": [""],
        "clock_packs": ["configs/packs/clock_typ.yaml"],
        "thermal_packs": ["configs/packs/thermal_typ.yaml"]
      }
    }
  ]
}





-----------------------

.\configs\presets\zero_push_calibration_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["1"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["1"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["16"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\zero_push_adaptive_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["1"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["1"],
      "adaptive_max_frames": ["2", "3"],
      "adaptive_margin_mV": ["0.8"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["16"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\zero_push_avg_frames_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["1"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["2", "3"],
      "use_avg_frames_for_path_a": ["1"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["16"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\zero_push_vote5_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["0"],
      "repeat": ["5"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["18"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\zero_push_20ns_power_boost_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["20"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "vote3": ["1"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["6"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml",
          "configs/packs/overlays/tuned_emitter_boost.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\zero_push_repeat5_permute_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["repeat"],
      "repeat": ["5"],
      "permute_repeats": ["1"],
      "permute_scheme": ["random"],

      "vote3": ["0"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["18"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\zero_push_replicate2_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["replicate2"],

      "vote3": ["0"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["18"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\zero_push_replicate16_permute_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["replicate"],
      "repeat": ["16"],
      "permute_repeats": ["1"],
      "permute_scheme": ["random"],

      "vote3": ["0"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["18"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\zero_push_phys2x_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["phys2x"],

      "vote3": ["0"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["18"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p065_tuned_32ch_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["auto"],
      "channels": ["32"],

      "vote3": ["1"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["18"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p065_tuned_64ch_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["auto"],
      "channels": ["64"],

      "vote3": ["1"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["18"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\robust_masked_64ch_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["14", "16", "18", "20"],
      "channels": ["64"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["replicate"],
      "repeat": ["8"],
      "permute_repeats": ["1"],
      "permute_scheme": ["random"],

      "mask_bad_channels": ["1", "2"],
      "calib_mask_trials": ["200"],

      "vote3": ["1"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["0"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["0"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["1"],
      "cap": ["24"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p065_tuned_masked_path_a.json
{
  "runs": [
    {
      "trials": ["200"],
      "seed": ["123"],
      "windows": ["18", "20", "30"],
      "channels": ["16"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["repeat"],
      "repeat": ["11"],
      "permute_repeats": ["1"],
      "permute_scheme": ["cyclic"],

      "mask_bad_channels": ["8", "10", "15"],
      "mask_bad_frac": ["0.0"],
      "calib_mask_trials": ["300"],

      "vote3": ["1"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["1"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["1"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["0"],
      "cap": ["12"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml",
          "configs/packs/overlays/tuned_emitter_boost.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p065_mask_sweep_path_a.json
{
  "runs": [
    {
      "trials": ["400"],
      "seed": ["321"],
      "windows": ["20"],
      "channels": ["16"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["repeat"],
      "repeat": ["11"],
      "permute_repeats": ["1"],
      "permute_scheme": ["cyclic"],

      "mask_bad_channels": ["0", "2", "4", "6", "8", "10"],
      "calib_mask_trials": ["300"],

      "vote3": ["0"],
      "autotune": ["0"],
      "apply_autotuned_params": ["0"],

      "sensitivity": ["0"],
      "neighbor_ct": ["0"],

      "apply_calibration": ["1"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "use_avg_frames_for_path_a": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["1"],
      "normalize_eps_v": ["1e-6"],

      "fast": ["0"],
      "no_sweeps": ["1"],
      "no_cal": ["0"],
      "no_drift": ["1"],
      "light_output": ["0"],
      "cap": ["48"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p065_optics_3deg_path_a.json
{
  "runs": [
    {
      "trials": ["400"],
      "seed": ["321"],
      "windows": ["18", "20"],
      "channels": ["16"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["repeat"],
      "repeat": ["11"],
      "permute_repeats": ["1"],
      "permute_scheme": ["cyclic"],

      "mask_bad_channels": ["0", "4"],
      "calib_mask_trials": ["300"],

      "apply_calibration": ["1"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "soft_thresh": ["0"],
      "normalize_dv": ["1"],

      "no_sweeps": ["1"],
      "no_drift": ["1"],
      "light_output": ["0"],
      "cap": ["24"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-3_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p065_channels_16_32_64_path_a.json
{
  "runs": [
    {
      "trials": ["300"],
      "seed": ["321"],
      "windows": ["20"],
      "channels": ["16", "32", "64"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["repeat"],
      "repeat": ["11"],
      "permute_repeats": ["1"],
      "permute_scheme": ["cyclic"],

      "mask_bad_channels": ["0"],
      "apply_calibration": ["1"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "normalize_dv": ["1"],
      "no_sweeps": ["1"],
      "no_drift": ["1"],
      "light_output": ["0"],
      "cap": ["36"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p065_avg11_path_a.json
{
  "runs": [
    {
      "trials": ["400"],
      "seed": ["321"],
      "windows": ["20", "30"],
      "channels": ["16"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["avg"],
      "avg_frames": ["11"],
      "mask_bad_channels": ["0", "6"],
      "calib_mask_trials": ["300"],

      "apply_calibration": ["1"],
      "adaptive_input": ["0"],
      "soft_thresh": ["0"],
      "normalize_dv": ["1"],
      "normalize_eps_v": ["1e-6"],

      "no_sweeps": ["1"],
      "no_drift": ["1"],
      "light_output": ["0"],
      "cap": ["24"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}





-----------------------

.\configs\presets\sub_0p0625_majority_16_path_a.json
{
  "runs": [
    {
      "trials": ["400"],
      "seed": ["321"],
      "windows": ["20"],
      "channels": ["16"],
      "inputs": ["digital"],
      "outputs": ["path_a"],
      "path_b_analog_depths": ["0"],

      "classifier": ["repeat"],
      "repeat": ["11"],
      "permute_repeats": ["1"],
      "permute_scheme": ["cyclic"],

      "mask_bad_channels": ["0", "2", "4"],
      "calib_mask_trials": ["300"],

      "apply_calibration": ["1"],
      "adaptive_input": ["0"],
      "avg_frames": ["1"],
      "soft_thresh": ["0"],
      "normalize_dv": ["1"],

      "no_sweeps": ["1"],
      "no_drift": ["1"],
      "light_output": ["0"],
      "cap": ["24"],

      "packs": {
        "emitter_packs": [
          "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"
        ],
        "optics_packs": [
          "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml"
        ],
        "sensor_packs": [
          "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"
        ],
        "tia_packs": [
          "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
          "configs/packs/overlays/tuned_tia.yaml"
        ],
        "comparator_packs": [
          "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml"
        ],
        "camera_packs": [
          ""
        ],
        "clock_packs": [
          "configs/packs/clock_typ.yaml"
        ],
        "thermal_packs": [
          "configs/packs/thermal_typ.yaml"
        ]
      }
    }
  ]
}




-----------------------

.\configs\presets\mvp_single_pass_led.json
{
  "runs": [
    {
      "label": "mvp_single_pass_led",
      "cmd": [
        "--trials", "400",
        "--light-output",
        "--channels", "1",
        "--base-window-ns", "6.0",
        "--seed", "7001",
        "--classifier", "chop",
        "--chop",
        "--avg-frames", "2",
        "--gate-thresh-mV", "0.6",
        "--gate-extra-frames", "1",
        "--apply-calibration",
        "--mask-bad-frac", "0.0",
        "--no-adaptive-input",
        "--no-path-b",
        "--decoder-linear",
        "--decoder-samples", "200",
        "--use-decoder-for-path-a",
        "--normalize-dv"
      ],
      "packs": {
        "emitter_pack": "configs/packs/tmp_led_array.yaml",
        "optics_pack": "configs/packs/tmp_codex_optics_medium.yaml",
        "sensor_pack": "configs/packs/tmp_budget_sensor.yaml",
        "tia_pack": "configs/packs/tmp_budget_tia.yaml",
        "comparator_pack": "configs/packs/tmp_budget_comparator.yaml",
        "clock_pack": "configs/packs/tmp_budget_clock.yaml",
        "thermal_pack": "configs/packs/thermal_typ.yaml"
      }
    }
  ]
}



-----------------------

.\configs\presets\tile16_wdm_dual.json
{
  "runs": [
    {
      "label": "tile16_wdm_dual",
      "cmd": [
        "--trials", "400",
        "--light-output",
        "--channels", "16",
        "--base-window-ns", "6.0",
        "--seed", "7201",
        "--classifier", "chop",
        "--chop",
        "--avg-frames", "2",
        "--gate-thresh-mV", "0.6",
        "--gate-extra-frames", "1",
        "--apply-calibration",
        "--mask-bad-frac", "0.0625",
        "--no-adaptive-input",
        "--decoder-linear",
        "--decoder-samples", "200",
        "--use-decoder-for-path-a",
        "--normalize-dv"
      ],
      "packs": {
        "emitter_pack": "configs/packs/overlays/emitter_dual_wdm.yaml",
        "optics_pack": "configs/packs/overlays/optics_mode_mix_dual.yaml",
        "sensor_pack": "configs/packs/tmp_budget_sensor.yaml",
        "tia_pack": "configs/packs/tmp_budget_tia.yaml",
        "comparator_pack": "configs/packs/tmp_budget_comparator.yaml",
        "clock_pack": "configs/packs/tmp_budget_clock.yaml",
        "thermal_pack": "configs/packs/thermal_typ.yaml"
      }
    }
  ]
}



-----------------------

.\dashboard\index.html
<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LookingGlassSim Dashboard</title>
  <style>
    :root {
      --bg: #0f172a;      /* slate-900 */
      --card: #111827;    /* gray-900 */
      --card2: #0b1220;   /* deeper */
      --text: #e5e7eb;    /* gray-200 */
      --muted: #9ca3af;   /* gray-400 */
      --accent: #60a5fa;  /* blue-400 */
      --border: #1f2937;  /* gray-800 */
    }
    * { box-sizing: border-box; }
    body { font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial; margin: 0; background: var(--bg); color: var(--text); }
    h1 { margin: 24px 24px 8px; font-size: 22px; font-weight: 600; color: var(--text); }
    p { margin: 0 24px 16px; color: var(--muted); }
    .container { padding: 0 24px 24px; }
    .grid { display: grid; grid-template-columns: minmax(0,1fr) minmax(0,1fr); gap: 16px; align-items: start; }
    .card { background: linear-gradient(180deg, var(--card), var(--card2)); border: 1px solid var(--border); border-radius: 12px; padding: 12px; box-shadow: 0 2px 8px rgba(0,0,0,0.25); }
    h2 { margin: 0 0 10px 0; font-size: 16px; font-weight: 600; color: var(--text); }
    table { border-collapse: collapse; width: 100%; background: transparent; table-layout: fixed; }
    th, td { border: 1px solid var(--border); padding: 6px 8px; text-align: left; font-size: 12px; color: var(--text); word-break: break-word; overflow-wrap: anywhere; }
    th { background: rgba(96,165,250,0.08); }
    .score { font-weight: 600; color: var(--accent); }
    canvas { width: 100% !important; height: 260px !important; }
    .diagram { display: flex; align-items: center; justify-content: center; }
    .box { padding: 6px 10px; border: 1px solid var(--border); border-radius: 6px; margin: 4px; font-size: 12px; background: #0b1220; }
    .arrow { margin: 0 6px; font-size: 16px; color: var(--muted); }
    select, input[type="number"], input[type="text"], button { background: #0b1220; color: var(--text); border: 1px solid var(--border); border-radius: 6px; padding: 6px 8px; }
    select[multiple] { min-height: 96px; }
    button { cursor: pointer; background: linear-gradient(180deg, #1e3a8a, #1f2937); border-color: #1e40af; }
    button:hover { filter: brightness(1.1); }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background: rgba(96,165,250,0.15); color: var(--accent); font-size: 12px; margin-left: 6px; }
    .row { display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
    .col { display:flex; flex-direction:column; gap:6px; }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
  <h1>LookingGlassSim Results</h1>
  <p>Run: <code>python examples/test.py --json out/test_summary.json</code> then open this page and select the JSON.</p>

  <input type="file" id="file" accept="application/json" />
  <div class="card" style="margin:8px 0;">
    <h2>Run Config (multi-select everything)</h2>
    <div style="display:flex;flex-wrap:wrap;gap:16px;align-items:flex-start;">
      <div class="col"><div class="label">Trials</div><select id="ms-trials" multiple size="6" style="min-width:120px;"></select></div>
      <div class="col"><div class="label">Seed</div><select id="ms-seed" multiple size="4" style="min-width:120px;"></select></div>
      <div class="col"><div class="label">Base Window ns</div><select id="ms-window" multiple size="8" style="min-width:120px;"></select></div>
      <div class="col"><div class="label">Input Source</div><select id="ms-input" multiple size="2" style="min-width:160px;"><option value="digital" selected>Digital Emitter (DLP)</option><option value="cold">Analog Input (Cold Reader)</option></select></div>
      <div class="col"><div class="label">Path</div><select id="ms-path" multiple size="2" style="min-width:160px;"><option value="path_a" selected>Path A (Camera/TIA/Comp)</option><option value="path_b_analog">Path B Analog Cascade</option></select></div>
      <div class="col"><div class="label">Path B Depth</div><select id="ms-pathb-depth" multiple size="6" style="min-width:100px;"></select></div>
      <div class="col"><div class="label">Vote3</div><select id="ms-vote3" multiple size="2" style="min-width:120px;"><option value="1" selected>on</option><option value="0">off</option></select></div>
      <div class="col"><div class="label">Autotune</div><select id="ms-autotune" multiple size="2" style="min-width:120px;"><option value="1" selected>on</option><option value="0">off</option></select></div>
      <div class="col"><div class="label">Sensitivity</div><select id="ms-sensitivity" multiple size="2" style="min-width:120px;"><option value="0" selected>off (default)</option><option value="1">on</option></select></div>
      <div class="col"><div class="label">Neighbor CT</div><select id="ms-neighbor" multiple size="2" style="min-width:120px;"><option value="0" selected>off</option><option value="1">on</option></select></div>
      <div class="col"><div class="label">Adaptive Input</div><select id="ms-adapt-flag" multiple size="2" style="min-width:120px;"><option value="1" selected>on</option><option value="0">off</option></select></div>
      <div class="col"><div class="label">Adaptive Max Frames</div><select id="ms-adapt-max" multiple size="6" style="min-width:120px;"></select></div>
      <div class="col"><div class="label">Margin mV</div><select id="ms-margin" multiple size="6" style="min-width:120px;"></select></div>
      <div class="col" style="gap:8px; min-width:260px;">
        <div class="label">Actions</div>
        <div class="row">
          <button id="btn-run" title="Run selected config(s)">Run Selected</button>
          <button id="btn-run-matrix" title="Run Cartesian matrix of selections">Run Matrix</button>
        </div>
        <div class="row" style="margin-top:8px;">
          <input type="file" id="preset-file" accept="application/json" style="min-width:260px;" />
          <button id="btn-run-preset" title="Run branches from selected preset JSON">Run Preset</button>
        </div>
        <div class="col" style="gap:4px; margin-top:8px; min-width:260px;">
          <div class="label">Progress</div>
          <div id="progress-text" style="font-size:12px;color:#9ca3af;">Idle</div>
          <div class="progress" style="width:100%;height:8px;border:1px solid var(--border);border-radius:6px;background:#0b1220;overflow:hidden;">
            <div id="progress-bar" style="height:100%;width:0%;background:linear-gradient(90deg,#1e40af,#60a5fa);"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <div class="card" style="margin:8px 0;">
    <h2>Vendor Packs (optional)</h2>
    <div style="display:flex;flex-wrap:wrap;gap:16px;align-items:flex-start;">
      <div class="col"><div class="label">Emitter</div><select id="packs-emitter" multiple size="6" style="min-width:260px;"></select></div>
      <div class="col"><div class="label">Optics</div><select id="packs-optics" multiple size="6" style="min-width:260px;"></select></div>
      <div class="col"><div class="label">Sensor (PD)</div><select id="packs-sensor" multiple size="6" style="min-width:260px;"></select></div>
      <div class="col"><div class="label">TIA</div><select id="packs-tia" multiple size="6" style="min-width:260px;"></select></div>
      <div class="col"><div class="label">Comparator</div><select id="packs-comparator" multiple size="6" style="min-width:260px;"></select></div>
      <div class="col"><div class="label">Camera</div><select id="packs-camera" multiple size="6" style="min-width:260px;"></select></div>
      <div class="col"><div class="label">Clock</div><select id="packs-clock" multiple size="6" style="min-width:260px;"></select></div>
      <div class="col"><div class="label">Thermal</div><select id="packs-thermal" multiple size="6" style="min-width:260px;"></select></div>
    </div>
    <p style="font-size:12px;color:#9ca3af;">Tip: leave all empty to use defaults. Multi-select to build a matrix of vendor combinations.</p>
  </div>

  <div class="card" style="margin:8px 0;">
    <h2>Worker Log</h2>
    <div style="display:flex;align-items:center;gap:8px;margin-bottom:6px;">
      <span>Connection:</span>
      <span id="conn" style="width:10px;height:10px;border-radius:50%;background:#4b5563;display:inline-block;"></span>
      <span id="connText" style="font-size:12px;color:#9ca3af;">Inactive</span>
    </div>
    <pre id="log" style="white-space:pre-wrap;height:160px;overflow:auto;border:1px solid var(--border);padding:8px;background:#0b1220;"></pre>
  </div>

  <div class="grid" style="margin-top:12px;grid-template-columns: 50% 50%;">
    <div class="card" style="min-width:0;">
      <h2>Summary KPIs</h2>
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;">
        <label title="Choose which variant's KPIs to display in Summary">
          Variant
          <select id="variant-select" style="min-width:220px;"></select>
        </label>
      </div>
      <table id="table-summary"></table>
    </div>
    <div class="card" style="min-width:0;">
      <h2>Variants (click to focus)</h2>
      <div id="variant-bar" style="display:flex;gap:6px;flex-wrap:wrap;"></div>
      <h2>Path A vs Path B</h2>
      <table id="table-paths"></table>
    </div>
    <div class="card">
      <h2>Input Path Comparison</h2>
      <table id="table-inputs"></table>
    </div>
    <div class="card">
      <h2>Realism Heuristics</h2>
      <table id="table-realism"></table>
    </div>
    <div class="card">
      <h2>Per-Component BER Attribution</h2>
      <table id="table-components"></table>
    </div>
    <div class="card">
      <h2>Calibrated Baseline KPIs</h2>
      <table id="table-calibrated"></table>
    </div>
    <div class="card">
      <h2>Per-tile BER</h2>
      <canvas id="tileHeat"></canvas>
    </div>
    <div class="card">
      <h2>Per-tile BER (after calibration)</h2>
      <canvas id="tileHeatAfter"></canvas>
    </div>
    <div class="card">
      <h2>Window Sweep (p50 BER)</h2>
      <canvas id="winChart"></canvas>
    </div>
    <div class="card">
      <h2>Voting & Calibration</h2>
      <table id="table-calib"></table>
    </div>
    <div class="card">
      <h2>Diag Crosstalk Sweep</h2>
      <canvas id="diagChart"></canvas>
    </div>
    <div class="card">
      <h2>Drift vs Time</h2>
      <canvas id="driftChart"></canvas>
    </div>
    <div class="card">
      <h2>Autotuner Result</h2>
      <table id="table-autotune"></table>
    </div>
    <div class="card">
      <h2>Best-of (across Matrix Runs)</h2>
      <table id="table-bestof"></table>
    </div>
    <div class="card">
      <h2>History & Filters</h2>
      <div style="display:flex;gap:8px;align-items:center;margin-bottom:6px;flex-wrap:wrap;">
        <label>Since (epoch s) <input id="hist-since" type="number" style="width:140px;"/></label>
        <label>Pack contains <input id="hist-pack" type="text" style="width:220px;"/></label>
        <label>Status
          <select id="hist-status"><option value="">any</option><option>ok</option><option>warn</option><option>fail</option></select>
        </label>
        <label>Limit <input id="hist-limit" type="number" value="50" style="width:80px;"/></label>
        <button id="btn-load-history">Load</button>
        <button id="btn-best-csv">Export Best CSV</button>
        <button id="btn-all-csv">Export All Runs CSV</button>
        <button id="btn-reset-history" style="margin-left:auto;background:#7f1d1d;border-color:#991b1b;">Reset History</button>
      </div>
      <table id="table-history"></table>
    </div>
    <div class="card">
      <h2>System Diagram</h2>
      <div class="diagram">
        <div class="box">Emitter</div><div class="arrow"></div>
        <div class="box">Optics</div><div class="arrow"></div>
        <div class="box">Camera</div><div class="arrow"></div>
        <div class="box">TIA</div><div class="arrow"></div>
        <div class="box">Comparator</div>
      </div>
      <p style="font-size:12px;color:#555;">Clock controls window & jitter. Thermal drift perturbs comparator threshold and optics transmittance.</p>
    </div>
    <div class="card">
      <h2>Pack Parameters</h2>
      <table id="table-packs"></table>
    </div>
  </div>

  <script>
    const fileInput = document.getElementById('file');
    let winChart, diagChart, driftChart, tileChartA, tileChartB;
    let collectedRuns = [];

    function getRunLabel(run) {
      try {
        const L = run.__label || {};
        const packs = (L.packs || {});
        const diffs = [];
        // defaults
        const def = { input: 'digital', sensitivity: false, output: 'path_a', window_ns: 20, analog_depth: 5 };
        if ((L.input||'digital') !== def.input) diffs.push(L.input === 'cold' ? 'cold' : String(L.input));
        if ((!!L.sensitivity) !== def.sensitivity) diffs.push('sens');
        if ((L.output||'path_a') !== def.output) {
          const d = (L.analog_depth!=null?`d=${L.analog_depth}`:'');
          diffs.push(L.output === 'path_b_analog' ? `pathB${d?`(${d})`:''}` : String(L.output));
        }
        const w = (L.window_ns!=null?Number(L.window_ns):null);
        if (w!=null && Math.round(w) !== def.window_ns) diffs.push(`w=${Math.round(w)}ns`);
        // include notable vendor overrides (non-typ)
        const base = (p)=>{ if(!p) return 'typ'; const s = p.split(/[\\/]/).pop()||''; return s.replace(/\.yaml$/,''); };
        const notable = [];
        ['tia','comparator','camera','emitter','optics','sensor','clock','thermal'].forEach(k=>{
          const b = base(packs[k]);
          if (b && !b.endsWith('_typ')) notable.push(`${k}=${b}`);
        });
        const core = diffs.length ? diffs.join(', ') : 'default';
        return notable.length ? `${core} | ${notable.join(', ')}` : core;
      } catch { return 'run'; }
    }

    function extractPrimaryBer(run) {
      try {
        const out = run.__label?.output;
        if (out === 'path_a') {
          return run?.path_a?.p50_ber ?? run?.baseline?.p50_ber ?? run?.p50_ber ?? null;
        }
        if (out === 'path_b_analog') {
          return run?.path_b?.analog_p50_ber ?? run?.path_b?.p50_ber ?? run?.baseline?.p50_ber ?? null;
        }
        // fallback
        return run?.baseline?.p50_ber ?? run?.p50_ber ?? null;
      } catch { return null; }
    }

    function updateBestOf() {
      const rows = [];
      if (!Array.isArray(collectedRuns) || collectedRuns.length === 0) {
        document.getElementById('table-bestof').innerHTML = '';
        return;
      }
      let bestOverall = { ber: Infinity, label: '' };
      let bestPathA = { ber: Infinity, label: '' };
      let bestPathB = { ber: Infinity, label: '' };
      let bestCold = { ber: Infinity, label: '' };
      let bestDigital = { ber: Infinity, label: '' };

      for (const r of collectedRuns) {
        const label = getRunLabel(r);
        const ber = extractPrimaryBer(r);
        if (typeof ber === 'number') {
          if (ber < bestOverall.ber) bestOverall = { ber, label };
        }
        const out = r.__label?.output;
        const inp = r.__label?.input;
        const berA = r?.path_a?.p50_ber ?? r?.baseline?.p50_ber;
        const berB = r?.path_b?.analog_p50_ber ?? r?.path_b?.p50_ber;
        if (typeof berA === 'number' && berA < bestPathA.ber) bestPathA = { ber: berA, label };
        if (typeof berB === 'number' && berB < bestPathB.ber) bestPathB = { ber: berB, label };
        if (inp === 'cold' && typeof ber === 'number' && ber < bestCold.ber) bestCold = { ber, label };
        if (inp === 'digital' && typeof ber === 'number' && ber < bestDigital.ber) bestDigital = { ber, label };
      }

      const table = document.getElementById('table-bestof');
      const obj = {
        best_overall_p50_ber: bestOverall.ber === Infinity ? 'N/A' : bestOverall.ber,
        best_overall_label: bestOverall.label || 'N/A',
        best_path_a_p50_ber: bestPathA.ber === Infinity ? 'N/A' : bestPathA.ber,
        best_path_a_label: bestPathA.label || 'N/A',
        best_path_b_analog_p50_ber: bestPathB.ber === Infinity ? 'N/A' : bestPathB.ber,
        best_path_b_analog_label: bestPathB.label || 'N/A',
        best_cold_input_p50_ber: bestCold.ber === Infinity ? 'N/A' : bestCold.ber,
        best_cold_input_label: bestCold.label || 'N/A',
        best_digital_input_p50_ber: bestDigital.ber === Infinity ? 'N/A' : bestDigital.ber,
        best_digital_input_label: bestDigital.label || 'N/A',
      };
      renderTable(table, obj);
    }

    function safeDestroy(ch) {
      try { if (ch && typeof ch.destroy === 'function') ch.destroy(); } catch (e) {}
    }

    function renderTable(table, obj) {
      const keys = Object.keys(obj || {});
      let html = '<tr><th>Key</th><th>Value</th></tr>';
      for (const k of keys) {
        let v = obj[k];
        if (typeof v === 'object') v = JSON.stringify(v);
        html += `<tr><td>${k}</td><td>${v}</td></tr>`;
      }
      table.innerHTML = html;
    }

    function renderRowsTable(table, rows) {
      const cols = ["__time","__run_id","__label","baseline.p50_ber","path_a.p50_ber","path_b.analog_p50_ber","__preflight.status"];
      let html = '<tr>' + cols.map(c=>`<th>${c}</th>`).join('') + '</tr>';
      for (const r of rows || []) {
        const cells = [];
        const t = r.__time ? new Date(r.__time*1000).toISOString().replace('T',' ').replace('Z','') : '';
        cells.push(t);
        cells.push(r.__run_id || '');
        cells.push(JSON.stringify(r.__label||{}));
        cells.push(String(r?.baseline?.p50_ber ?? ''));
        cells.push(String(r?.path_a?.p50_ber ?? ''));
        cells.push(String(r?.path_b?.analog_p50_ber ?? ''));
        cells.push(String(r?.__preflight?.status ?? ''));
        html += '<tr>' + cells.map(x=>`<td>${x}</td>`).join('') + '</tr>';
      }
      table.innerHTML = html;
    }

    function renderPacks(table, packs) {
      let html = '<tr><th>Pack</th><th>Params</th></tr>';
      for (const [name, vals] of Object.entries(packs || {})) {
        html += `<tr><td>${name}</td><td><pre style="white-space:pre-wrap;">${JSON.stringify(vals, null, 2)}</pre></td></tr>`;
      }
      table.innerHTML = html;
    }

    function drawHeatmap(canvas, existingChart, matrix) {
      if (!matrix || !Array.isArray(matrix) || matrix.length === 0 || !Array.isArray(matrix[0])) {
        return existingChart || null;
      }
      safeDestroy(existingChart);
      // Flatten matrix into dataset per row; color via gradient plugin surrogate (Chart.js lacks heatmap natively)
      // We'll approximate using stacked bar per column with opacity by value.
      const labels = matrix[0].map((_, i) => 'x'+i);
      const datasets = matrix.map((row, r) => ({
        label: 'y'+r,
        data: row,
        backgroundColor: row.map(v => `rgba(33,150,243,${Math.min(1, Math.max(0.05, v))})`),
        borderWidth: 0
      }));
      const chart = new Chart(canvas.getContext('2d'), {
        type: 'bar',
        data: { labels, datasets },
        options: {
          responsive: true,
          scales: { x: { stacked: true }, y: { stacked: true, suggestedMax: 1.0 } },
          plugins: { legend: { display: false } }
        }
      });
      return chart;
    }

    function drawLine(canvas, existingChart, xs, ys, label) {
      if (!Array.isArray(xs) || !Array.isArray(ys) || xs.length === 0 || ys.length === 0) {
        return existingChart || null;
      }
      safeDestroy(existingChart);
      const chart = new Chart(canvas.getContext('2d'), {
        type: 'line',
        data: { labels: xs, datasets: [{ label, data: ys, borderColor: '#4caf50', fill: false }] },
        options: { responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1 } } }
      });
      return chart;
    }

    fileInput.addEventListener('change', (e) => {
      const f = e.target.files[0];
      if (!f) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const data = JSON.parse(reader.result);
          renderTable(document.getElementById('table-summary'), {
            p50_ber: data?.baseline?.p50_ber,
            p50_energy_pj: data?.baseline?.p50_energy_pj,
            window_ns: data?.baseline?.window_ns,
            p50_snr_emit: data?.baseline?.p50_snr_emit,
            p50_snr_pd: data?.baseline?.p50_snr_pd,
            p50_snr_tia: data?.baseline?.p50_snr_tia,
          });
          renderTable(document.getElementById('table-realism'), (data?.realism)||{});
          renderTable(document.getElementById('table-components'), (data?.components)||{});
          const variants = [];
          variants.push({ key:'baseline', label:'Baseline (Digital, Path A)', present: !!data?.baseline });
          variants.push({ key:'cold_input', label:'Cold input (Path A)', present: !!data?.cold_input });
          variants.push({ key:'path_b', label:'Path B (baseline)', present: !!data?.path_b });
          variants.push({ key:'path_b_analog', label:'Path B (analog cascade)', present: !!data?.path_b?.analog_p50_ber });
          const bar = document.getElementById('variant-bar');
          bar.innerHTML = '';
          const sel = document.getElementById('variant-select');
          sel.innerHTML = '';
          const present = variants.filter(v=>v.present);
          present.forEach(v => {
            const b = document.createElement('button');
            b.textContent = v.label;
            b.style.padding = '4px 8px';
            b.onclick = () => {
              window.__focusVariant = v.key;
              // re-render summary tables according to selected variant if needed
              let base = null;
              if (v.key === 'cold_input') base = data?.cold_input;
              else if (v.key === 'path_b' || v.key === 'path_b_analog') base = data?.path_b;
              else base = data?.baseline;
              if (base) renderTable(document.getElementById('table-summary'), {
                p50_ber: base?.p50_ber ?? 'N/A',
                p50_energy_pj: base?.p50_energy_pj ?? 'N/A',
                window_ns: base?.window_ns ?? 'N/A',
                p50_snr_emit: base?.p50_snr_emit ?? 'N/A',
                p50_snr_pd: base?.p50_snr_pd ?? 'N/A',
                p50_snr_tia: base?.p50_snr_tia ?? 'N/A',
              });
            };
            bar.appendChild(b);
            const opt = document.createElement('option');
            opt.value = v.key;
            opt.textContent = v.label;
            sel.appendChild(opt);
          });
          if (present.length) {
            sel.onchange = () => {
              const key = sel.value;
              window.__focusVariant = key;
              let base = null;
              if (key === 'cold_input') base = data?.cold_input;
              else if (key === 'path_b' || key === 'path_b_analog') base = data?.path_b;
              else base = data?.baseline;
              if (base) renderTable(document.getElementById('table-summary'), {
                p50_ber: base?.p50_ber ?? 'N/A',
                p50_energy_pj: base?.p50_energy_pj ?? 'N/A',
                window_ns: base?.window_ns ?? 'N/A',
                p50_snr_emit: base?.p50_snr_emit ?? 'N/A',
                p50_snr_pd: base?.p50_snr_pd ?? 'N/A',
                p50_snr_tia: base?.p50_snr_tia ?? 'N/A',
              });
            };
            sel.value = present[0].key;
            sel.onchange();
          }
          if (data?.path_a || data?.path_b) {
            renderTable(document.getElementById('table-paths'), {
              path_a_p50_ber: data?.path_a?.p50_ber ?? 'N/A',
              path_b_p50_ber: data?.path_b?.p50_ber ?? 'N/A',
              path_b_chain_depth: data?.path_b_chain?.depth,
              path_b_chain_p50_ber_vs_prev: data?.path_b_chain?.per_stage_p50_ber_vs_prev,
              path_b_chain_p50_ber_vs_initial: data?.path_b_chain?.per_stage_p50_ber_vs_initial,
              path_b_sweep_amp_gain_db: data?.path_b_sweeps?.amp_gain_db,
              path_b_sweep_p50_ber_vs_gain: data?.path_b_sweeps?.p50_ber_vs_gain,
              path_b_sweep_sat_I_sat: data?.path_b_sweeps?.sat_I_sat,
              path_b_sweep_p50_ber_vs_isat: data?.path_b_sweeps?.p50_ber_vs_isat,
            });
          }
          if (data?.cold_input || data?.baseline) {
            renderTable(document.getElementById('table-inputs'), {
              dlp_input_p50_ber: data?.baseline?.p50_ber ?? 'N/A',
              cold_input_p50_ber: data?.cold_input?.p50_ber ?? 'N/A',
              cold_input_window_ns: data?.cold_input?.window_ns ?? 'N/A',
            });
          }
          renderTable(document.getElementById('table-calibrated'), {
            p50_ber: data?.baseline_calibrated?.p50_ber,
            p50_energy_pj: data?.baseline_calibrated?.p50_energy_pj,
            window_ns: data?.baseline_calibrated?.window_ns,
            p50_snr_emit: data?.baseline_calibrated?.p50_snr_emit,
            p50_snr_pd: data?.baseline_calibrated?.p50_snr_pd,
            p50_snr_tia: data?.baseline_calibrated?.p50_snr_tia,
          });
          renderPacks(document.getElementById('table-packs'), data?.packs || {});
          try {
            const hm = data?.ber_per_tile;
            tileChartA = drawHeatmap(document.getElementById('tileHeat'), tileChartA, hm);
          } catch {}
          try {
            const hma = data?.ber_per_tile_after;
            tileChartB = drawHeatmap(document.getElementById('tileHeatAfter'), tileChartB, hma);
          } catch {}
          try {
            const xs = data?.window_sweep?.x_window_ns || [];
            const ys = data?.window_sweep?.p50_ber || [];
            winChart = drawLine(document.getElementById('winChart'), winChart, xs, ys, 'p50 BER');
          } catch {}
          try {
            const dx = data?.sensitivity?.diag_crosstalk_sweep?.x_ct_diag_db || [];
            const dy = data?.sensitivity?.diag_crosstalk_sweep?.p50_ber || [];
            diagChart = drawLine(document.getElementById('diagChart'), diagChart, dx, dy, 'p50 BER vs ct_diag_db');
          } catch {}
          const dno = data?.drift?.no_cal || {};
          const dfix = data?.drift?.with_cal || {};
          if ((dno?.x_frame?.length||0) && (dfix?.x_frame?.length||0)) {
            const ctx = document.getElementById('driftChart').getContext('2d');
            safeDestroy(driftChart);
            driftChart = new Chart(ctx, {
              type: 'line',
              data: {
                labels: dno.x_frame,
                datasets: [
                  { label: 'No Cal', data: dno.p50_ber, borderColor: '#f44336', fill: false },
                  { label: 'With Cal', data: dfix.p50_ber, borderColor: '#2196f3', fill: false }
                ]
              },
              options: { responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1 } } }
            });
          }
          renderTable(document.getElementById('table-calib'), {
            vote3_p50_ber: data?.vote3_p50_ber,
            spatial_oversample_p50_ber: data?.spatial_oversample_p50_ber,
            lockin_p50_ber: data?.lockin_p50_ber,
            chop_p50_ber: data?.chop_p50_ber,
            avg_frames_p50_ber: data?.avg_frames_p50_ber,
            soft_thresh_p50_ber: data?.soft_thresh_p50_ber,
            mitigated_p50_ber: data?.mitigated_p50_ber,
            vth_suggest_mV: data?.calibration?.vth_suggest_mV,
            ber_before: data?.calibration?.ber_before,
            ber_after: data?.calibration?.ber_after,
            ber_delta: data?.calibration?.ber_delta,
          });
          if (data?.autotune) {
            renderTable(document.getElementById('table-autotune'), {
              best_ber: data.autotune.best_ber,
              best_summary: JSON.stringify(data.autotune.best_summary),
              tuned_clock_window_ns: data.autotune.params?.clock?.window_ns,
              tuned_emitter_power_mw_per_ch: data.autotune.params?.emitter?.power_mw_per_ch,
              tuned_tia_gain_kohm: data.autotune.params?.tia?.tia_transimpedance_kohm,
              tuned_tia_bw_mhz: data.autotune.params?.tia?.bw_mhz,
              tuned_comp_hysteresis_mV: data.autotune.params?.comparator?.hysteresis_mV,
              tuned_optics_ct_db: data.autotune.params?.optics?.crosstalk_db,
              tuned_optics_ct_neighbor_db: data.autotune.params?.optics?.ct_neighbor_db,
              tuned_optics_ct_diag_db: data.autotune.params?.optics?.ct_diag_db,
            });
          }
        } catch (err) {
          alert('Invalid JSON');
        }
      };
      reader.readAsText(f);
    });

    // Retest controls
    const logEl = document.getElementById('log');
    function appendLog(obj) {
      const s = (typeof obj === 'string' ? obj : JSON.stringify(obj)) + "\n";
      logEl.textContent += s;
      // Cap log buffer to avoid unbounded growth (keep last ~200k chars)
      const MAX_CHARS = 200000;
      if (logEl.textContent.length > MAX_CHARS) {
        logEl.textContent = logEl.textContent.slice(-MAX_CHARS);
      }
      logEl.scrollTop = logEl.scrollHeight;
    }
    const evtSrc = new EventSource('/api/events');
    let totalPlanned = 0;
    let totalDone = 0;
    function setProgress(total, done) {
      totalPlanned = total; totalDone = done;
      const pct = total > 0 ? Math.min(100, Math.floor((done/total)*100)) : 0;
      document.getElementById('progress-text').textContent = total ? `Running ${done} / ${total} (${pct}%)` : 'Idle';
      document.getElementById('progress-bar').style.width = `${pct}%`;
    }
    evtSrc.onmessage = (ev) => {
      try {
        const data = JSON.parse(ev.data);
        if (data.msg === 'connected') {
          document.getElementById('conn').style.background = '#4caf50';
          document.getElementById('connText').textContent = 'Active';
          // Do not reset progress to Idle if we already have a planned run
          if (totalPlanned === 0) setProgress(0,0);
          return;
        }
        if (data.msg === 'started') {
          // Ensure progress shows running if no prior plan (e.g., server-side start)
          if (totalPlanned === 0) setProgress(1, 0);
        }
        if (data.ping) return; // quiet heartbeat
        appendLog(data);
      } catch { appendLog(ev.data); }
    };
    evtSrc.addEventListener('done', (ev) => {
      try {
        const data = JSON.parse(ev.data);
        if (data.__run_id) {
          setProgress(totalPlanned, Math.min(totalPlanned, totalDone+1));
          // Matrix run result: collect and append to select, auto-render latest
          // Keep only a bounded number of recent runs to avoid growing memory
          collectedRuns.push(data);
          const MAX_RUNS = 250;
          if (collectedRuns.length > MAX_RUNS) collectedRuns.splice(0, collectedRuns.length - MAX_RUNS);
          const sel = document.getElementById('variant-select');
          const label = getRunLabel(data);
          const opt = document.createElement('option');
          opt.value = `run:${data.__run_id}`;
          opt.textContent = label;
          sel.appendChild(opt);
          sel.value = `run:${data.__run_id}`;
          // render immediately across panels
          renderTable(document.getElementById('table-summary'), {
            p50_ber: data?.baseline?.p50_ber ?? data?.p50_ber ?? 'N/A',
            p50_energy_pj: data?.baseline?.p50_energy_pj ?? data?.p50_energy_pj ?? 'N/A',
            window_ns: data?.baseline?.window_ns ?? data?.window_ns ?? 'N/A',
            p50_snr_emit: data?.baseline?.p50_snr_emit ?? data?.p50_snr_emit ?? 'N/A',
            p50_snr_pd: data?.baseline?.p50_snr_pd ?? data?.p50_snr_pd ?? 'N/A',
            p50_snr_tia: data?.baseline?.p50_snr_tia ?? data?.p50_snr_tia ?? 'N/A',
          });
          renderTable(document.getElementById('table-realism'), (data?.realism)||{});
          renderTable(document.getElementById('table-components'), (data?.components)||{});
          renderTable(document.getElementById('table-paths'), {
            path_a_p50_ber: data?.path_a?.p50_ber ?? 'N/A',
            path_b_p50_ber: data?.path_b?.p50_ber ?? 'N/A',
            path_b_chain_depth: data?.path_b_chain?.depth ?? 'N/A',
            path_b_chain_p50_ber_vs_prev: data?.path_b_chain?.per_stage_p50_ber_vs_prev ?? 'N/A',
            path_b_chain_p50_ber_vs_initial: data?.path_b_chain?.per_stage_p50_ber_vs_initial ?? 'N/A',
            path_b_analog_depth: data?.path_b?.analog_depth ?? 'N/A',
            path_b_analog_p50_ber: data?.path_b?.analog_p50_ber ?? 'N/A',
          });
          renderTable(document.getElementById('table-inputs'), {
            dlp_input_p50_ber: data?.baseline?.p50_ber ?? 'N/A',
            cold_input_p50_ber: data?.cold_input?.p50_ber ?? 'N/A',
            cold_input_window_ns: data?.cold_input?.window_ns ?? 'N/A',
          });
          renderTable(document.getElementById('table-calibrated'), {
            p50_ber: data?.baseline_calibrated?.p50_ber,
            p50_energy_pj: data?.baseline_calibrated?.p50_energy_pj,
            window_ns: data?.baseline_calibrated?.window_ns,
            p50_snr_emit: data?.baseline_calibrated?.p50_snr_emit,
            p50_snr_pd: data?.baseline_calibrated?.p50_snr_pd,
            p50_snr_tia: data?.baseline_calibrated?.p50_snr_tia,
          });
          // Packs
          try { renderPacks(document.getElementById('table-packs'), data?.packs || {}); } catch {}
          try { tileChartA = drawHeatmap(document.getElementById('tileHeat'), tileChartA, data?.ber_per_tile); } catch {}
          try { tileChartB = drawHeatmap(document.getElementById('tileHeatAfter'), tileChartB, data?.ber_per_tile_after); } catch {}
          try {
            const xs = data?.window_sweep?.x_window_ns || [];
            const ys = data?.window_sweep?.p50_ber || [];
            winChart = drawLine(document.getElementById('winChart'), winChart, xs, ys, 'p50 BER');
          } catch {}
          // Diag crosstalk sweep (sensitivity block)
          try {
            const dx = data?.sensitivity?.diag_crosstalk_sweep?.x_ct_diag_db || [];
            const dy = data?.sensitivity?.diag_crosstalk_sweep?.p50_ber || [];
            diagChart = drawLine(document.getElementById('diagChart'), diagChart, dx, dy, 'p50 BER vs ct_diag_db');
          } catch {}
          // Drift vs time
          try {
            const dno = data?.drift?.no_cal || {};
            const dfix = data?.drift?.with_cal || {};
            if ((dno?.x_frame?.length||0) && (dfix?.x_frame?.length||0)) {
              const ctx = document.getElementById('driftChart').getContext('2d');
              safeDestroy(driftChart);
              driftChart = new Chart(ctx, {
                type: 'line',
                data: { labels: dno.x_frame, datasets: [
                  { label: 'No Cal', data: dno.p50_ber, borderColor: '#f44336', fill: false },
                  { label: 'With Cal', data: dfix.p50_ber, borderColor: '#2196f3', fill: false },
                ]},
                options: { responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1 } } }
              });
            }
          } catch {}
          // Autotuner results
          if (data?.autotune) {
            renderTable(document.getElementById('table-autotune'), {
              best_ber: data.autotune.best_ber,
              best_summary: JSON.stringify(data.autotune.best_summary),
              tuned_clock_window_ns: data.autotune.params?.clock?.window_ns,
              tuned_emitter_power_mw_per_ch: data.autotune.params?.emitter?.power_mw_per_ch,
              tuned_tia_gain_kohm: data.autotune.params?.tia?.tia_transimpedance_kohm,
              tuned_tia_bw_mhz: data.autotune.params?.tia?.bw_mhz,
              tuned_comp_hysteresis_mV: data.autotune.params?.comparator?.hysteresis_mV,
              tuned_optics_ct_db: data.autotune.params?.optics?.crosstalk_db,
              tuned_optics_ct_neighbor_db: data.autotune.params?.optics?.ct_neighbor_db,
              tuned_optics_ct_diag_db: data.autotune.params?.optics?.ct_diag_db,
            });
          }
          renderTable(document.getElementById('table-calib'), {
            vote3_p50_ber: data?.vote3_p50_ber,
            spatial_oversample_p50_ber: data?.spatial_oversample_p50_ber,
            lockin_p50_ber: data?.lockin_p50_ber,
            chop_p50_ber: data?.chop_p50_ber,
            avg_frames_p50_ber: data?.avg_frames_p50_ber,
            soft_thresh_p50_ber: data?.soft_thresh_p50_ber,
            mitigated_p50_ber: data?.mitigated_p50_ber,
            vth_suggest_mV: data?.calibration?.vth_suggest_mV,
            ber_before: data?.calibration?.ber_before,
            ber_after: data?.calibration?.ber_after,
            ber_delta: data?.calibration?.ber_delta,
          });
          // update best-of
          updateBestOf();
          return;
        }
        // Auto-load the finished JSON
        renderTable(document.getElementById('table-summary'), {
          p50_ber: data?.baseline?.p50_ber ?? 'N/A',
          p50_energy_pj: data?.baseline?.p50_energy_pj ?? 'N/A',
          window_ns: data?.baseline?.window_ns ?? 'N/A',
          p50_snr_emit: data?.baseline?.p50_snr_emit ?? 'N/A',
          p50_snr_pd: data?.baseline?.p50_snr_pd ?? 'N/A',
          p50_snr_tia: data?.baseline?.p50_snr_tia ?? 'N/A',
        });
        renderTable(document.getElementById('table-realism'), (data?.realism)||{});
        // Build/refresh variants bar
        const variants = [];
        variants.push({ key:'baseline', label:'Baseline (Digital, Path A)', present: !!data?.baseline });
        variants.push({ key:'cold_input', label:'Cold input (Path A)', present: !!data?.cold_input });
        variants.push({ key:'path_b', label:'Path B (baseline)', present: !!data?.path_b });
        variants.push({ key:'path_b_analog', label:'Path B (analog cascade)', present: !!data?.path_b?.analog_p50_ber });
        const bar = document.getElementById('variant-bar');
        bar.innerHTML = '';
        const sel = document.getElementById('variant-select');
        sel.innerHTML = '';
        const present = variants.filter(v=>v.present);
        present.forEach(v => {
          const b = document.createElement('button');
          b.textContent = v.label;
          b.style.padding = '4px 8px';
          b.onclick = () => {
            window.__focusVariant = v.key;
            const base = (v.key==='cold_input') ? data?.cold_input : data?.baseline;
            if (base) renderTable(document.getElementById('table-summary'), {
              p50_ber: base?.p50_ber ?? 'N/A',
              p50_energy_pj: base?.p50_energy_pj ?? 'N/A',
              window_ns: base?.window_ns ?? 'N/A',
              p50_snr_emit: base?.p50_snr_emit ?? 'N/A',
              p50_snr_pd: base?.p50_snr_pd ?? 'N/A',
              p50_snr_tia: base?.p50_snr_tia ?? 'N/A',
            });
          };
          bar.appendChild(b);
          const opt = document.createElement('option');
          opt.value = v.key;
          opt.textContent = v.label;
          sel.appendChild(opt);
        });
        if (present.length) {
          sel.onchange = () => {
            const key = sel.value;
            window.__focusVariant = key;
            const base = (key==='cold_input') ? data?.cold_input : data?.baseline;
            if (base) renderTable(document.getElementById('table-summary'), {
              p50_ber: base?.p50_ber ?? 'N/A',
              p50_energy_pj: base?.p50_energy_pj ?? 'N/A',
              window_ns: base?.window_ns ?? 'N/A',
              p50_snr_emit: base?.p50_snr_emit ?? 'N/A',
              p50_snr_pd: base?.p50_snr_pd ?? 'N/A',
              p50_snr_tia: base?.p50_snr_tia ?? 'N/A',
            });
          };
          sel.value = present[0].key;
          sel.onchange();
        }
        if (data?.path_a || data?.path_b) {
          renderTable(document.getElementById('table-paths'), {
            path_a_p50_ber: data?.path_a?.p50_ber ?? 'N/A',
            path_b_p50_ber: data?.path_b?.p50_ber ?? 'N/A',
            path_b_chain_depth: data?.path_b_chain?.depth ?? 'N/A',
            path_b_chain_p50_ber_vs_prev: data?.path_b_chain?.per_stage_p50_ber_vs_prev ?? 'N/A',
            path_b_chain_p50_ber_vs_initial: data?.path_b_chain?.per_stage_p50_ber_vs_initial ?? 'N/A',
            path_b_analog_depth: data?.path_b?.analog_depth ?? 'N/A',
            path_b_analog_p50_ber: data?.path_b?.analog_p50_ber ?? 'N/A',
            path_b_sweep_amp_gain_db: data?.path_b_sweeps?.amp_gain_db ?? 'N/A',
            path_b_sweep_p50_ber_vs_gain: data?.path_b_sweeps?.p50_ber_vs_gain ?? 'N/A',
            path_b_sweep_sat_I_sat: data?.path_b_sweeps?.sat_I_sat ?? 'N/A',
            path_b_sweep_p50_ber_vs_isat: data?.path_b_sweeps?.p50_ber_vs_isat ?? 'N/A',
          });
        }
        if (data?.cold_input || data?.baseline) {
          renderTable(document.getElementById('table-inputs'), {
            dlp_input_p50_ber: data?.baseline?.p50_ber ?? 'N/A',
            cold_input_p50_ber: data?.cold_input?.p50_ber ?? 'N/A',
            cold_input_window_ns: data?.cold_input?.window_ns ?? 'N/A',
          });
        }
        renderTable(document.getElementById('table-calibrated'), {
          p50_ber: data?.baseline_calibrated?.p50_ber,
          p50_energy_pj: data?.baseline_calibrated?.p50_energy_pj,
          window_ns: data?.baseline_calibrated?.window_ns,
          p50_snr_emit: data?.baseline_calibrated?.p50_snr_emit,
          p50_snr_pd: data?.baseline_calibrated?.p50_snr_pd,
          p50_snr_tia: data?.baseline_calibrated?.p50_snr_tia,
        });
        try {
          const hm = data?.ber_per_tile;
          tileChartA = drawHeatmap(document.getElementById('tileHeat'), tileChartA, hm);
        } catch {}
        try {
          const hma = data?.ber_per_tile_after;
          tileChartB = drawHeatmap(document.getElementById('tileHeatAfter'), tileChartB, hma);
        } catch {}
        try {
          const xs = data?.window_sweep?.x_window_ns || [];
          const ys = data?.window_sweep?.p50_ber || [];
          winChart = drawLine(document.getElementById('winChart'), winChart, xs, ys, 'p50 BER');
        } catch {}
        renderTable(document.getElementById('table-calib'), {
          vote3_p50_ber: data?.vote3_p50_ber,
          spatial_oversample_p50_ber: data?.spatial_oversample_p50_ber,
          lockin_p50_ber: data?.lockin_p50_ber,
          chop_p50_ber: data?.chop_p50_ber,
          avg_frames_p50_ber: data?.avg_frames_p50_ber,
          soft_thresh_p50_ber: data?.soft_thresh_p50_ber,
          mitigated_p50_ber: data?.mitigated_p50_ber,
          vth_suggest_mV: data?.calibration?.vth_suggest_mV,
          ber_before: data?.calibration?.ber_before,
          ber_after: data?.calibration?.ber_after,
          ber_delta: data?.calibration?.ber_delta,
        });
        if (data?.autotune) {
          renderTable(document.getElementById('table-autotune'), {
            best_ber: data.autotune.best_ber,
            tuned_clock_window_ns: data.autotune.params?.clock?.window_ns,
            tuned_emitter_power_mw_per_ch: data.autotune.params?.emitter?.power_mw_per_ch,
            tuned_tia_gain_kohm: data.autotune.params?.tia?.tia_transimpedance_kohm,
            tuned_tia_bw_mhz: data.autotune.params?.tia?.bw_mhz,
            tuned_comp_hysteresis_mV: data.autotune.params?.comparator?.hysteresis_mV,
            tuned_optics_ct_db: data.autotune.params?.optics?.crosstalk_db,
            tuned_optics_ct_neighbor_db: data.autotune.params?.optics?.ct_neighbor_db,
            tuned_optics_ct_diag_db: data.autotune.params?.optics?.ct_diag_db,
          });
        }
        try {
          const dx = data?.sensitivity?.diag_crosstalk_sweep?.x_ct_diag_db || [];
          const dy = data?.sensitivity?.diag_crosstalk_sweep?.p50_ber || [];
          diagChart = drawLine(document.getElementById('diagChart'), diagChart, dx, dy, 'p50 BER vs ct_diag_db');
        } catch {}
        const dno = data?.drift?.no_cal || {};
        const dfix = data?.drift?.with_cal || {};
        if ((dno?.x_frame?.length||0) && (dfix?.x_frame?.length||0)) {
          const ctx = document.getElementById('driftChart').getContext('2d');
          new Chart(ctx, { type: 'line', data: { labels: dno.x_frame, datasets: [ { label: 'No Cal', data: dno.p50_ber, borderColor: '#f44336', fill: false }, { label: 'With Cal', data: dfix.p50_ber, borderColor: '#2196f3', fill: false } ] }, options: { responsive: true, scales: { y: { suggestedMin: 0, suggestedMax: 1 } } } });
        }
      } catch (e) { appendLog({ error: String(e) }); }
    });
    function firstOf(id) {
      const el = document.getElementById(id);
      const sel = Array.from(el.selectedOptions).map(o=>o.value);
      return sel[0];
    }
    function csvOf(id) {
      const el = document.getElementById(id);
      const sel = Array.from(el.selectedOptions).map(o=>o.value);
      return sel.join(',');
    }
    document.getElementById('btn-run').onclick = async () => {
      const trials = firstOf('ms-trials');
      const seed = firstOf('ms-seed');
      const windowNs = firstOf('ms-window');
      const vote = firstOf('ms-vote3') || '1';
      const auto = firstOf('ms-autotune') || '1';
      const sens = firstOf('ms-sensitivity') || '0';
      const neigh = firstOf('ms-neighbor') || '0';
      const adapt = firstOf('ms-adapt-flag') || '1';
      const pbd = firstOf('ms-pathb-depth');
      const adaptMax = firstOf('ms-adapt-max');
      const adaptMargin = firstOf('ms-margin');
      const path = firstOf('ms-path');
      const inputSrc = firstOf('ms-input');
      appendLog({ msg: 'requesting run' });
      try {
        const packArgs = new URLSearchParams();
        const map = {
          'packs-emitter': 'emitter_pack',
          'packs-optics': 'optics_pack',
          'packs-sensor': 'sensor_pack',
          'packs-tia': 'tia_pack',
          'packs-comparator': 'comparator_pack',
          'packs-camera': 'camera_pack',
          'packs-clock': 'clock_pack',
          'packs-thermal': 'thermal_pack',
        };
        Object.entries(map).forEach(([id, key]) => {
          const v = firstOf(id);
          if (v) packArgs.append(key, v);
        });
        const isPathB = (path === 'path_b_analog');
        const cold = (inputSrc === 'cold') ? '1':'0';
        const r = await fetch(`/api/run?trials=${trials}&seed=${seed}&base_window_ns=${windowNs}&vote3=${vote}&autotune=${auto}&sensitivity=${sens}&neighbor_ct=${neigh}&path_b=${isPathB?'1':'0'}&path_b_depth=${pbd}&path_b_sweep=0&path_b_analog_depth=${pbd}&path_b_analog=${isPathB?'1':'0'}&cold_input=${cold}&adaptive_input=${adapt}&adaptive_max_frames=${adaptMax}&adaptive_margin_mV=${adaptMargin}&${packArgs.toString()}`);
        const resp = await r.json();
        appendLog(resp);
        setProgress(1, 0);
      } catch (err) { appendLog({ error: String(err) }); }
    };

    document.getElementById('btn-run-matrix').onclick = async () => {
      const trials = csvOf('ms-trials');
      const seed = csvOf('ms-seed');
      const windowNs = csvOf('ms-window');
      const depths = csvOf('ms-pathb-depth');
      const auto = csvOf('ms-autotune') || '1';
      const votes = csvOf('ms-vote3') || '1';
      const sens = csvOf('ms-sensitivity') || '0';
      const neigh = csvOf('ms-neighbor') || '0';
      const adapt = csvOf('ms-adapt-flag') || '1';
      const inputs = csvOf('ms-input');
      const outputs = csvOf('ms-path');
      appendLog({ msg: 'requesting matrix run' });
      try {
        // Build CSV lists from multi-selects
        const pickCSV = (id) => {
          const el = document.getElementById(id);
          if (!el) return '';
          const sel = Array.from(el.selectedOptions).map(o=>o.value);
          return encodeURIComponent(sel.join(','));
        };
        const cap = 96;
        const q = `emitter_packs=${pickCSV('packs-emitter')}&optics_packs=${pickCSV('packs-optics')}&sensor_packs=${pickCSV('packs-sensor')}&tia_packs=${pickCSV('packs-tia')}&comparator_packs=${pickCSV('packs-comparator')}&camera_packs=${pickCSV('packs-camera')}&clock_packs=${pickCSV('packs-clock')}&thermal_packs=${pickCSV('packs-thermal')}`;
        const r = await fetch(`/api/run_matrix?trials=${trials}&seed=${seed}&windows=${windowNs}&inputs=${inputs}&outputs=${outputs}&path_b_analog_depths=${depths}&autotune=${auto}&vote3=${votes}&sensitivity=${sens}&neighbor_ct=${neigh}&adaptive_input=${adapt}&adaptive_max_frames=${csvOf('ms-adapt-max')}&adaptive_margin_mV=${csvOf('ms-margin')}&cap=${cap}&${q}`);
        const resp = await r.json();
        appendLog(resp);
        if (resp && typeof resp.runs === 'number') setProgress(resp.runs, 0);
      } catch (err) { appendLog({ error: String(err) }); }
    };

    document.getElementById('btn-load-history').onclick = async () => {
      const since = document.getElementById('hist-since').value || '';
      const pack = document.getElementById('hist-pack').value || '';
      const status = document.getElementById('hist-status').value || '';
      const limit = document.getElementById('hist-limit').value || '50';
      try {
        const r = await fetch(`/api/history?limit=${encodeURIComponent(limit)}&since=${encodeURIComponent(since)}&pack_contains=${encodeURIComponent(pack)}&status=${encodeURIComponent(status)}`);
        const data = await r.json();
        renderRowsTable(document.getElementById('table-history'), data.rows || []);
      } catch (e) { appendLog({ error: String(e) }); }
    };

    document.getElementById('btn-best-csv').onclick = async () => {
      const status = document.getElementById('hist-status').value || '';
      // group by all packs by default
      const qs = `status=${encodeURIComponent(status)}&group_by=emitter,optics,sensor,tia,comparator,camera,clock,thermal&format=csv`;
      try {
        const r = await fetch(`/api/history_best?${qs}`);
        const text = await r.text();
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([text], {type:'text/csv'}));
        a.download = 'history_best.csv';
        a.click();
      } catch (e) { appendLog({ error: String(e) }); }
    };

    document.getElementById('btn-all-csv').onclick = async () => {
      const since = document.getElementById('hist-since').value || '';
      const pack = document.getElementById('hist-pack').value || '';
      const status = document.getElementById('hist-status').value || '';
      const limit = document.getElementById('hist-limit').value || '10000';
      try {
        const r = await fetch(`/api/history?format=csv&limit=${encodeURIComponent(limit)}&since=${encodeURIComponent(since)}&pack_contains=${encodeURIComponent(pack)}&status=${encodeURIComponent(status)}`);
        const text = await r.text();
        const a = document.createElement('a');
        a.href = URL.createObjectURL(new Blob([text], {type:'text/csv'}));
        a.download = 'history_all_runs.csv';
        a.click();
      } catch (e) { appendLog({ error: String(e) }); }
    };

    // Run preset (JSON file with runs array)
    document.getElementById('btn-run-preset').onclick = async () => {
      const f = document.getElementById('preset-file').files?.[0];
      if (!f) { appendLog({ error: 'Select a preset JSON first' }); return; }
      try {
        const text = await f.text();
        const payload = JSON.parse(text);
        appendLog({ msg: 'requesting preset run', branches: (payload?.runs||[]).length });
        const r = await fetch('/api/run_preset', { method: 'POST', headers: { 'Content-Type':'application/json' }, body: JSON.stringify(payload) });
        const resp = await r.json();
        appendLog(resp);
        if (resp && typeof resp.runs === 'number') setProgress(resp.runs, 0);
      } catch (e) { appendLog({ error: String(e) }); }
    };

    document.getElementById('btn-reset-history').onclick = async () => {
      if (!confirm('This will delete runs_history.jsonl. Continue?')) return;
      try {
        const r = await fetch('/api/history/reset', { method: 'POST' });
        appendLog(await r.json());
      } catch (e) { appendLog({ error: String(e) }); }
    };

    // Populate vendor packs and Run Config lists
    (async () => {
      try {
        const r = await fetch('/api/packs');
        const data = await r.json();
        const fill = (id, arr) => {
          const el = document.getElementById(id);
          if (!el) return;
          el.innerHTML = '';
          (arr||[]).forEach(p => { const o = document.createElement('option'); o.value = p; o.textContent = p; el.appendChild(o); });
        };
        fill('packs-emitter', data.emitters || data.emitters || data.emitter || []);
        fill('packs-optics', data.optics || []);
        fill('packs-sensor', data.sensors || data.sensor || []);
        fill('packs-tia', data.tias || data.tia || []);
        fill('packs-comparator', data.comparators || data.comparator || []);
        fill('packs-camera', data.cameras || data.camera || []);
        fill('packs-clock', data.clocks || data.clock || []);
        fill('packs-thermal', data.thermal || []);
        // Run config defaults
        const trials = Array.from({length: 20}, (_,i)=> (50*(i+1))).map(x=>String(x));
        const seeds = ['123','321','42','777'];
        const windows = Array.from({length:50},(_,i)=>String(i+1));
        const depths = Array.from({length:50},(_,i)=>String(i+1));
        const adaptMax = Array.from({length:16},(_,i)=>String(i+1));
        const margins = Array.from({length:20},(_,i)=> (0.1*(i+1)).toFixed(1));
        const fillOpts = (id, arr, selIdxs=[0]) => { const el=document.getElementById(id); el.innerHTML=''; arr.forEach((v,idx)=>{ const o=document.createElement('option'); o.value=v; o.textContent=v; if(selIdxs.includes(idx)) o.selected=true; el.appendChild(o); }); };
        fillOpts('ms-trials', trials, [5]);
        fillOpts('ms-seed', seeds, [0]);
        fillOpts('ms-window', windows, [19]);
        fillOpts('ms-pathb-depth', depths, [4]);
        fillOpts('ms-adapt-max', adaptMax, [11]);
        fillOpts('ms-margin', margins, [7]);
      } catch {}
    })();

    // Allow selecting any collected matrix run from the dropdown later
    document.getElementById('variant-select').addEventListener('change', () => {
      const sel = document.getElementById('variant-select');
      const val = sel.value || '';
      if (!val.startsWith('run:')) return; // handled elsewhere for static variants
      const runId = val.slice(4);
      const data = collectedRuns.find(r => r.__run_id === runId);
      if (!data) return;
      renderTable(document.getElementById('table-summary'), {
        p50_ber: data?.baseline?.p50_ber ?? data?.p50_ber ?? 'N/A',
        p50_energy_pj: data?.baseline?.p50_energy_pj ?? data?.p50_energy_pj ?? 'N/A',
        window_ns: data?.baseline?.window_ns ?? data?.window_ns ?? 'N/A',
        p50_snr_emit: data?.baseline?.p50_snr_emit ?? data?.p50_snr_emit ?? 'N/A',
        p50_snr_pd: data?.baseline?.p50_snr_pd ?? data?.p50_snr_pd ?? 'N/A',
        p50_snr_tia: data?.baseline?.p50_snr_tia ?? data?.p50_snr_tia ?? 'N/A',
      });
      renderTable(document.getElementById('table-realism'), (data?.realism)||{});
      renderTable(document.getElementById('table-components'), (data?.components)||{});
      renderTable(document.getElementById('table-paths'), {
        path_a_p50_ber: data?.path_a?.p50_ber ?? 'N/A',
        path_b_p50_ber: data?.path_b?.p50_ber ?? 'N/A',
        path_b_chain_depth: data?.path_b_chain?.depth ?? 'N/A',
        path_b_chain_p50_ber_vs_prev: data?.path_b_chain?.per_stage_p50_ber_vs_prev ?? 'N/A',
        path_b_chain_p50_ber_vs_initial: data?.path_b_chain?.per_stage_p50_ber_vs_initial ?? 'N/A',
        path_b_analog_depth: data?.path_b?.analog_depth ?? 'N/A',
        path_b_analog_p50_ber: data?.path_b?.analog_p50_ber ?? 'N/A',
      });
      renderTable(document.getElementById('table-inputs'), {
        dlp_input_p50_ber: data?.baseline?.p50_ber ?? 'N/A',
        cold_input_p50_ber: data?.cold_input?.p50_ber ?? 'N/A',
        cold_input_window_ns: data?.cold_input?.window_ns ?? 'N/A',
      });
      renderTable(document.getElementById('table-calibrated'), {
        p50_ber: data?.baseline_calibrated?.p50_ber,
        p50_energy_pj: data?.baseline_calibrated?.p50_energy_pj,
        window_ns: data?.baseline_calibrated?.window_ns,
        p50_snr_emit: data?.baseline_calibrated?.p50_snr_emit,
        p50_snr_pd: data?.baseline_calibrated?.p50_snr_pd,
        p50_snr_tia: data?.baseline_calibrated?.p50_snr_tia,
      });
      try { tileChartA = drawHeatmap(document.getElementById('tileHeat'), tileChartA, data?.ber_per_tile); } catch {}
      try { tileChartB = drawHeatmap(document.getElementById('tileHeatAfter'), tileChartB, data?.ber_per_tile_after); } catch {}
      try {
        const xs = data?.window_sweep?.x_window_ns || [];
        const ys = data?.window_sweep?.p50_ber || [];
        winChart = drawLine(document.getElementById('winChart'), winChart, xs, ys, 'p50 BER');
      } catch {}
      renderTable(document.getElementById('table-calib'), {
        vote3_p50_ber: data?.vote3_p50_ber,
        spatial_oversample_p50_ber: data?.spatial_oversample_p50_ber,
        lockin_p50_ber: data?.lockin_p50_ber,
        chop_p50_ber: data?.chop_p50_ber,
        avg_frames_p50_ber: data?.avg_frames_p50_ber,
        soft_thresh_p50_ber: data?.soft_thresh_p50_ber,
        mitigated_p50_ber: data?.mitigated_p50_ber,
        vth_suggest_mV: data?.calibration?.vth_suggest_mV,
        ber_before: data?.calibration?.ber_before,
        ber_after: data?.calibration?.ber_after,
        ber_delta: data?.calibration?.ber_delta,
      });
      updateBestOf();
    });
  </script>
</body>
</html>




-----------------------

.\scripts\run_probes.py
import sys
import json
from pathlib import Path


def run_one(window_ns: float, out_path: str) -> dict:
    # Build argv to call examples/test.py main() directly (avoids shell quoting issues)
    argv = [
        "examples/test.py",
        "--trials", "200",
        "--seed", "123",
        "--no-sweeps",
        "--no-drift",
        "--light-output",
        "--base-window-ns", str(float(window_ns)),
        "--avg-frames", "1",
        "--classifier", "avg",
        "--apply-calibration",
        "--no-adaptive-input",
        "--no-cold-input",
        "--no-path-b", "--path-b-depth", "0", "--no-path-b-analog",
        # Vendor packs (match winning preset)
        "--emitter-pack", "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml",
        "--optics-pack", "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml",
        "--sensor-pack", "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml",
        "--tia-pack", "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml",
        "--tia-pack", "configs/packs/overlays/tuned_tia.yaml",
        "--comparator-pack", "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml",
        "--clock-pack", "configs/packs/clock_typ.yaml",
        "--thermal-pack", "configs/packs/thermal_typ.yaml",
        "--quiet",
        "--json", out_path,
    ]
    # Inject argv and call main
    import importlib
    test_mod = importlib.import_module("examples.test")
    prev_argv = sys.argv[:]
    try:
        sys.argv = argv
        test_mod.main()
    finally:
        sys.argv = prev_argv
    # Load result
    data = json.loads(Path(out_path).read_text(encoding="utf-8"))
    return data


def summarize(label: str, data: dict) -> str:
    base_cal = (data.get("baseline_calibrated") or {})
    pa = (data.get("path_a") or {})
    cfg = (data.get("config") or {})
    return "{} win={} base_cal.p50_ber={} path_a.p50_ber={}".format(
        label,
        cfg.get('base_window_ns'),
        base_cal.get('p50_ber'),
        pa.get('p50_ber'),
    )


def main():
    # Minimal fixed set of windows to probe quickly; adjust as needed
    windows = [14.0, 16.0, 18.0, 20.0]
    out_dir = Path("out")
    out_dir.mkdir(parents=True, exist_ok=True)
    lines = []
    for w in windows:
        out_path = str(out_dir / f"probe_single_avg_win{int(w)}.json")
        data = run_one(w, out_path)
        lines.append(summarize(f"single_avg", data))
    # Print concise summary lines
    for ln in lines:
        print(ln)


if __name__ == "__main__":
    main()





-----------------------

.\scripts\probe_queue_runner.py
import sys
import time
import json
import hashlib
import runpy
from pathlib import Path
from datetime import datetime
import os


BASE_DIR = Path(__file__).resolve().parent.parent
QUEUE_PATH = BASE_DIR / "queue" / "probes.jsonl"
COMPLETED_PATH = BASE_DIR / "queue" / "completed.jsonl"
OUT_DIR = BASE_DIR / "out"


def ensure_paths():
    QUEUE_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    if not QUEUE_PATH.exists():
        QUEUE_PATH.write_text("", encoding="utf-8")
    if not COMPLETED_PATH.exists():
        COMPLETED_PATH.write_text("", encoding="utf-8")


def job_signature(job: dict) -> str:
    # Exclude output path from signature so replays to new file don't duplicate
    canon = {k: v for k, v in job.items() if k not in {"json_out", "label"}}
    blob = json.dumps(canon, sort_keys=True, ensure_ascii=False)
    return hashlib.sha1(blob.encode("utf-8")).hexdigest()


def load_completed_signatures() -> set[str]:
    sigs: set[str] = set()
    try:
        for line in COMPLETED_PATH.read_text(encoding="utf-8").splitlines():
            if not line.strip():
                continue
            try:
                rec = json.loads(line)
                s = rec.get("signature")
                status = rec.get("status")
                # Skip signatures that have already been processed (ok or error)
                if isinstance(s, str) and status in ("ok", "error"):
                    sigs.add(s)
            except json.JSONDecodeError:
                continue
    except FileNotFoundError:
        pass
    return sigs


def append_completed(record: dict) -> None:
    # Write a minimal record to avoid encoding/size issues
    rec_min = {
        "signature": record.get("signature"),
        "status": record.get("status"),
        "out": record.get("out"),
        "summary": record.get("summary"),
        "finished_at": record.get("finished_at"),
        # Include helpful debugging fields when present
        "error": record.get("error"),
        "label": (record.get("job") or {}).get("label") if isinstance(record.get("job"), dict) else None,
        "traceback": record.get("traceback"),
    }
    # Append one JSON line per run and force it to disk immediately
    line = json.dumps(rec_min, ensure_ascii=True) + "\n"
    try:
        before = COMPLETED_PATH.stat().st_size if COMPLETED_PATH.exists() else 0
    except Exception:
        before = -1
    with COMPLETED_PATH.open("a", encoding="utf-8") as f:
        f.write(line)
        f.flush()
        try:
            import os
            os.fsync(f.fileno())
        except OSError as _oe:
            print(f"WARN: fsync failed on {COMPLETED_PATH}: {_oe}")
    try:
        after = COMPLETED_PATH.stat().st_size
        print(f"APPENDED completed: +{after-before} bytes at {COMPLETED_PATH}")
    except Exception as _se:
        print(f"WARN: stat failed on {COMPLETED_PATH}: {_se}")


def build_argv_from_job(job: dict, out_path: str) -> list[str]:
    # Allow passthrough args if provided
    if isinstance(job.get("args"), list):
        return ["examples/test.py", *[str(x) for x in job["args"]], "--quiet", "--json", out_path]

    # Defaults and mappings
    trials = int(job.get("trials", 200))
    seed = int(job.get("seed", 123))
    base_window_ns = float(job.get("base_window_ns", 16.0))
    classifier = str(job.get("classifier", "avg"))
    avg_frames = int(job.get("avg_frames", 1))

    def flag(b: bool, name: str):
        return [name] if b else []

    # Optionally merge overlay packs into vendor packs and write temp merged YAMLs
    tmp_dir = Path("queue/tmp")
    tmp_dir.mkdir(parents=True, exist_ok=True)

    def prepare_merged_pack(base_key: str, overlay_key: str, default_path: str, tag: str) -> str:
        base = str(job.get(base_key, default_path))
        over = str(job.get(overlay_key, ""))
        if not over:
            return base
        try:
            import yaml  # type: ignore
            base_d = {}
            over_d = {}
            if Path(base).exists():
                base_d = yaml.safe_load(Path(base).read_text(encoding="utf-8")) or {}
            if Path(over).exists():
                over_d = yaml.safe_load(Path(over).read_text(encoding="utf-8")) or {}
            merged = dict(base_d)
            merged.update(over_d)
            sig = hashlib.sha1(json.dumps({"b": base, "o": over}, sort_keys=True).encode("utf-8")).hexdigest()[:10]
            outp = tmp_dir / f"merged_{tag}_{sig}.yaml"
            outp.write_text(yaml.safe_dump(merged, sort_keys=False), encoding="utf-8")
            return str(outp)
        except ModuleNotFoundError:
            return base
        except Exception:
            return base

    optics_pack_path = prepare_merged_pack(
        "optics_pack", "optics_overlay",
        "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml", "optics"
    )
    comparator_pack_path = prepare_merged_pack(
        "comparator_pack", "comparator_overlay",
        "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml", "comp"
    )
    tia_pack_base = str(job.get("tia_pack", "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"))
    tia_pack_path = prepare_merged_pack("tia_pack", "tia_overlay", tia_pack_base, "tia")

    argv = [
        "examples/test.py",
        "--trials", str(trials),
        "--seed", str(seed),
        "--no-sweeps",
        "--no-drift",
        "--light-output",
        "--base-window-ns", str(base_window_ns),
        "--avg-frames", str(avg_frames),
        "--classifier", classifier,
        *flag(bool(job.get("apply_calibration", True)), "--apply-calibration"),
        *flag(bool(job.get("no_adaptive_input", True)), "--no-adaptive-input"),
        *flag(bool(job.get("neighbor_ct", False)), "--neighbor-ct"),
        *flag(bool(job.get("no_cold_input", True)), "--no-cold-input"),
        *flag(bool(job.get("no_path_b", True)), "--no-path-b"),
        "--path-b-depth", str(int(job.get("path_b_depth", 0))),
        *flag(bool(job.get("no_path_b_analog", True)), "--no-path-b-analog"),
        *flag(bool(job.get("lockin", False)), "--lockin"),
        *flag(bool(job.get("chop", False)), "--chop"),
        *flag(bool(job.get("mitigated", False)), "--mitigated"),
        *flag(bool(job.get("use_avg_frames_for_path_a", False)), "--use-avg-frames-for-path-a"),
        *flag(bool(job.get("normalize_dv", False)), "--normalize-dv"),
        # Masking controls
        "--mask-bad-frac", str(job.get("mask_bad_frac", 0.0)),
        "--mask-bad-channels", str(int(job.get("mask_bad_channels", 0))),
        "--calib-mask-trials", str(int(job.get("calib_mask_trials", 200))),
        *(["--mask-mode", str(job.get("mask_mode"))] if job.get("mask_mode") else []),
        # Comparator overrides
        *(["--comp-hysteresis-mV", str(job.get("comp_hysteresis_mV"))] if job.get("comp_hysteresis_mV") is not None else []),
        *(["--comp-input-noise-mV", str(job.get("comp_input_noise_mV"))] if job.get("comp_input_noise_mV") is not None else []),
        *(["--comp-vth-mV", str(job.get("comp_vth_mV"))] if job.get("comp_vth_mV") is not None else []),
        *(["--comp-vth-sigma-mV", str(job.get("comp_vth_sigma_mV"))] if job.get("comp_vth_sigma_mV") is not None else []),
        # Per-channel vth workflows
        *(["--export-vth", str(job.get("export_vth"))] if job.get("export_vth") else []),
        *(["--import-vth", str(job.get("import_vth"))] if job.get("import_vth") else []),
        *(["--vth-inline", str(job.get("vth_inline"))] if job.get("vth_inline") else []),
        *(["--vth-scale", str(job.get("vth_scale"))] if job.get("vth_scale") is not None else []),
        *(["--vth-bias-mV", str(job.get("vth_bias_mV"))] if job.get("vth_bias_mV") is not None else []),
        # Packs
        "--emitter-pack", str(job.get("emitter_pack", "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml")),
        "--optics-pack", optics_pack_path,
        "--sensor-pack", str(job.get("sensor_pack", "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml")),
        "--tia-pack", tia_pack_path,
        "--comparator-pack", comparator_pack_path,
        "--clock-pack", str(job.get("clock_pack", "configs/packs/clock_typ.yaml")),
        "--thermal-pack", str(job.get("thermal_pack", "configs/packs/thermal_typ.yaml")),
        "--quiet",
        "--json", out_path,
    ]
    return argv


def run_job(job: dict) -> dict:
    # Determine output path
    out_path = job.get("json_out")
    if not out_path:
        sig = job_signature(job)
        out_path = str(OUT_DIR / f"probe_{sig[:10]}.json")

    # RAW passthrough modes: job["raw"] string or job["cmd"] array
    if isinstance(job.get("cmd"), list):
        argv = ["examples/test.py", *[str(x) for x in job["cmd"]]]
        # Back-compat/arg hygiene: fix known flag typos and remove deprecated ones
        try:
            # Replace legacy '--gate-thresh-mv' with correct '--gate-thresh-mV'
            argv = ["--gate-thresh-mV" if x == "--gate-thresh-mv" else x for x in argv]
            # Remove '--gate-mode' and its value if present
            if "--gate-mode" in argv:
                gm_idx = argv.index("--gate-mode")
                # Drop flag and following value if any
                del argv[gm_idx: min(gm_idx+2, len(argv))]
        except Exception:
            pass
        # If overlays are provided on the job, append merged packs unless already present
        try:
            def has_flag(flag: str) -> bool:
                try:
                    return flag in argv
                except Exception:
                    return False

            # Reuse merge logic
            tmp_dir = Path("queue/tmp")
            tmp_dir.mkdir(parents=True, exist_ok=True)

            def prepare_merged_pack(base_key: str, overlay_key: str, default_path: str, tag: str) -> str:
                base = str(job.get(base_key, default_path))
                over = str(job.get(overlay_key, ""))
                if not over:
                    return base
                try:
                    import yaml  # type: ignore
                    base_d = {}
                    over_d = {}
                    if Path(base).exists():
                        base_d = yaml.safe_load(Path(base).read_text(encoding="utf-8")) or {}
                    if Path(over).exists():
                        over_d = yaml.safe_load(Path(over).read_text(encoding="utf-8")) or {}
                    merged = dict(base_d)
                    merged.update(over_d)
                    sig = hashlib.sha1(json.dumps({"b": base, "o": over}, sort_keys=True).encode("utf-8")).hexdigest()[:10]
                    outp = tmp_dir / f"merged_{tag}_{sig}.yaml"
                    outp.write_text(yaml.safe_dump(merged, sort_keys=False), encoding="utf-8")
                    return str(outp)
                except ModuleNotFoundError:
                    return base
                except Exception:
                    return base

            # Compute merged pack paths
            optics_pack_path = prepare_merged_pack(
                "optics_pack", "optics_overlay",
                "configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml", "optics"
            )
            comparator_pack_path = prepare_merged_pack(
                "comparator_pack", "comparator_overlay",
                "configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml", "comp"
            )
            tia_pack_base = str(job.get("tia_pack", "configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml"))
            tia_pack_path = prepare_merged_pack("tia_pack", "tia_overlay", tia_pack_base, "tia")

            # Append pack flags if not already provided in cmd
            if not has_flag("--optics-pack"):
                argv += ["--optics-pack", optics_pack_path]
            if not has_flag("--comparator-pack"):
                argv += ["--comparator-pack", comparator_pack_path]
            if not has_flag("--tia-pack"):
                argv += ["--tia-pack", tia_pack_path]
            if not has_flag("--emitter-pack"):
                argv += ["--emitter-pack", str(job.get("emitter_pack", "configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml"))]
            if not has_flag("--sensor-pack"):
                argv += ["--sensor-pack", str(job.get("sensor_pack", "configs/packs/vendors/sensors/vishay_BPW34_typ.yaml"))]
            if not has_flag("--clock-pack"):
                argv += ["--clock-pack", str(job.get("clock_pack", "configs/packs/clock_typ.yaml"))]
            if not has_flag("--thermal-pack"):
                argv += ["--thermal-pack", str(job.get("thermal_pack", "configs/packs/thermal_typ.yaml"))]
            # Support use_avg_frames_for_path_a via job key if requested
            if bool(job.get("use_avg_frames_for_path_a", False)) and not has_flag("--use-avg-frames-for-path-a"):
                argv += ["--use-avg-frames-for-path-a"]
        except Exception as _e_overlay:
            # Non-fatal: continue without overlays if something goes wrong
            pass
    elif isinstance(job.get("raw"), str):
        import shlex
        argv = ["examples/test.py", *shlex.split(job["raw"]) ]
    else:
        argv = build_argv_from_job(job, out_path)

    # Ensure JSON path present in argv
    if "--json" not in argv:
        argv += ["--quiet", "--json", out_path]
    # If job requests verbose, strip any --quiet flags so test.py prints
    try:
        if bool(job.get("verbose", False)):
            argv = [a for a in argv if a != "--quiet"]
    except Exception:
        pass

    # Execute examples/test.py by path to avoid package import issues
    prev_argv = sys.argv[:]
    _se_code = 0
    _se_error = None
    try:
        sys.argv = argv
        # Optionally suppress stdout from test.py to avoid huge prints
        import os as _os
        job_verbose = bool(job.get("verbose", False)) if isinstance(job, dict) else False
        suppress = False if job_verbose else (str(_os.environ.get("SUPPRESS_TEST_STDOUT", "1")).lower() in ("1","true","yes"))
        import traceback as _tb
        import sys as _sys
        import io as _io
        import contextlib as _ctx
        # Prepare stdout capture; if verbose, tee to console
        buf = _io.StringIO()
        class _Tee:
            def __init__(self, a, b):
                self.a = a; self.b = b
            def write(self, s):
                try:
                    self.a.write(s)
                except Exception:
                    pass
                return self.b.write(s)
            def flush(self):
                try:
                    self.a.flush()
                except Exception:
                    pass
                return self.b.flush()
        buf_err = _io.StringIO()
        try:
            if suppress:
                with _ctx.redirect_stdout(buf), _ctx.redirect_stderr(buf_err):
                    runpy.run_path("examples/test.py", run_name="__main__")
            else:
                tee_out = _Tee(_sys.__stdout__, buf)
                tee_err = _Tee(_sys.__stderr__, buf_err)
                with _ctx.redirect_stdout(tee_out), _ctx.redirect_stderr(tee_err):
                    runpy.run_path("examples/test.py", run_name="__main__")
        except SystemExit as _se:
            # Convert nonzero sys.exit from test.py into a regular error so main() can record and continue
            code = getattr(_se, 'code', 0)
            if code not in (None, 0):
                _se_code = int(code) if isinstance(code, int) else 1
                _se_error = f"test.py exited with code {code}\nSTDOUT:\n{buf.getvalue()}\nSTDERR:\n{buf_err.getvalue()}"
        except Exception as _e:
            # Attach traceback string to propagate to main()
            tb = _tb.format_exc()
            raise RuntimeError(f"test.py exception: {_e}\n{tb}\nSTDOUT:\n{buf.getvalue()}\nSTDERR:\n{buf_err.getvalue()}")
    finally:
        sys.argv = prev_argv
    # If test.py exited non-zero but produced JSON, accept it; otherwise raise
    out_file = Path(out_path)
    if _se_code not in (0, None) and not out_file.exists():
        raise RuntimeError(_se_error or f"test.py exited with code {_se_code}")
    data = json.loads(out_file.read_text(encoding="utf-8"))
    return {"out": out_path, "data": data}


def summarize(data: dict) -> dict:
    cfg = data.get("config") or {}
    base_cal = data.get("baseline_calibrated") or {}
    path_a = data.get("path_a") or {}
    return {
        "base_window_ns": cfg.get("base_window_ns"),
        "baseline_calibrated_p50_ber": base_cal.get("p50_ber"),
        "baseline_calibrated_p50_tokens_per_s": base_cal.get("p50_tokens_per_s"),
        "baseline_calibrated_p50_energy_pj": base_cal.get("p50_energy_pj"),
        "path_a_p50_ber": path_a.get("p50_ber"),
        "path_a_p50_energy_pj": path_a.get("p50_energy_pj"),
        "path_a_mean_ber": path_a.get("mean_ber"),
        "path_a_window_ns": path_a.get("window_ns"),
    }
def _play_idle_chime_once() -> None:
    """Play a small, mild chime when entering idle. Best-effort, Windows-first.

    Controlled by env IDLE_CHIME (default: on). Set IDLE_CHIME=0 to disable.
    """
    if str(os.environ.get("IDLE_CHIME", "1")).lower() in ("0", "false", "no"):
        return
    try:
        import winsound  # type: ignore
        mode = str(os.environ.get("IDLE_BEEP", "")).lower()
        if mode in ("1", "true", "yes", "beep"):
            # Explicit simple beep (audible on most Windows systems)
            winsound.Beep(800, 120)  # 800 Hz, 120 ms
        else:
            # Mild system chime; if silent on this host, optionally follow with a short beep
            winsound.MessageBeep(getattr(winsound, "MB_ICONASTERISK", 0))
            if str(os.environ.get("IDLE_FALLBACK_BEEP", "1")).lower() in ("1","true","yes"):
                try:
                    winsound.Beep(800, 80)
                except Exception:
                    pass
        return
    except Exception:
        pass
    # Fallback: ASCII bell (may be ignored on some terminals)
    try:
        print("\a", end="", flush=True)
    except Exception:
        pass



def main():
    ensure_paths()
    print(f"probe_queue_runner: watching queue={QUEUE_PATH}")
    print(f"probe_queue_runner: writing completed to {COMPLETED_PATH}")
    last_status = None
    last_idle = None
    while True:
        # Always reload completed_ok from disk; if file doesn't exist or is empty, treat as empty set
        try:
            sig_done = load_completed_signatures()
        except Exception as e:
            print(f"WARN: failed to read completed file: {e}")
            sig_done = set()
        try:
            text = QUEUE_PATH.read_text(encoding="utf-8")
            lines = text.splitlines()
        except Exception as e:
            print(f"WARN: failed to read queue file: {e}")
            lines = []
        status_msg = f"STATUS: queue_lines={len(lines)} completed_ok={len(sig_done)}"
        if status_msg != last_status:
            print(status_msg)
            last_status = status_msg
        ran_one = False
        quiet_skips = str(os.environ.get("QUIET_SKIPS", "1")).lower() in ("1","true","yes")
        skip_count = 0
        for idx, raw in enumerate(lines):
            raw = raw.strip()
            if not raw or raw.startswith("#"):
                if raw and not quiet_skips:
                    print(f"SKIP[{idx}]: comment/blank")
                continue
            try:
                job = json.loads(raw)
            except json.JSONDecodeError as je:
                if not quiet_skips:
                    preview = raw[:120].replace('\n',' ')
                    print(f"SKIP[{idx}]: json error {je} in '{preview}...'")
                continue
            sig = job_signature(job)
            # Skip if this signature is already present in completed.jsonl
            if sig in sig_done:
                if quiet_skips:
                    skip_count += 1
                else:
                    print(f"SKIP[{idx}]: already completed ok sig={sig[:8]}")
                continue
            started_at = datetime.utcnow().isoformat() + "Z"
            try:
                res = run_job(job)
                summ = summarize(res["data"]) if isinstance(res, dict) else {}
                append_completed({
                    "signature": sig,
                    "finished_at": datetime.utcnow().isoformat() + "Z",
                    "out": res.get("out"),
                    "summary": summ,
                    "status": "ok",
                })
                print(f"DONE {sig[:8]} -> {res.get('out')} {summ}")
            except Exception as e:
                append_completed({
                    "signature": sig,
                    "started_at": started_at,
                    "finished_at": datetime.utcnow().isoformat() + "Z",
                    "error": str(e),
                    "traceback": getattr(e, 'args', [None])[-1] if e.args else None,
                    "job": job,
                    "status": "error",
                })
                print(f"ERROR {sig[:8]} {e}")
            # Do NOT remove lines; probes.jsonl remains static. Rely solely on completed.jsonl for skipping.
            try:
                # Show updated completed_ok for visibility
                new_done = load_completed_signatures()
                print(f"UPDATED: completed_ok={len(new_done)}")
            except Exception as _e2:
                print(f"WARN: failed to reload completed: {_e2}")
            if quiet_skips and skip_count:
                print(f"SKIPPED {skip_count} already-completed entries (quiet)")
            ran_one = True
            break  # Process only one job per loop
        # Sleep briefly; if we ran one job, loop immediately to check for more
        if not ran_one:
            if quiet_skips and skip_count:
                idle_msg = f"IDLE: sleeping 2s (quiet; {skip_count} skips)"
            else:
                idle_msg = "IDLE: sleeping 2s"
            if idle_msg != last_idle:
                print(idle_msg)
                # Play a small chime once and log it before the separator
                _play_idle_chime_once()
                try:
                    print("[idle chime]\n==================")
                except Exception:
                    print("==================")
                last_idle = idle_msg
            time.sleep(2.0)


def _run_forever():
    import time as _t
    while True:
        try:
            main()
        except SystemExit as _se:
            code = getattr(_se, 'code', 0)
            if code not in (None, 0):
                print(f"WARN: main exited with code {code}, restarting in 1s")
            _t.sleep(1.0)
            continue
        except Exception as _e:
            print(f"WARN: main crashed: {_e}; restarting in 1s")
            _t.sleep(1.0)
            continue

if __name__ == "__main__":
    _run_forever()






-----------------------

.\scripts\collect_once.py
import sys
import time
import json
from pathlib import Path


def print_one_result(json_path: Path) -> int:
    # Wait up to 15s for the file
    for _ in range(15):
        if json_path.exists():
            break
        time.sleep(1)
    if not json_path.exists():
        print(f"MISSING {json_path}")
        return 1
    try:
        data = json.loads(json_path.read_text(encoding="utf-8"))
    except Exception as e:
        print(f"ERR reading {json_path}: {e}")
        return 1
    cfg = data.get("config") or {}
    base_cal = data.get("baseline_calibrated") or {}
    pa = data.get("path_a") or {}
    print(
        "file=", json_path,
        "win=", cfg.get("base_window_ns"),
        "base_cal.p50_ber=", base_cal.get("p50_ber"),
        "path_a.p50_ber=", pa.get("p50_ber"),
    )
    return 0


def print_completed(after_sig: str | None = None,
                    match_sub: str | None = None,
                    limit: int | None = None,
                    unique: bool = True,
                    csv: bool = False,
                    include_errors: bool = False) -> int:
    comp_path = Path('queue/completed.jsonl')
    if not comp_path.exists():
        print(f"MISSING {comp_path}")
        return 1
    lines = comp_path.read_text(encoding='utf-8').splitlines()
    started = (after_sig is None)
    count = 0
    seen: set[tuple[str, str]] = set()
    if csv:
        print("sig8,out,win,base_cal_p50_ber,path_a_p50_ber")
    for raw in lines:
        raw = raw.strip()
        if not raw:
            continue
        try:
            rec = json.loads(raw)
        except json.JSONDecodeError:
            continue
        sig = str(rec.get('signature') or '')
        outp = str(rec.get('out') or '')
        summ = rec.get('summary') or {}
        # Skip incomplete/error records unless requested
        if not include_errors and (not outp or not isinstance(summ, dict) or 'path_a_p50_ber' not in summ):
            continue
        if not started:
            if sig.startswith(after_sig):
                started = True
            continue
        if match_sub and (match_sub not in outp):
            continue
        key = (sig, outp)
        if unique and key in seen:
            continue
        seen.add(key)
        if csv:
            print(
                f"{sig[:8]},{outp},{summ.get('base_window_ns')},{summ.get('baseline_calibrated_p50_ber')},{summ.get('path_a_p50_ber')}"
            )
        else:
            print(
                "sig=", sig[:8],
                "out=", outp,
                "win=", summ.get('base_window_ns'),
                "base_cal.p50_ber=", summ.get('baseline_calibrated_p50_ber'),
                "path_a.p50_ber=", summ.get('path_a_p50_ber'),
            )
        count += 1
        if limit is not None and count >= limit:
            break
    return 0


def main():
    # Modes:
    # 1) collect_once.py out/<file>.json  -> summarize one JSON
    # 2) collect_once.py                  -> dump all completed.jsonl shorthand
    #    optional: --after SIG_PREFIX  --match SUBSTR  --limit N  [--no-unique] [--csv] [--include-errors]
    if len(sys.argv) >= 2 and sys.argv[1].endswith('.json'):
        sys.exit(print_one_result(Path(sys.argv[1])))

    after_sig = None
    match_sub = None
    limit = None
    args = sys.argv[1:]
    i = 0
    unique = True
    csv = False
    include_errors = False
    while i < len(args):
        a = args[i]
        if a == '--after' and i+1 < len(args):
            after_sig = args[i+1]
            i += 2
        elif a == '--match' and i+1 < len(args):
            match_sub = args[i+1]
            i += 2
        elif a == '--limit' and i+1 < len(args):
            try:
                limit = int(args[i+1])
            except ValueError:
                limit = None
            i += 2
        elif a == '--no-unique':
            unique = False
            i += 1
        elif a == '--csv':
            csv = True
            i += 1
        elif a == '--include-errors':
            include_errors = True
            i += 1
        else:
            i += 1
    sys.exit(print_completed(after_sig=after_sig, match_sub=match_sub, limit=limit, unique=unique, csv=csv, include_errors=include_errors))


if __name__ == "__main__":
    main()





-----------------------

.\scripts\append_tuned_probes.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320',
        '--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--normalize-dv',
        '--calib-mask-trials','240','--calib-samples','400',
        '--base-window-ns','19.0',
        '--classifier','avg','--avg-frames','11',
    ]

    def J(seed: int, mask: float, tia_overlay: str, win: str = '19.0') -> dict:
        cmd = list(base)
        cmd[cmd.index('--base-window-ns')+1] = win
        cmd += ['--seed', str(seed), '--mask-bad-frac', str(mask)]
        return {
            'cmd': cmd,
            'optics_overlay': 'configs/packs/overlays/optics_low_ct.yaml',
            'comparator_overlay': 'configs/packs/overlays/tuned_comparator.yaml',
            'tia_overlay': tia_overlay,
            'json_out': f"out/tuned_w{win.replace('.', 'p')}_avg11_m{mask}_s{seed}.json",
            'label': f"tuned_w{win}_avg11_m{mask}_s{seed}",
        }

    jobs = [
        J(5091, 0.09375, 'configs/packs/overlays/tuned_tia.yaml', '19.0'),
        J(5092, 0.0625,  'configs/packs/overlays/tuned_tia.yaml', '19.0'),
        J(5093, 0.09375, 'configs/packs/overlays/tia_12k_65.yaml', '19.0'),
        J(5094, 0.0625,  'configs/packs/overlays/tia_12k_65.yaml', '19.0'),
        J(5095, 0.09375, 'configs/packs/overlays/tuned_tia.yaml',  '18.0'),
        J(5096, 0.0625,  'configs/packs/overlays/tuned_tia.yaml',  '18.0'),
    ]

    with queue.open('a', encoding='utf-8') as f:
        for job in jobs:
            f.write(json.dumps(job, separators=(',', ':')) + '\n')
    print(f'appended {len(jobs)} tuned jobs to {queue}')


if __name__ == '__main__':
    main()






-----------------------

.\scripts\append_focus19_probes.py
from __future__ import annotations
import json
from pathlib import Path

def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--base-window-ns','19.0','--classifier','chop','--avg-frames','3',
        '--mask-bad-frac','0.09375',
    ]

    def J(seed: int, extra: list[str]) -> dict:
        return {
            'cmd': base + ['--seed', str(seed)] + extra,
            'optics_overlay': 'configs/packs/overlays/optics_low_ct.yaml',
            'comparator_overlay': 'configs/packs/overlays/tuned_comparator.yaml',
            'tia_overlay': 'configs/packs/overlays/tuned_tia.yaml',
            'json_out': f'out/focus19_chop_avg3_m09375_s{seed}.json',
            'label': f'focus19_chop_avg3_m09375_s{seed}',
        }

    jobs = [
        J(6001, []),
        J(6002, ['--force-cal-in-primary']),
        J(6003, ['--force-cal-in-primary','--gate-thresh-mV','0.6','--gate-extra-frames','1']),
        J(6004, ['--force-cal-in-primary','--gate-thresh-mV','1.0','--gate-extra-frames','2']),
        J(6005, ['--force-cal-in-primary','--optimize-vth','--opt-vth-iters','3','--opt-vth-step-mV','0.1','--opt-vth-use-mask']),
        J(6006, ['--force-cal-in-primary','--optimize-linear','--opt-lin-iters','4','--opt-lin-step-mV','0.1','--opt-lin-use-mask']),
        J(6007, ['--force-cal-in-primary','--optimize-vth','--opt-vth-iters','3','--opt-vth-step-mV','0.1','--opt-vth-use-mask','--optimize-linear','--opt-lin-iters','4','--opt-lin-step-mV','0.1','--opt-lin-use-mask']),
        J(6008, ['--force-cal-in-primary','--gate-thresh-mV','0.6','--gate-extra-frames','1','--optimize-linear','--opt-lin-iters','3','--opt-lin-step-mV','0.08','--opt-lin-use-mask']),
    ]

    with queue.open('a', encoding='utf-8') as f:
        for job in jobs:
            f.write(json.dumps(job, separators=(',', ':')) + '\n')
    print(f'appended {len(jobs)} focus19 jobs to {queue}')

if __name__ == '__main__':
    main()




-----------------------

.\scripts\append_parallel_focus.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    classifiers = ['chop', 'lockin']
    windows = ['18.8', '19.0', '19.2']
    avg_frames = ['2', '3', '4']
    masks = ['0.085', '0.09375', '0.11']

    base_common = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
    ]

    def mk_job(seed: int, cls: str, win: str, avg: str, mask: str, extra: list[str] | None = None) -> dict:
        cmd = list(base_common)
        cmd += ['--base-window-ns', win, '--classifier', cls, '--avg-frames', avg, '--mask-bad-frac', mask, '--seed', str(seed)]
        if extra:
            cmd += extra
        label = f"par_{cls}_w{win.replace('.', 'p')}_avg{avg}_m{mask}_s{seed}"
        return {
            'cmd': cmd,
            'optics_overlay': 'configs/packs/overlays/optics_low_ct.yaml',
            'comparator_overlay': 'configs/packs/overlays/tuned_comparator.yaml',
            'tia_overlay': 'configs/packs/overlays/tuned_tia.yaml',
            'json_out': f"out/{label}.json",
            'label': label,
        }

    jobs: list[dict] = []
    seed_base = 7000
    idx = 0
    # Base grid (no gating, no force-cal)
    for cls in classifiers:
        for win in windows:
            for avg in avg_frames:
                for mask in masks:
                    jobs.append(mk_job(seed_base + idx, cls, win, avg, mask))
                    idx += 1
    # Lite gating only for avg3
    for cls in classifiers:
        for win in windows:
            for mask in masks:
                jobs.append(mk_job(seed_base + idx, cls, win, '3', mask, extra=['--gate-thresh-mV','0.6','--gate-extra-frames','1']))
                idx += 1

    with queue.open('a', encoding='utf-8') as f:
        for job in jobs:
            f.write(json.dumps(job, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} parallel focus jobs to {queue}")


if __name__ == '__main__':
    main()






-----------------------

.\scripts\append_sweep2.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base_common = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--base-window-ns','19.0',  # default; will override per job
    ]

    def mk_job(seed: int, cls: str, win: str, avg: str, mask: str, extra: list[str] | None = None) -> dict:
        cmd = list(base_common)
        cmd += ['--base-window-ns', win, '--classifier', cls, '--avg-frames', avg, '--mask-bad-frac', mask, '--seed', str(seed)]
        if extra:
            cmd += extra
        label = f"s2_{cls}_w{win.replace('.', 'p')}_avg{avg}_m{mask}_s{seed}"
        return {
            'cmd': cmd,
            'optics_overlay': 'configs/packs/overlays/optics_low_ct.yaml',
            'comparator_overlay': 'configs/packs/overlays/tuned_comparator.yaml',
            'tia_overlay': 'configs/packs/overlays/tuned_tia.yaml',
            'json_out': f"out/{label}.json",
            'label': label,
        }

    windows = ['18.8','19.0','19.2']
    avgs = ['2','3','4']
    # finer mask sweep around best
    masks = [
        '0.07','0.075','0.08','0.085','0.09','0.09375','0.10','0.105','0.11'
    ]

    jobs: list[dict] = []
    seeds = [8000, 8001]

    # Primary: chop generous sweep
    for seed in seeds:
        for win in windows:
            for avg in avgs:
                for mask in masks:
                    jobs.append(mk_job(seed, 'chop', win, avg, mask))
    # Lite gating only for avg3
    for seed in seeds:
        for win in windows:
            for mask in masks:
                jobs.append(mk_job(seed, 'chop', win, '3', mask, extra=['--gate-thresh-mV','0.6','--gate-extra-frames','1']))
                jobs.append(mk_job(seed, 'chop', win, '3', mask, extra=['--gate-thresh-mV','1.0','--gate-extra-frames','2']))

    # Control slice for lockin (narrower, avg2/3 only)
    for seed in seeds:
        for win in windows:
            for avg in ['2','3']:
                for mask in masks:
                    jobs.append(mk_job(seed, 'lockin', win, avg, mask))

    with queue.open('a', encoding='utf-8') as f:
        for job in jobs:
            f.write(json.dumps(job, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} sweep2 jobs to {queue}")


if __name__ == '__main__':
    main()







-----------------------

.\scripts\append_sweep3.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--normalize-dv',
        '--no-adaptive-input','--no-cold-input','--no-path-b',
        '--path-b-depth','0','--no-path-b-analog',
    ]

    def mk_job(name: str, extra: list[str]) -> dict:
        cmd = list(base) + extra
        return {
            'cmd': cmd,
            'optics_overlay': 'configs/packs/overlays/optics_low_ct.yaml',
            'comparator_overlay': 'configs/packs/overlays/tuned_comparator.yaml',
            'tia_overlay': 'configs/packs/overlays/tuned_tia.yaml',
            'json_out': f"out/{name}.json",
            'label': name,
        }

    windows = ['18.9','19.0','19.1']
    masks = ['0.085','0.09','0.09375','0.10']

    jobs: list[dict] = []
    seed = 9100

    # Force calibrated corrections into primary via existing path flags in test.py
    # Sweep chop with avg3 base and small gating variants
    for w in windows:
        for m in masks:
            name = f"s3_calnorm_chop_w{w.replace('.', 'p')}_avg3_m{m}_s{seed}"
            extra = ['--base-window-ns', w, '--classifier', 'chop', '--avg-frames','3', '--mask-bad-frac', m, '--seed', str(seed)]
            jobs.append(mk_job(name, extra))
            # lite gating variants
            for gt, ge in [('0.6','1'), ('1.0','2')]:
                gname = f"{name}_gate{gt.replace('.', 'p')}e{ge}"
                gextra = extra + ['--gate-thresh-mV', gt, '--gate-extra-frames', ge]
                jobs.append(mk_job(gname, gextra))

    # Lockin controls avg2
    for w in windows:
        for m in masks:
            name = f"s3_calnorm_lockin_w{w.replace('.', 'p')}_avg2_m{m}_s{seed}"
            extra = ['--base-window-ns', w, '--classifier', 'lockin', '--avg-frames','2', '--mask-bad-frac', m, '--seed', str(seed)]
            jobs.append(mk_job(name, extra))

    with queue.open('a', encoding='utf-8') as f:
        for job in jobs:
            f.write(json.dumps(job, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} sweep3 jobs to {queue}")


if __name__ == '__main__':
    main()







-----------------------

.\scripts\append_stage_ab_probes.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    # Shared baseline args for quick convergence sweeps
    base_common = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
    ]

    windows = ['18.9','19.0','19.1']
    masks = ['0.09125','0.09375']
    avg_opts = ['2','3']

    # Overlays for Stage A and Stage B
    optics_A = 'configs/packs/overlays/optics_stage_a_hygiene.yaml'
    comp_T = 'configs/packs/overlays/tuned_comparator.yaml'
    comp_C = 'configs/packs/overlays/comparator_stage_c_trims.yaml'
    tia_T = 'configs/packs/overlays/tuned_tia.yaml'
    tia_B = 'configs/packs/overlays/tia_stage_b_low_noise.yaml'

    def mk_job(label_prefix: str, seed: int, win: str, avg: str, mask: str,
               optics_overlay: str, tia_overlay: str, gating: tuple[str,str] | None = None,
               force_cal_in_primary: bool = False, normalize: bool = False,
               vth_opt: bool = False, cls: str = 'chop', mask_mode: str | None = None,
               extra: list[str] | None = None) -> dict:
        cmd = list(base_common)
        cmd += ['--base-window-ns', win, '--classifier', cls, '--avg-frames', avg,
                '--mask-bad-frac', mask, '--seed', str(seed)]
        if force_cal_in_primary:
            cmd += ['--force-cal-in-primary']
        if normalize:
            cmd += ['--normalize-dv']
        if vth_opt:
            cmd += ['--optimize-vth','--opt-vth-iters','2','--opt-vth-step-mV','0.2','--opt-vth-use-mask']
        if mask_mode:
            cmd += ['--mask-mode', mask_mode]
        if gating:
            gt, ge = gating
            cmd += ['--gate-thresh-mV', gt, '--gate-extra-frames', ge]
        if extra:
            cmd += extra
        label = f"{label_prefix}_{cls}_w{win.replace('.', 'p')}_avg{avg}_m{mask}_s{seed}"
        if force_cal_in_primary:
            label += '_fcip'
        if normalize:
            label += '_norm'
        if vth_opt:
            label += '_vthopt'
        if mask_mode:
            label += f"_mm{mask_mode}"
        if gating:
            gt, ge = gating
            label += f"_g{gt.replace('.','p')}e{ge}"
        if extra:
            # crude tag for select extras
            if '--deblur-neigh-alpha' in extra:
                label += '_deblur'
            if '--use-map-thresh' in extra:
                label += '_map'
            if '--decoder-linear' in extra:
                label += '_dec'
            if '--use-ecc' in extra:
                label += '_ecc'
        return {
            'cmd': cmd,
            'optics_overlay': optics_A,
            'comparator_overlay': comp_T,
            'tia_overlay': tia_overlay,
            'json_out': f"out/{label}.json",
            'label': label,
        }

    jobs: list[dict] = []

    # Stage A: optics hygiene with tuned TIA
    seed_base = 8200
    for win in windows:
        for avg in avg_opts:
            for mask in masks:
                jobs.append(mk_job('stageA', seed_base, win, avg, mask, optics_A, tia_T, None))
                jobs.append(mk_job('stageA', seed_base+1, win, avg, mask, optics_A, tia_T, ('0.8','1')))
        seed_base += 10

    # Stage B: low-noise TIA overlay with Stage A optics
    for win in windows:
        for avg in avg_opts:
            for mask in masks:
                jobs.append(mk_job('stageB', seed_base, win, avg, mask, optics_A, tia_B, None))
                jobs.append(mk_job('stageB', seed_base+1, win, avg, mask, optics_A, tia_B, ('0.6','1')))
        seed_base += 10

    # Follow-up: force cal in primary + normalize, with lite gating
    for win in ['19.0']:
        for avg in ['2','3']:
            for mask in masks:
                jobs.append(mk_job('stageA_fup', seed_base, win, avg, mask, optics_A, tia_T, ('0.8','1'), True, True))
                jobs.append(mk_job('stageB_fup', seed_base+1, win, avg, mask, optics_A, tia_B, ('0.6','1'), True, True))
        seed_base += 10

    # Focused tuning at 19.0 ns, avg3, masks with lite gating and small vth optimizer subset
    for mask in masks:
        for gt, ge in [('0.6','1'),('0.8','1'),('1.0','2')]:
            jobs.append(mk_job('stageA_tune', seed_base, '19.0', '3', mask, optics_A, tia_T, (gt, ge)))
            jobs.append(mk_job('stageB_tune', seed_base+1, '19.0', '3', mask, optics_A, tia_B, (gt, ge)))
        jobs.append(mk_job('stageA_tune', seed_base+2, '19.0', '3', mask, optics_A, tia_T, None, False, False, True))
        jobs.append(mk_job('stageB_tune', seed_base+3, '19.0', '3', mask, optics_A, tia_B, None, False, False, True))
        seed_base += 10

    # Tune2: force-cal-in-primary only (no normalize), compare chop vs avg, dvspan mask, and avg4
    for mask in masks:
        for cls in ['chop','avg']:
            jobs.append(mk_job('tune2', seed_base, '19.0', '3', mask, optics_A, tia_T, ('0.8','1'), True, False, False, cls, None))
            jobs.append(mk_job('tune2', seed_base+1, '19.0', '3', mask, optics_A, tia_T, ('0.8','1'), True, False, False, cls, 'dvspan'))
            jobs.append(mk_job('tune2', seed_base+2, '19.0', '4', mask, optics_A, tia_T, ('0.8','1'), True, False, False, cls, None))
        for cls in ['chop','avg']:
            jobs.append(mk_job('tune2B', seed_base+3, '19.0', '3', mask, optics_A, tia_B, ('0.6','1'), True, False, False, cls, None))
            jobs.append(mk_job('tune2B', seed_base+4, '19.0', '3', mask, optics_A, tia_B, ('0.6','1'), True, False, False, cls, 'dvspan'))
            jobs.append(mk_job('tune2B', seed_base+5, '19.0', '4', mask, optics_A, tia_B, ('0.6','1'), True, False, False, cls, None))
        seed_base += 10

    # Diverse mini-suite (compact): probe deblur, MAP, and decoder/ECC interactions
    diverse = [
        # Deblur light touch
        ('divA', tia_T, ['--deblur-neigh-alpha','0.15']),
        ('divB', tia_B, ['--deblur-neigh-alpha','0.15']),
        # MAP thresholding (uses comparator sigma)
        ('mapA', tia_T, ['--use-map-thresh']),
        ('mapB', tia_B, ['--use-map-thresh']),
        # Linear decoder + ECC with small samples
        ('decA', tia_T, ['--decoder-linear','--decoder-l2','1e-3','--decoder-samples','200','--use-ecc','--ecc-spc-block','4']),
        ('decB', tia_B, ['--decoder-linear','--decoder-l2','1e-3','--decoder-samples','200','--use-ecc','--ecc-spc-block','4']),
    ]
    for tag, tia, extra in diverse:
        # One seed, one mask, fixed 19.0 ns, avg3, chop; lite gating moderate
        jobs.append(mk_job(tag, seed_base, '19.0', '3', '0.09375', optics_A, tia, ('0.8','1'), False, False, False, 'chop', None, extra))
        # And an avg variant without gating
        jobs.append(mk_job(tag, seed_base+1, '19.0', '3', '0.09375', optics_A, tia, None, False, False, False, 'avg', None, extra))
    seed_base += 10

    # Compact Stage C and E probes to quantify gains vs Stage A/B
    optics_E = 'configs/packs/overlays/optics_stage_e_power_mod.yaml'
    for cls in ['chop']:
        # Stage C: comparator trims with tuned TIA
        jobs.append({
            'cmd': base_common + ['--base-window-ns','19.0','--classifier',cls,'--avg-frames','3','--mask-bad-frac','0.09375','--seed','8360','--gate-thresh-mV','0.8','--gate-extra-frames','1'],
            'optics_overlay': optics_A,
            'comparator_overlay': comp_C,
            'tia_overlay': tia_T,
            'json_out': 'out/stageC_chop_w19p0_avg3_m0.09375_s8360_g0p8e1.json',
            'label': 'stageC_chop_w19p0_avg3_m0.09375_s8360_g0p8e1',
        })
        # Stage E: power/modulation boost with low-noise TIA
        jobs.append({
            'cmd': base_common + ['--base-window-ns','19.0','--classifier',cls,'--avg-frames','3','--mask-bad-frac','0.09375','--seed','8361','--gate-thresh-mV','0.6','--gate-extra-frames','1'],
            'optics_overlay': optics_E,
            'comparator_overlay': comp_T,
            'tia_overlay': tia_B,
            'json_out': 'out/stageE_chop_w19p0_avg3_m0.09375_s8361_g0p6e1.json',
            'label': 'stageE_chop_w19p0_avg3_m0.09375_s8361_g0p6e1',
        })

    # Mini3: compact diverse set  lockin vs chop, small window shifts, stronger gating
    for tia, tag in [(tia_T, 'mini3A'), (tia_B, 'mini3B')]:
        for win in ['18.95','19.05']:
            for cls in ['chop','lockin']:
                # avg3 with stronger gating
                jobs.append(mk_job(tag, seed_base, win, '3', '0.09375', optics_A, tia, ('1.2','2'), False, False, False, cls))
                jobs.append(mk_job(tag, seed_base+1, win, '3', '0.09375', optics_A, tia, ('0.8','1'), False, False, False, cls))
                # avg2 with modest gating
                jobs.append(mk_job(tag, seed_base+2, win, '2', '0.09375', optics_A, tia, ('1.0','1'), False, False, False, cls))
            seed_base += 10

    with queue.open('a', encoding='utf-8') as f:
        for job in jobs:
            f.write(json.dumps(job, separators=(',', ':')) + '\n')
    print(f'appended {len(jobs)} Stage A/B jobs to {queue}')


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_min_combo_hardware.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
    ]

    optics_E = 'configs/packs/overlays/optics_stage_e_power_mod.yaml'
    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    optics_F = 'configs/packs/overlays/optics_stage_f_amp.yaml'
    optics_G = 'configs/packs/overlays/optics_stage_g_saturable.yaml'
    comp_C = 'configs/packs/overlays/comparator_stage_c_trims.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_B = 'configs/packs/overlays/tia_stage_b_low_noise.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    tia_B3 = 'configs/packs/overlays/tia_stage_b3_precision.yaml'
    comp_C3 = 'configs/packs/overlays/comparator_stage_c3_precision.yaml'

    def job(seed: int, win: str, avg: str, mask: str, gate: tuple[str,str]) -> dict:
        cmd = list(base)
        cmd += ['--base-window-ns', win, '--classifier', 'chop', '--avg-frames', avg,
                '--mask-bad-frac', mask, '--seed', str(seed),
                '--gate-thresh-mV', gate[0], '--gate-extra-frames', gate[1]]
        label = f"comboBCE_w{win.replace('.', 'p')}_avg{avg}_m{mask}_s{seed}_g{gate[0].replace('.', 'p')}e{gate[1]}"
        return {
            'cmd': cmd,
            'optics_overlay': optics_E,
            'comparator_overlay': comp_C,
            'tia_overlay': tia_B,
            'json_out': f"out/{label}.json",
            'label': label,
        }

    jobs = [
        job(8370, '19.0', '3', '0.09375', ('0.6','1')),
        job(8371, '19.0', '2', '0.09375', ('1.0','1')),
        job(8372, '18.95', '3', '0.09125', ('0.8','1')),
        job(8373, '19.05', '3', '0.09125', ('1.0','2')),
    ]

    # Stronger combo variants
    for seed, opt, cmpo, tia in [
        (8380, optics_E2, comp_C, tia_B),
        (8381, optics_E, comp_C2, tia_B),
        (8382, optics_E, comp_C, tia_B2),
        (8383, optics_E2, comp_C2, tia_B2),
        # New simulated hardware: amp and saturable absorber, precision comp/TIA
        (8384, optics_F, comp_C3, tia_B3),
        (8385, optics_G, comp_C3, tia_B3),
    ]:
        cmd = list(base)
        cmd += ['--base-window-ns','19.0','--classifier','chop','--avg-frames','3','--mask-bad-frac','0.09375','--seed',str(seed),'--gate-thresh-mV','0.6','--gate-extra-frames','1']
        label = f"comboStrong_w19p0_avg3_m0.09375_s{seed}_g0p6e1"
        jobs.append({
            'cmd': cmd,
            'optics_overlay': opt,
            'comparator_overlay': cmpo,
            'tia_overlay': tia,
            'json_out': f"out/{label}.json",
            'label': label,
        })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} Stage B+C+E combo jobs to {queue}")


if __name__ == '__main__':
    main()



-----------------------

.\scripts\append_hw_tuning_suite.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
    ]

    optics_A = 'configs/packs/overlays/optics_stage_a_hygiene.yaml'
    optics_E = 'configs/packs/overlays/optics_stage_e_power_mod.yaml'
    comp_T = 'configs/packs/overlays/tuned_comparator.yaml'
    comp_C = 'configs/packs/overlays/comparator_stage_c_trims.yaml'
    tia_T = 'configs/packs/overlays/tuned_tia.yaml'
    tia_B = 'configs/packs/overlays/tia_stage_b_low_noise.yaml'

    sets = [
        ('stageC', optics_A, comp_C, tia_T, '19.0', '3', '0.09375', ('0.8','1'), 8400),
        ('stageE', optics_E, comp_T, tia_B, '19.0', '3', '0.09375', ('0.6','1'), 8401),
        ('stageBC', optics_A, comp_C, tia_B, '19.0', '3', '0.09375', ('0.6','1'), 8402),
        ('stageCE', optics_E, comp_C, tia_T, '19.0', '3', '0.09375', ('0.8','1'), 8403),
        ('stageBCE', optics_E, comp_C, tia_B, '19.0', '3', '0.09375', ('0.6','1'), 8404),
        ('stageBCE', optics_E, comp_C, tia_B, '18.95', '3', '0.09375', ('0.6','1'), 8405),
        ('stageBCE', optics_E, comp_C, tia_B, '19.05', '3', '0.09375', ('0.6','1'), 8406),
        ('stageBCE', optics_E, comp_C, tia_B, '19.0', '2', '0.09375', ('1.0','1'), 8407),
    ]

    jobs: list[dict] = []
    for tag, opt, comp, tia, win, avg, mask, gate, seed in sets:
        cmd = list(base)
        cmd += ['--base-window-ns', win, '--classifier', 'chop', '--avg-frames', avg,
                '--mask-bad-frac', mask, '--seed', str(seed),
                '--gate-thresh-mV', gate[0], '--gate-extra-frames', gate[1]]
        label = f"{tag}_w{win.replace('.', 'p')}_avg{avg}_m{mask}_s{seed}_g{gate[0].replace('.', 'p')}e{gate[1]}"
        jobs.append({
            'cmd': cmd,
            'optics_overlay': opt,
            'comparator_overlay': comp,
            'tia_overlay': tia,
            'json_out': f"out/{label}.json",
            'label': label,
        })

    # Refine suite: override comparator noise/sigma/hysteresis minimally on the best combo (BCE)
    refine = [
        ('n0p28_s0p12_h0p5', {'--comp-input-noise-mV':'0.28','--comp-vth-sigma-mV':'0.12','--comp-hysteresis-mV':'0.5'}),
        ('n0p24_s0p10_h0p6', {'--comp-input-noise-mV':'0.24','--comp-vth-sigma-mV':'0.10','--comp-hysteresis-mV':'0.6'}),
        ('n0p32_s0p15_h0p7', {'--comp-input-noise-mV':'0.32','--comp-vth-sigma-mV':'0.15','--comp-hysteresis-mV':'0.7'}),
    ]
    for tag, overrides in refine:
        cmd = list(base)
        cmd += ['--base-window-ns','19.0','--classifier','chop','--avg-frames','3',
                '--mask-bad-frac','0.09375','--seed','8410','--gate-thresh-mV','0.6','--gate-extra-frames','1']
        for k,v in overrides.items():
            cmd += [k, v]
        label = f"stageBCE_refine_{tag}_w19p0_avg3_m0.09375_s8410_g0p6e1"
        jobs.append({
            'cmd': cmd,
            'optics_overlay': optics_E,
            'comparator_overlay': comp_C,
            'tia_overlay': tia_B,
            'json_out': f"out/{label}.json",
            'label': label,
        })

    # Refine2: Stage C/E combos, masks {0.09375, 0.10}, gating {(0.8,1),(1.2,2)}, plus one avg4 and one vth-opt
    for mask in ['0.09375','0.10']:
        for gate in [('0.8','1'),('1.2','2')]:
            # Stage C
            cmd = list(base) + ['--base-window-ns','19.0','--classifier','chop','--avg-frames','3','--mask-bad-frac',mask,'--seed','8420','--gate-thresh-mV',gate[0],'--gate-extra-frames',gate[1]]
            jobs.append({'cmd': cmd,'optics_overlay': optics_A,'comparator_overlay': comp_C,'tia_overlay': tia_T,'json_out': f"out/ref2_stageC_m{mask}_g{gate[0].replace('.','p')}e{gate[1]}.json",'label': f"ref2_stageC_m{mask}_g{gate[0]}e{gate[1]}"})
            # Stage E
            cmd = list(base) + ['--base-window-ns','19.0','--classifier','chop','--avg-frames','3','--mask-bad-frac',mask,'--seed','8421','--gate-thresh-mV',gate[0],'--gate-extra-frames',gate[1]]
            jobs.append({'cmd': cmd,'optics_overlay': optics_E,'comparator_overlay': comp_T,'tia_overlay': tia_B,'json_out': f"out/ref2_stageE_m{mask}_g{gate[0].replace('.','p')}e{gate[1]}.json",'label': f"ref2_stageE_m{mask}_g{gate[0]}e{gate[1]}"})
    # One avg4 at best mask
    cmd = list(base) + ['--base-window-ns','19.0','--classifier','chop','--avg-frames','4','--mask-bad-frac','0.09375','--seed','8422','--gate-thresh-mV','0.8','--gate-extra-frames','1']
    jobs.append({'cmd': cmd,'optics_overlay': optics_E,'comparator_overlay': comp_C,'tia_overlay': tia_B,'json_out': 'out/ref2_stageCE_avg4.json','label': 'ref2_stageCE_avg4'})
    # One small vth-opt pass
    cmd = list(base) + ['--base-window-ns','19.0','--classifier','chop','--avg-frames','3','--mask-bad-frac','0.09375','--seed','8423','--optimize-vth','--opt-vth-iters','2','--opt-vth-step-mV','0.2','--opt-vth-use-mask','--gate-thresh-mV','0.8','--gate-extra-frames','1']
    jobs.append({'cmd': cmd,'optics_overlay': optics_E,'comparator_overlay': comp_C,'tia_overlay': tia_B,'json_out': 'out/ref2_stageCE_vthopt.json','label': 'ref2_stageCE_vthopt'})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} hardware tuning jobs to {queue}")


if __name__ == '__main__':
    main()



-----------------------

.\scripts\append_overlayfix_batch.py
from __future__ import annotations
import json
import time
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--base-window-ns','19.0','--classifier','chop','--avg-frames','3',
        '--mask-bad-frac','0.09375','--gate-thresh-mV','0.6','--gate-extra-frames','1',
    ]

    optics_A = 'configs/packs/overlays/optics_stage_a_hygiene.yaml'
    optics_E = 'configs/packs/overlays/optics_stage_e_power_mod.yaml'
    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_T = 'configs/packs/overlays/tuned_comparator.yaml'
    comp_C = 'configs/packs/overlays/comparator_stage_c_trims.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_T = 'configs/packs/overlays/tuned_tia.yaml'
    tia_B = 'configs/packs/overlays/tia_stage_b_low_noise.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    def J(label: str, seed: int, optics: str, comp: str, tia: str) -> dict:
        cmd = list(base) + ['--seed', str(seed)]
        return {
            'version': 'overlayfix2',
            'nonce': str(int(time.time())),
            'cmd': cmd,
            'optics_overlay': optics,
            'comparator_overlay': comp,
            'tia_overlay': tia,
            'json_out': f"out/{label}.json",
            'label': label,
        }

    jobs = [
        J('ofix_stageA', 8450, optics_A, comp_T, tia_T),
        J('ofix_stageB', 8451, optics_A, comp_T, tia_B),
        J('ofix_stageC', 8452, optics_A, comp_C, tia_T),
        J('ofix_stageE', 8453, optics_E, comp_T, tia_B),
        J('ofix_stageBCE', 8454, optics_E, comp_C, tia_B),
        J('ofix_comboStrong', 8455, optics_E2, comp_C2, tia_B2),
    ]

    with queue.open('a', encoding='utf-8') as f:
        for job in jobs:
            f.write(json.dumps(job, separators=(',', ':')) + '\n')
    print(f'appended {len(jobs)} overlay-fix validation jobs to {queue}')


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_hw_acceptance_suite.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--base-window-ns','19.0',
    ]

    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    def J(tag: str, seed: int, avg: str, mask: str, gate: tuple[str,str]) -> dict:
        cmd = list(base) + ['--avg-frames', avg, '--mask-bad-frac', mask, '--seed', str(seed), '--gate-thresh-mV', gate[0], '--gate-extra-frames', gate[1]]
        label = f"acc_{tag}_w19p0_avg{avg}_m{mask}_s{seed}_g{gate[0].replace('.', 'p')}e{gate[1]}"
        return {
            'cmd': cmd,
            'optics_overlay': optics_E2,
            'comparator_overlay': comp_C2,
            'tia_overlay': tia_B2,
            'json_out': f"out/{label}.json",
            'label': label,
        }

    jobs = [
        J('C2B2E2', 8460, '3', '0.09375', ('0.6','1')),
        J('C2B2E2', 8461, '3', '0.09375', ('0.8','1')),
        J('C2B2E2', 8462, '3', '0.09375', ('1.2','2')),
        J('C2B2E2', 8463, '2', '0.09375', ('1.0','1')),
        # jitter check
        {
            'cmd': base + ['--avg-frames','3','--mask-bad-frac','0.09375','--seed','8464','--gate-thresh-mV','0.6','--gate-extra-frames','1','--base-window-ns','18.95'],
            'optics_overlay': optics_E2,
            'comparator_overlay': comp_C2,
            'tia_overlay': tia_B2,
            'json_out': 'out/acc_C2B2E2_w18p95_avg3_m0.09375_s8464_g0p6e1.json',
            'label': 'acc_C2B2E2_w18p95_avg3_m0.09375_s8464_g0p6e1',
        },
        {
            'cmd': base + ['--avg-frames','3','--mask-bad-frac','0.09375','--seed','8465','--gate-thresh-mV','0.6','--gate-extra-frames','1','--base-window-ns','19.05'],
            'optics_overlay': optics_E2,
            'comparator_overlay': comp_C2,
            'tia_overlay': tia_B2,
            'json_out': 'out/acc_C2B2E2_w19p05_avg3_m0.09375_s8465_g0p6e1.json',
            'label': 'acc_C2B2E2_w19p05_avg3_m0.09375_s8465_g0p6e1',
        },
    ]

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} acceptance jobs to {queue}")


if __name__ == '__main__':
    main()



-----------------------

.\scripts\append_forcecal_accept.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--base-window-ns','19.0',
        '--force-cal-in-primary',  # enable gating path
    ]

    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    def J(seed: int, avg: str, mask: str, gate: tuple[str,str]) -> dict:
        cmd = list(base) + ['--avg-frames', avg, '--mask-bad-frac', mask, '--seed', str(seed), '--gate-thresh-mV', gate[0], '--gate-extra-frames', gate[1]]
        label = f"acc_fcip_C2B2E2_w19p0_avg{avg}_m{mask}_s{seed}_g{gate[0].replace('.', 'p')}e{gate[1]}"
        return {
            'cmd': cmd,
            'optics_overlay': optics_E2,
            'comparator_overlay': comp_C2,
            'tia_overlay': tia_B2,
            'json_out': f"out/{label}.json",
            'label': label,
        }

    jobs = [
        J(8470, '3', '0.09375', ('0.6','1')),
        J(8471, '3', '0.09375', ('0.8','1')),
        J(8472, '3', '0.09375', ('1.0','2')),
        J(8473, '2', '0.09375', ('1.0','1')),
    ]

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} force-cal acceptance jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_hw_acceptance_diag.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--base-window-ns','19.0',
    ]

    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    def J(tag: str, seed: int, avg: str, mask: str, gate: tuple[str,str], extras: list[str] | None = None) -> dict:
        cmd = list(base) + ['--avg-frames', avg, '--mask-bad-frac', mask, '--seed', str(seed), '--gate-thresh-mV', gate[0], '--gate-extra-frames', gate[1]]
        if extras:
            cmd += extras
        label = f"diag_{tag}_w19p0_avg{avg}_m{mask}_s{seed}_g{gate[0].replace('.', 'p')}e{gate[1]}"
        return {
            'cmd': cmd,
            'optics_overlay': optics_E2,
            'comparator_overlay': comp_C2,
            'tia_overlay': tia_B2,
            'json_out': f"out/{label}.json",
            'label': label,
        }

    jobs = [
        # Wider masks (diagnostic only)
        J('C2B2E2', 8480, '3', '0.10', ('1.2','2')),
        J('C2B2E2', 8481, '3', '0.12', ('1.2','2')),
        # dvspan mask compare
        J('C2B2E2_dvspan', 8482, '3', '0.10', ('1.0','2'), ['--mask-mode','dvspan']),
        J('C2B2E2_dvspan', 8483, '3', '0.12', ('1.0','2'), ['--mask-mode','dvspan']),
        # avg4 variant at 0.10
        J('C2B2E2', 8484, '4', '0.10', ('0.8','1')),
        # enable use_avg_frames_for_path_a to ensure primary uses averaging path
        J('C2B2E2_useavg', 8485, '3', '0.10', ('0.8','1'), ['--use-avg-frames-for-path-a']),
    ]

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} acceptance diag jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_hw_compact_sweep.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop',
    ]

    # Curated overlays
    optics = {
        'A': 'configs/packs/overlays/optics_stage_a_hygiene.yaml',
        'E': 'configs/packs/overlays/optics_stage_e_power_mod.yaml',
        'E2': 'configs/packs/overlays/optics_stage_e2_power_mod.yaml',
        'F': 'configs/packs/overlays/optics_stage_f_amp.yaml',
        'G': 'configs/packs/overlays/optics_stage_g_saturable.yaml',
    }
    comps = {
        'T': 'configs/packs/overlays/tuned_comparator.yaml',
        'C2': 'configs/packs/overlays/comparator_stage_c2_trims.yaml',
        'C3': 'configs/packs/overlays/comparator_stage_c3_precision.yaml',
    }
    tias = {
        'T': 'configs/packs/overlays/tuned_tia.yaml',
        'B2': 'configs/packs/overlays/tia_stage_b2_low_noise.yaml',
        'B3': 'configs/packs/overlays/tia_stage_b3_precision.yaml',
    }

    # Small grid: windows, masks, avg, gating
    windows = ['18.9','19.0','19.1']
    masks = ['0.09125','0.09375']
    avgs = ['2','3']
    gates = [('0.6','1'),('0.8','1')]

    # Combos to try (kept small)
    combos = [
        ('A','T','T'),
        ('E','C2','B2'),
        ('E2','C2','B2'),
        ('F','C3','B3'),
        ('G','C3','B3'),
    ]

    jobs: list[dict] = []
    seed = 8600
    for o,c,t in combos:
        for w in windows:
            for m in masks:
                for a in avgs:
                    for g in gates:
                        cmd = list(base) + ['--base-window-ns', w, '--avg-frames', a, '--mask-bad-frac', m,
                                             '--seed', str(seed), '--gate-thresh-mV', g[0], '--gate-extra-frames', g[1]]
                        label = f"swh_{o}{c}{t}_w{w.replace('.', 'p')}_avg{a}_m{m}_s{seed}_g{g[0].replace('.', 'p')}e{g[1]}"
                        jobs.append({
                            'cmd': cmd,
                            'optics_overlay': optics[o],
                            'comparator_overlay': comps[c],
                            'tia_overlay': tias[t],
                            'json_out': f"out/{label}.json",
                            'label': label,
                        })
                        seed += 1

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} hardware compact sweep jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_confirm_best.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop',
    ]

    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    seeds = [9300, 9301, 9302]
    windows = ['18.95','19.0','19.05']

    jobs: list[dict] = []
    for s in seeds:
        for w in windows:
            # no gating
            cmd = list(base) + ['--base-window-ns', w, '--avg-frames', '2', '--mask-bad-frac', '0.09375', '--seed', str(s)]
            label = f"confirm_E2C2B2_w{w.replace('.','p')}_avg2_m0.09375_s{s}"
            jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
            # lite gating
            cmd = list(base) + ['--base-window-ns', w, '--avg-frames', '2', '--mask-bad-frac', '0.09375', '--seed', str(s),'--gate-thresh-mV','0.6','--gate-extra-frames','1']
            label = f"confirm_E2C2B2_w{w.replace('.','p')}_avg2_m0.09375_s{s}_g0p6e1"
            jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
            # for s != 9300, try stronger gating and avg3, and alt mask 0.09125 (minimal additions)
            if s != 9300 and w == '19.0':
                # stronger gating
                cmd = list(base) + ['--base-window-ns', w, '--avg-frames', '2', '--mask-bad-frac', '0.09375', '--seed', str(s),'--gate-thresh-mV','0.8','--gate-extra-frames','1']
                label = f"confirm_E2C2B2_w{w.replace('.','p')}_avg2_m0.09375_s{s}_g0p8e1"
                jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
                cmd = list(base) + ['--base-window-ns', w, '--avg-frames', '2', '--mask-bad-frac', '0.09375', '--seed', str(s),'--gate-thresh-mV','1.0','--gate-extra-frames','2']
                label = f"confirm_E2C2B2_w{w.replace('.','p')}_avg2_m0.09375_s{s}_g1p0e2"
                jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
                # avg3 lite gating
                cmd = list(base) + ['--base-window-ns', w, '--avg-frames', '3', '--mask-bad-frac', '0.09375', '--seed', str(s),'--gate-thresh-mV','0.6','--gate-extra-frames','1']
                label = f"confirm_E2C2B2_w{w.replace('.','p')}_avg3_m0.09375_s{s}_g0p6e1"
                jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
                # alt mask 0.09125
                cmd = list(base) + ['--base-window-ns', w, '--avg-frames', '2', '--mask-bad-frac', '0.09125', '--seed', str(s),'--gate-thresh-mV','0.6','--gate-extra-frames','1']
                label = f"confirm_E2C2B2_w{w.replace('.','p')}_avg2_m0.09125_s{s}_g0p6e1"
                jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
                # mask widen 0.10 at avg2 with lite and stronger gating
                cmd = list(base) + ['--base-window-ns', w, '--avg-frames', '2', '--mask-bad-frac', '0.10', '--seed', str(s),'--gate-thresh-mV','0.6','--gate-extra-frames','1']
                label = f"confirm_E2C2B2_w{w.replace('.','p')}_avg2_m0.10_s{s}_g0p6e1"
                jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
                cmd = list(base) + ['--base-window-ns', w, '--avg-frames', '2', '--mask-bad-frac', '0.10', '--seed', str(s),'--gate-thresh-mV','0.8','--gate-extra-frames','1']
                label = f"confirm_E2C2B2_w{w.replace('.','p')}_avg2_m0.10_s{s}_g0p8e1"
                jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} confirm-best jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_optimize_best.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop', '--base-window-ns','19.0', '--avg-frames','2', '--mask-bad-frac','0.09375',
        '--gate-thresh-mV','0.6','--gate-extra-frames','1',
    ]

    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    jobs: list[dict] = []
    for s in [9301, 9302]:
        # vth optimizer (small)
        cmd = list(base) + ['--seed', str(s), '--optimize-vth', '--opt-vth-iters','2', '--opt-vth-step-mV','0.2', '--opt-vth-use-mask']
        label = f"optbest_E2C2B2_w19p0_avg2_m0.09375_s{s}_vthopt_g0p6e1"
        jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
        # linear optimizer (small)
        cmd = list(base) + ['--seed', str(s), '--optimize-linear', '--opt-lin-iters','2', '--opt-lin-step-mV','0.2', '--opt-lin-use-mask']
        label = f"optbest_E2C2B2_w19p0_avg2_m0.09375_s{s}_linopt_g0p6e1"
        jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} optimize-best jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_moe_comp_suite.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--base-window-ns','19.0', '--mask-bad-frac','0.09375', '--seed','9500',
    ]

    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    jobs: list[dict] = []

    # 1) Replicate/majority vote (simulate MoE style redundancy across optical tiles)
    # Use existing replicate classifiers if present; otherwise, emulate via avg/gating combos.
    for cls in ['replicate', 'replicate2', 'vote5']:
        cmd = list(base) + ['--classifier', cls, '--avg-frames','2']
        label = f"moe_{cls}_avg2_m0.09375_s9500"
        jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
        cmd = list(base) + ['--classifier', cls, '--avg-frames','2','--gate-thresh-mV','0.6','--gate-extra-frames','1']
        label = f"moe_{cls}_avg2_m0.09375_s9500_g0p6e1"
        jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})

    # 2) Decoder + ECC (linear decoder with small L2 + single-parity block ECC)
    cmd = list(base) + ['--classifier','chop','--avg-frames','2','--gate-thresh-mV','0.6','--gate-extra-frames','1',
                        '--decoder-linear','--decoder-l2','1e-3','--decoder-samples','240',
                        '--use-ecc','--ecc-spc-block','4']
    label = 'moe_decoder_ecc_chop_avg2_g0p6e1'
    jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})

    # 3) Soft/vote fusion with lite gating (if fuse-decoder supported)
    cmd = list(base) + ['--classifier','chop','--avg-frames','2','--gate-thresh-mV','0.6','--gate-extra-frames','1',
                        '--decoder-linear','--decoder-l2','1e-3','--decoder-samples','240',
                        '--fuse-decoder','--fuse-alpha','0.7']
    label = 'moe_decoder_fuse_chop_avg2_g0p6e1'
    jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} MoE compensation jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_drift_stress.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--base-window-ns','19.0','--avg-frames','3', '--mask-bad-frac','0.09375',
        '--gate-thresh-mV','0.6','--gate-extra-frames','1',
    ]

    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    jobs: list[dict] = []

    # Drift knobs: simulate slow vth bias drift, increased comp noise, and window jitter
    drifts = [
        ('vth+0p2', ['--vth-bias-mV','0.2']),
        ('vth+0p5', ['--vth-bias-mV','0.5']),
        ('noise+0p05', ['--comp-input-noise-mV','0.35']),  # from 0.300.35
        ('noise+0p10', ['--comp-input-noise-mV','0.40']),  # to 0.40
        ('jit+0p05', ['--base-window-ns','19.05']),
        ('jit-0p05', ['--base-window-ns','18.95']),
    ]
    seed = 9600
    for tag, extra in drifts:
        cmd = list(base) + ['--seed', str(seed)] + extra
        label = f"drift_{tag}_avg3_m0.09375_s{seed}"
        jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})
        seed += 1

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} drift stress-test jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_quick_working.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--base-window-ns','19.0', '--mask-bad-frac','0.09375',
    ]

    optics_E2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_C2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_B2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    jobs: list[dict] = []

    # Best config, avg2 + lite gating (new seeds)
    for s in [9700, 9701]:
        cmd = list(base) + ['--avg-frames','2','--gate-thresh-mV','0.6','--gate-extra-frames','1','--seed',str(s)]
        label = f"quick_E2C2B2_w19p0_avg2_m0.09375_s{s}_g0p6e1"
        jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})

    # Robust variant, avg3 + lite gating
    for s in [9700, 9701]:
        cmd = list(base) + ['--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1','--seed',str(s)]
        label = f"quick_E2C2B2_w19p0_avg3_m0.09375_s{s}_g0p6e1"
        jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})

    # Safe drift variants with supported flags
    drift_cases = [
        ('vth+0p2', ['--vth-bias-mV','0.2'], 9710),
        ('noise+0p05', ['--comp-input-noise-mV','0.35'], 9711),
        ('jit+0p05', ['--base-window-ns','19.05'], 9712),
    ]
    for tag, extra, s in drift_cases:
        cmd = list(base) + ['--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1','--seed',str(s)] + extra
        label = f"quick_drift_{tag}_avg3_m0.09375_s{s}"
        jobs.append({'cmd': cmd,'optics_overlay': optics_E2,'comparator_overlay': comp_C2,'tia_overlay': tia_B2,'json_out': f"out/{label}.json",'label': label})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} quick working jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_invalidation_stress.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--base-window-ns','19.0', '--mask-bad-frac','0.09375',
        '--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        '--seed','9800',
    ]

    optics_bad = 'configs/packs/overlays/optics_stress_ct_stray.yaml'
    comp_bad = 'configs/packs/overlays/comparator_stress_sigma.yaml'
    tia_bad = 'configs/packs/overlays/tia_stress_gainvar.yaml'

    jobs: list[dict] = []

    # Combine one bad overlay at a time and all together
    cases = [
        ('opticsBad', optics_bad, 'configs/packs/overlays/comparator_stage_c2_trims.yaml', 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'),
        ('compBad', 'configs/packs/overlays/optics_stage_e2_power_mod.yaml', comp_bad, 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'),
        ('tiaBad', 'configs/packs/overlays/optics_stage_e2_power_mod.yaml', 'configs/packs/overlays/comparator_stage_c2_trims.yaml', tia_bad),
        ('allBad', optics_bad, comp_bad, tia_bad),
    ]

    for tag, opt, comp, tia in cases:
        cmd = list(base)
        label = f"invalidate_{tag}_avg3_m0.09375_s9800"
        jobs.append({'cmd': cmd,'optics_overlay': opt,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json",'label': label})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} invalidation stress jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_invalidation_stress2.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop', '--mask-bad-frac','0.09375',
    ]

    # Good baseline combo for reference
    optics_good = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_good = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_good = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    # Bad overlays to mix in
    optics_bad = 'configs/packs/overlays/optics_stress_ct_stray.yaml'
    comp_bad = 'configs/packs/overlays/comparator_stress_sigma.yaml'
    tia_bad = 'configs/packs/overlays/tia_stress_gainvar.yaml'

    jobs: list[dict] = []

    def add_job(tag: str, seed: int, win: str, avg: str, gate: tuple[str,str] | None,
                mask: str, opt: str, comp: str, tia: str, extras: list[str] | None = None):
        cmd = list(base) + ['--base-window-ns', win, '--avg-frames', avg, '--seed', str(seed)]
        if gate:
            cmd += ['--gate-thresh-mV', gate[0], '--gate-extra-frames', gate[1]]
        if mask:
            cmd += ['--mask-bad-frac', mask]
        if extras:
            cmd += extras
        label = f"inv2_{tag}_w{win.replace('.', 'p')}_avg{avg}_m{mask}_s{seed}"
        jobs.append({
            'cmd': cmd,
            'optics_overlay': opt,
            'comparator_overlay': comp,
            'tia_overlay': tia,
            'json_out': f"out/{label}.json",
            'label': label,
        })

    seeds = [9900, 9901]
    windows = ['18.9','19.0','19.1']  # includes 0.1 ns jitter
    # Cases: good baseline vs one-bad overlay vs all-bad; no gating and lite gating; avg2 vs avg3; mask narrow/wide
    cases = [
        ('good', optics_good, comp_good, tia_good),
        ('optBad', optics_bad, comp_good, tia_good),
        ('compBad', optics_good, comp_bad, tia_good),
        ('tiaBad', optics_good, comp_good, tia_bad),
        ('allBad', optics_bad, comp_bad, tia_bad),
    ]

    for s in seeds:
        for win in windows:
            for tag, opt, comp, tia in cases:
                # No gating, avg2 and avg3, nominal mask
                add_job(f"{tag}_nogate", s, win, '2', None, '0.09375', opt, comp, tia)
                add_job(f"{tag}_nogate", s, win, '3', None, '0.09375', opt, comp, tia)
                # Lite gating, avg3, nominal mask
                add_job(f"{tag}_g06", s, win, '3', ('0.6','1'), '0.09375', opt, comp, tia)
                # Mask sensitivity: narrow and wide under gating
                add_job(f"{tag}_g06_m008", s, win, '3', ('0.6','1'), '0.08', opt, comp, tia)
                add_job(f"{tag}_g06_m010", s, win, '3', ('0.6','1'), '0.10', opt, comp, tia)

    # Add explicit comparator noise/sigma sweeps on good opt/TIA
    comp_noise_sweep = [
        ('n0p35_s0p20', ['--comp-input-noise-mV','0.35','--comp-vth-sigma-mV','0.20']),
        ('n0p40_s0p30', ['--comp-input-noise-mV','0.40','--comp-vth-sigma-mV','0.30']),
    ]
    for s in seeds:
        for tag, extras in comp_noise_sweep:
            add_job(f"comp_{tag}", s, '19.0', '3', ('0.6','1'), '0.09375', optics_good, comp_good, tia_good, extras)

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} invalidation stress2 jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_invalidation_hooks.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--base-window-ns','19.0','--mask-bad-frac','0.09375',
        '--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1',
    ]

    # Use good combo with stress overlays layered on top
    optics_good = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_good = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_good = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    optics_speckle = 'configs/packs/overlays/optics_speckle_stress.yaml'
    comp_meta = 'configs/packs/overlays/comparator_metastable_stress.yaml'

    jobs: list[dict] = []

    # Speckle only, metastability only, both
    cases = [
        ('speckle', optics_speckle, comp_good, tia_good),
        ('meta', optics_good, comp_meta, tia_good),
        ('speckle_meta', optics_speckle, comp_meta, tia_good),
    ]

    seed = 9950
    for tag, opt, comp, tia in cases:
        cmd = list(base) + ['--seed', str(seed)]
        label = f"invhooks_{tag}_avg3_m0.09375_s{seed}"
        jobs.append({'cmd': cmd,'optics_overlay': opt,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json",'label': label})
        seed += 1

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} invalidation hook jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_drift_schedule.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    """Append a time-series drift schedule: bias/noise/jitter steps with periodic re-trim.

    Model: robust preset (avg3 + lite gate) on best E2+C2+B2 combo.
    - Slices T0..T5 increase: vth_bias (+0.00+0.50 mV), comp noise (+0.00+0.10 mV),
      window jitter (19.0019.10 ns). Every third slice re-trims (omit --no-cal), others use --no-cal.
    - Seeds: 9920, 9921.
    """
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base_common = [
        '--trials','320','--no-sweeps','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--avg-frames','3','--mask-bad-frac','0.09375',
        '--gate-thresh-mV','0.6','--gate-extra-frames','1',
    ]

    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    # Drift schedule slices
    slices = [
        # (label, win_ns, vth_bias_mV, comp_noise_mV, retrim)
        ('T0', '19.00', '0.0', '0.30', True),   # baseline retrim
        ('T1', '19.02', '0.1', '0.32', False),
        ('T2', '19.04', '0.2', '0.34', False),
        ('T3', '19.06', '0.3', '0.36', True),   # retrim
        ('T4', '19.08', '0.4', '0.38', False),
        ('T5', '19.10', '0.5', '0.40', False),
    ]

    jobs: list[dict] = []
    for seed in (9920, 9921):
        for tag, win, vth_b, noise, retrim in slices:
            cmd = list(base_common) + [
                '--seed', str(seed),
                '--base-window-ns', win,
                '--vth-bias-mV', vth_b,
                '--comp-input-noise-mV', noise,
            ]
            if not retrim:
                cmd += ['--no-cal']
            label = f"driftsched_{tag}_w{win.replace('.', 'p')}_avg3_m0.09375_s{seed}_vth{vth_b}_n{noise}{'' if retrim else '_nocal'}"
            jobs.append({
                'cmd': cmd,
                'optics_overlay': optics,
                'comparator_overlay': comp,
                'tia_overlay': tia,
                'json_out': f"out/{label}.json",
                'label': label,
            })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} drift-schedule jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_drift_schedule_rerun.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base_common = [
        '--trials','320','--no-sweeps','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--avg-frames','3','--mask-bad-frac','0.09375',
        '--gate-thresh-mV','0.6','--gate-extra-frames','1',
    ]

    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    slices = [
        ('T0', '19.00', '0.0', '0.30', True),
        ('T1', '19.02', '0.1', '0.32', False),
        ('T2', '19.04', '0.2', '0.34', False),
        ('T3', '19.06', '0.3', '0.36', True),
        ('T4', '19.08', '0.4', '0.38', False),
        ('T5', '19.10', '0.5', '0.40', False),
    ]

    jobs: list[dict] = []
    for seed in (9922, 9923):
        for tag, win, vth_b, noise, retrim in slices:
            cmd = list(base_common) + [
                '--seed', str(seed), '--base-window-ns', win,
                '--vth-bias-mV', vth_b, '--comp-input-noise-mV', noise,
            ]
            if not retrim:
                cmd += ['--no-cal']
            label = f"driftsched2_{tag}_w{win.replace('.', 'p')}_avg3_m0.09375_s{seed}_vth{vth_b}_n{noise}{'' if retrim else '_nocal'}"
            jobs.append({
                'cmd': cmd,
                'optics_overlay': optics,
                'comparator_overlay': comp,
                'tia_overlay': tia,
                'json_out': f"out/{label}.json",
                'label': label,
            })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} drift-schedule rerun jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_pathb_suite.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--light-output',
        '--apply-calibration','--no-adaptive-input',
        '--no-cold-input',  # focus on path B loop, final camera readout
        '--classifier','chop','--mask-bad-frac','0.09375',
    ]

    # Use best-known packs; Path B recursion is controlled via flags
    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    jobs: list[dict] = []

    seeds = [8800, 8801]
    depths = ['1','2','3']
    windows = ['18.95','19.0','19.05']
    for s in seeds:
        for d in depths:
            for w in windows:
                # avg2 and avg3 variants, lite gating on avg3
                cmd = list(base) + ['--seed', str(s), '--base-window-ns', w, '--avg-frames','2', '--path-b-depth', d]
                label = f"pathb_w{w.replace('.','p')}_avg2_m0.09375_s{s}_d{d}"
                jobs.append({'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json",'label': label})
                cmd = list(base) + ['--seed', str(s), '--base-window-ns', w, '--avg-frames','3', '--path-b-depth', d, '--gate-thresh-mV','0.6','--gate-extra-frames','1']
                label = f"pathb_w{w.replace('.','p')}_avg3_m0.09375_s{s}_d{d}_g0p6e1"
                jobs.append({'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json",'label': label})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} path B suite jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_cold_input_suite.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    base = [
        '--trials','320','--no-sweeps','--light-output',
        '--apply-calibration','--no-adaptive-input',
        '--classifier','chop','--mask-bad-frac','0.09375',
    ]

    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    jobs: list[dict] = []
    seeds = [8850, 8851]
    windows = ['18.95','19.0','19.05']
    for s in seeds:
        for w in windows:
            # digital emitter baseline
            cmd = list(base) + ['--seed', str(s), '--base-window-ns', w, '--no-cold-input', '--avg-frames','2']
            label = f"coldcmp_digital_w{w.replace('.','p')}_avg2_m0.09375_s{s}"
            jobs.append({'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json",'label': label})
            # cold input enabled
            cmd = list(base) + ['--seed', str(s), '--base-window-ns', w, '--avg-frames','2']
            label = f"coldcmp_cold_w{w.replace('.','p')}_avg2_m0.09375_s{s}"
            jobs.append({'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json",'label': label})
            # robust variants with lite gating (avg3)
            cmd = list(base) + ['--seed', str(s), '--base-window-ns', w, '--no-cold-input', '--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1']
            label = f"coldcmp_digital_w{w.replace('.','p')}_avg3_m0.09375_s{s}_g0p6e1"
            jobs.append({'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json",'label': label})
            cmd = list(base) + ['--seed', str(s), '--base-window-ns', w, '--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1']
            label = f"coldcmp_cold_w{w.replace('.','p')}_avg3_m0.09375_s{s}_g0p6e1"
            jobs.append({'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json",'label': label})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} cold-input comparison jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\collect_pathb.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    out_dir = Path('out')
    rows = []
    for p in sorted(out_dir.glob('*.json')):
        try:
            data = json.loads(p.read_text(encoding='utf-8'))
        except Exception:
            continue
        label = p.stem
        cfg = data.get('config') or {}
        path_b = data.get('path_b') or {}
        path_b_p50 = path_b.get('p50_ber')
        path_a_p50 = (data.get('path_a') or {}).get('p50_ber')
        base_p50 = (data.get('baseline') or {}).get('p50_ber')
        if path_b_p50 is not None:
            rows.append((label, cfg.get('base_window_ns'), base_p50, path_a_p50, path_b_p50))
    # Print concise summary
    print('label,window_ns,baseline_p50,path_a_p50,path_b_p50')
    for r in rows:
        print(','.join(str(x) for x in r))


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_analog_runs.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    # Base good overlays (E2+C2+B2) and stress overlays layered via runner merge
    optics_good = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_good = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_good = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_speckle = 'configs/packs/overlays/optics_speckle_stress.yaml'
    comp_meta = 'configs/packs/overlays/comparator_metastable_stress.yaml'

    # 1) Cold analog input (Path A), clearly marked and fresh seeds
    cold_cases = [
        ('cold_lockin_avg2', ['--trials','320','--seed','12051','--no-sweeps','--no-drift','--light-output',
                               '--base-window-ns','19.0','--classifier','lockin','--lockin','--avg-frames','2',
                               '--apply-calibration','--no-path-b','--path-b-depth','0','--no-path-b-analog']),
        ('cold_chop_avg3',   ['--trials','320','--seed','12052','--no-sweeps','--no-drift','--light-output',
                               '--base-window-ns','19.0','--classifier','chop','--chop','--avg-frames','3',
                               '--apply-calibration','--no-path-b','--path-b-depth','0','--no-path-b-analog']),
        ('cold_avg_norm',    ['--trials','320','--seed','12053','--no-sweeps','--no-drift','--light-output',
                               '--base-window-ns','19.0','--classifier','avg','--avg-frames','2','--normalize-dv',
                               '--apply-calibration','--no-path-b','--path-b-depth','0','--no-path-b-analog']),
    ]
    for tag, cmd in cold_cases:
        label = f"analoginput_{tag}_w19_s{cmd[3]}"
        jobs.append({
            'label': label,
            'cmd': cmd,
            'optics_overlay': optics_speckle,  # stress speckle on cold input
            'comparator_overlay': comp_meta,
            'tia_overlay': tia_good,
            'json_out': f"out/{label}.json",
        })

    # 2) Path B analog loop runs (analog stages), clearly marked and fresh seeds
    pathb_cases = [
        ('pathb_anlg_d2_lockin', ['--trials','320','--seed','12101','--no-sweeps','--no-drift','--light-output',
                                   '--base-window-ns','19.0','--classifier','lockin','--lockin',
                                   '--path-b-analog-depth','2']),
        ('pathb_anlg_d3_chop',   ['--trials','320','--seed','12102','--no-sweeps','--no-drift','--light-output',
                                   '--base-window-ns','19.0','--classifier','chop','--chop',
                                   '--path-b-analog-depth','3']),
        ('pathb_anlg_d5_avg2',   ['--trials','320','--seed','12103','--no-sweeps','--no-drift','--light-output',
                                   '--base-window-ns','19.0','--classifier','avg','--avg-frames','2',
                                   '--path-b-analog-depth','5']),
    ]
    for tag, cmd in pathb_cases:
        label = f"analogpath_{tag}_w19_s{cmd[3]}"
        jobs.append({
            'label': label,
            'cmd': cmd,
            'optics_overlay': optics_good,   # start from good optics; rely on analog path dynamics
            'comparator_overlay': comp_good,
            'tia_overlay': tia_good,
            'json_out': f"out/{label}.json",
        })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} analog-input/path jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_analog_tuned.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    # Good overlays
    optics_e2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_c2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_b2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    # Robust preset knobs
    preset = ['--mask-bad-frac','0.09375','--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1']

    # Cold analog input (Path A), tuned robust
    cold = [
        ('cold_chop_avg3_gated', ['--trials','320','--seed','12251','--no-sweeps','--no-drift','--light-output',
                                   '--base-window-ns','19.0','--classifier','chop','--chop','--apply-calibration',
                                   *preset, '--no-path-b','--path-b-depth','0','--no-path-b-analog']),
        ('cold_lockin_avg3_gated', ['--trials','320','--seed','12252','--no-sweeps','--no-drift','--light-output',
                                     '--base-window-ns','19.0','--classifier','lockin','--lockin','--apply-calibration',
                                     *preset, '--no-path-b','--path-b-depth','0','--no-path-b-analog']),
    ]
    for tag, cmd in cold:
        label = f"analoginput_{tag}_w19_s{cmd[3]}"
        jobs.append({
            'label': label,
            'cmd': cmd,
            'optics_overlay': optics_e2,
            'comparator_overlay': comp_c2,
            'tia_overlay': tia_b2,
            'json_out': f"out/{label}.json",
        })

    # Path B analog loop, tuned robust at depths 2..4
    pathb = [
        ('pathb_d2_chop_avg3_gated', ['--trials','320','--seed','12351','--no-sweeps','--no-drift','--light-output',
                                       '--base-window-ns','19.0','--classifier','chop','--chop','--apply-calibration',
                                       *preset, '--path-b-analog-depth','2']),
        ('pathb_d3_chop_avg3_gated', ['--trials','320','--seed','12352','--no-sweeps','--no-drift','--light-output',
                                       '--base-window-ns','19.0','--classifier','chop','--chop','--apply-calibration',
                                       *preset, '--path-b-analog-depth','3']),
        ('pathb_d4_chop_avg3_gated', ['--trials','320','--seed','12353','--no-sweeps','--no-drift','--light-output',
                                       '--base-window-ns','19.0','--classifier','chop','--chop','--apply-calibration',
                                       *preset, '--path-b-analog-depth','4']),
    ]
    for tag, cmd in pathb:
        label = f"analogpath_{tag}_w19_s{cmd[3]}"
        jobs.append({
            'label': label,
            'cmd': cmd,
            'optics_overlay': optics_e2,
            'comparator_overlay': comp_c2,
            'tia_overlay': tia_b2,
            'json_out': f"out/{label}.json",
        })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} tuned analog-input/path jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_pathb_analog_compact.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    # Base overlays (good) and stress overlays
    optics_good = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_good = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_good = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_speckle = 'configs/packs/overlays/optics_speckle_stress.yaml'
    comp_meta = 'configs/packs/overlays/comparator_metastable_stress.yaml'

    # Compact grid
    seed = 12421  # fresh seed to avoid skip
    windows = ['18.90','19.00','19.10']
    depths = ['1','2','3','4','5','6']
    avg_variants = [
        ('avg2', ['--avg-frames','2'], ''),
        ('avg3g', ['--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1'], '_g0p6e1'),
    ]
    overlay_cases = [
        ('base', optics_good, comp_good),
        ('spkm_meta', optics_speckle, comp_meta),
    ]

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--classifier','chop','--mask-bad-frac','0.09375',
    ]

    for w in windows:
        for d in depths:
            for mode_tag, mode_flags, suffix in avg_variants:
                for o_tag, opt_overlay, comp_overlay in overlay_cases:
                    cmd = list(base) + ['--seed', str(seed), '--base-window-ns', w, '--path-b-analog-depth', d] + mode_flags
                    label = f"pathbanalog_{o_tag}_w{w.replace('.','p')}_{mode_tag}_m0.09375_s{seed}_d{d}{suffix}"
                    jobs.append({
                        'label': label,
                        'cmd': cmd,
                        'optics_overlay': opt_overlay,
                        'comparator_overlay': comp_overlay,
                        'tia_overlay': tia_good,
                        'json_out': f"out/{label}.json",
                    })
            seed += 1

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} path B analog compact sweep jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_pathb_amp_sa.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    # Overlays: amp-only, SA-only, both
    optics_amp = 'configs/packs/overlays/optics_stage_f_amp.yaml'
    optics_sa = 'configs/packs/overlays/optics_stage_g_saturable.yaml'
    optics_both = 'configs/packs/overlays/optics_stage_fg_amp_sat.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    windows = ['18.90','19.00','19.10']
    depths = ['1','2','3','4']
    modes = [
        ('avg2', ['--avg-frames','2'], ''),
        ('avg3g', ['--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1'], '_g0p6e1'),
    ]
    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-cold-input',
        '--classifier','chop','--mask-bad-frac','0.09375',
    ]

    seed = 12501
    for w in windows:
        for d in depths:
            for tag, flags, suffix in modes:
                for o_name, optics in (
                    ('amp', optics_amp),
                    ('sa', optics_sa),
                    ('amp_sa', optics_both),
                ):
                    cmd = list(base) + ['--seed', str(seed), '--base-window-ns', w, '--path-b-analog-depth', d] + flags
                    label = f"pathb_{o_name}_w{w.replace('.','p')}_{tag}_m0.09375_s{seed}_d{d}{suffix}"
                    jobs.append({
                        'label': label,
                        'cmd': cmd,
                        'optics_overlay': optics,
                        'comparator_overlay': comp,
                        'tia_overlay': tia,
                        'json_out': f"out/{label}.json",
                    })
            seed += 1

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} path B amp/SA sweep jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_projector_suite.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    # Optics overlays representing projector regimes
    optics_sets = [
        ('low', 'configs/packs/overlays/optics_projector_low.yaml'),
        ('mid', 'configs/packs/overlays/optics_projector_mid.yaml'),
        ('strong', 'configs/packs/overlays/optics_projector_strong.yaml'),
        ('isolated', 'configs/packs/overlays/optics_projector_isolated.yaml'),
    ]

    # Camera overlay tuned for projector visible band
    cam_overlay = 'configs/packs/overlays/camera_projector_typ.yaml'

    # Tricks/options
    tricks = [
        ('base', []),
        ('norm', ['--normalize-dv']),
        ('avg2', ['--avg-frames','2']),
        ('avg3g', ['--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1']),
        ('mask10', ['--mask-bad-frac','0.10']),
    ]

    # Channel scales (square numbers)
    chan_counts = [256, 576, 1024]

    base = [
        '--trials','240','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop',
    ]

    seeds = [12601, 12602]
    windows = ['18.9','19.0','19.1']

    for oc_tag, opt_overlay in optics_sets:
        for seed in seeds:
            for w in windows:
                for chans in chan_counts:
                    for t_tag, t_flags in tricks:
                        cmd = list(base) + ['--seed', str(seed), '--base-window-ns', w, '--channels', str(chans)] + t_flags
                        label = f"projector_{oc_tag}_w{w.replace('.','p')}_{t_tag}_ch{chans}_s{seed}"
                        jobs.append({
                            'label': label,
                            'cmd': cmd,
                            'optics_overlay': opt_overlay,
                            'comparator_overlay': 'configs/packs/overlays/comparator_stage_c2_trims.yaml',
                            'tia_overlay': 'configs/packs/overlays/tia_stage_b2_low_noise.yaml',
                            'camera_overlay': cam_overlay,
                            'json_out': f"out/{label}.json",
                        })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} projector variant jobs to {queue}")


if __name__ == '__main__':
    main()



-----------------------

.\scripts\append_projector_improve.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    optics = [
        ('mid', 'configs/packs/overlays/optics_projector_mid.yaml'),
        ('iso', 'configs/packs/overlays/optics_projector_isolated.yaml'),
        ('iso_strong', 'configs/packs/overlays/optics_projector_iso_strong.yaml'),
    ]
    cam_overlay = 'configs/packs/overlays/camera_projector_typ.yaml'

    base = [
        '--trials','320','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--channels','576',
    ]

    # Pragmatic improvement ladder
    ladders = [
        ('base', []),
        ('norm', ['--normalize-dv']),
        ('avg2', ['--avg-frames','2']),
        ('avg3g', ['--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1']),
        ('mask7', ['--mask-bad-frac','0.07']),
        ('mask5', ['--mask-bad-frac','0.05']),
    ]

    seeds = [12701, 12702]
    windows = ['18.95','19.0','19.05']

    for tag, opt in optics:
        for seed in seeds:
            for w in windows:
                for ltag, flags in ladders:
                    cmd = list(base) + ['--seed', str(seed), '--base-window-ns', w] + flags
                    label = f"projimp_{tag}_w{w.replace('.','p')}_{ltag}_ch576_s{seed}"
                    jobs.append({
                        'label': label,
                        'cmd': cmd,
                        'optics_overlay': opt,
                        'comparator_overlay': 'configs/packs/overlays/comparator_stage_c2_trims.yaml',
                        'tia_overlay': 'configs/packs/overlays/tia_stage_b2_low_noise.yaml',
                        'camera_overlay': cam_overlay,
                        'json_out': f"out/{label}.json",
                    })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} projector improvement jobs to {queue}")


if __name__ == '__main__':
    main()



-----------------------

.\scripts\append_projector_best.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    optics = 'configs/packs/overlays/optics_projector_dmd_strong.yaml'
    cam_overlay = 'configs/packs/overlays/camera_projector_typ.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    base = [
        '--trials','480','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--normalize-dv','--use-avg-frames-for-path-a',
        '--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        '--mask-bad-frac','0.05',
    ]

    seeds = [12801, 12802, 12803]
    windows = ['19.05','19.10']
    chans = [256, 576]

    for seed in seeds:
        for w in windows:
            for ch in chans:
                cmd = list(base) + ['--seed', str(seed), '--base-window-ns', w, '--channels', str(ch)]
                label = f"projbest_dmd_w{w.replace('.','p')}_ch{ch}_s{seed}"
                jobs.append({
                    'label': label,
                    'cmd': cmd,
                    'optics_overlay': optics,
                    'comparator_overlay': comp,
                    'tia_overlay': tia,
                    'camera_overlay': cam_overlay,
                    'json_out': f"out/{label}.json",
                })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} projector best-cal runs to {queue}")


if __name__ == '__main__':
    main()



-----------------------

.\scripts\append_projector_best2.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    optics = 'configs/packs/overlays/optics_projector_dmd_strong.yaml'
    cam_overlay = 'configs/packs/overlays/camera_projector_typ.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    base = [
        '--trials','640','--no-sweeps','--no-drift','--light-output',
        '--apply-calibration','--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
        '--classifier','chop','--normalize-dv','--use-avg-frames-for-path-a',
        '--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        '--mask-bad-frac','0.05',
    ]

    seeds = [12901, 12902]
    windows = ['19.10']
    chans = [256, 576]

    for seed in seeds:
        for w in windows:
            for ch in chans:
                cmd = list(base) + ['--seed', str(seed), '--base-window-ns', w, '--channels', str(ch)]
                label = f"projbest2_dmd_w{w.replace('.','p')}_ch{ch}_s{seed}"
                jobs.append({
                    'label': label,
                    'cmd': cmd,
                    'optics_overlay': optics,
                    'comparator_overlay': comp,
                    'tia_overlay': tia,
                    'camera_overlay': cam_overlay,
                    'json_out': f"out/{label}.json",
                })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} projector best-cal v2 runs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_pragmatic_path.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    # Common good overlays (Path A PD path unless camera overlay provided)
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_good = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    optics_iso = 'configs/packs/overlays/optics_projector_isolated.yaml'  # uses tile borders/isolation
    optics_amp = 'configs/packs/overlays/optics_stage_f_amp.yaml'
    optics_sa = 'configs/packs/overlays/optics_stage_g_saturable.yaml'
    optics_both = 'configs/packs/overlays/optics_stage_fg_amp_sat.yaml'

    # Phase 1: Single-PD MVP (Path A, electronic ternary)  PD path (no camera overlay)
    phase1 = [
        ('p1_pd_w10',  ['--channels','1','--base-window-ns','10.0','--avg-frames','1']),
        ('p1_pd_w5',   ['--channels','1','--base-window-ns','5.0','--avg-frames','1']),
        ('p1_pd_w2',   ['--channels','1','--base-window-ns','2.0','--avg-frames','1']),
    ]
    for tag, args in phase1:
        cmd = ['--trials','320','--no-sweeps','--no-drift','--light-output','--apply-calibration',
               '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
               '--classifier','avg','--seed','13101'] + args
        label = f"prag_{tag}"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_good,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Phase 2: Fast gating proxy (short window)  still PD read
    phase2 = [
        ('p2_fast_w1',  ['--channels','1','--base-window-ns','1.0','--avg-frames','1']),
        ('p2_fast_w0p5',['--channels','1','--base-window-ns','0.5','--avg-frames','1']),
    ]
    for tag, args in phase2:
        cmd = ['--trials','320','--no-sweeps','--no-drift','--light-output','--apply-calibration',
               '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
               '--classifier','avg','--seed','13102'] + args
        label = f"prag_{tag}"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_good,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Phase 3: Path B single hop (amp and/or SA)  PD read
    phase3 = [
        ('p3_pathb_amp',      optics_amp),
        ('p3_pathb_sa',       optics_sa),
        ('p3_pathb_amp_sa',   optics_both),
    ]
    for tag, opt in phase3:
        cmd = ['--trials','320','--no-sweeps','--no-drift','--light-output','--apply-calibration',
               '--no-adaptive-input','--base-window-ns','5.0','--classifier','avg','--avg-frames','1',
               '--seed','13103', '--path-b-analog-depth','1']
        label = f"prag_{tag}_ch1"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': opt,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Phase 4: PD banks (32/128/256/512) with isolation borders, normalize, lite gating
    phase4_ch = ['32','128','256','512']
    for ch in phase4_ch:
        cmd = ['--trials','320','--no-sweeps','--no-drift','--light-output','--apply-calibration',
               '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
               '--classifier','chop','--channels', ch,
               '--base-window-ns','19.0','--avg-frames','2','--normalize-dv',
               '--gate-thresh-mV','0.6','--gate-extra-frames','1','--mask-bad-frac','0.07',
               '--seed','13104']
        label = f"prag_p4_iso_ch{ch}_avg2_norm_g0p6e1_m0p07"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_iso,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Phase 5: Shared SA+amp with PD banks (time-multiplex depth 2)
    phase5_ch = ['128','256']
    for ch in phase5_ch:
        cmd = ['--trials','320','--no-sweeps','--no-drift','--light-output','--apply-calibration',
               '--no-adaptive-input','--classifier','chop','--channels', ch,
               '--base-window-ns','19.0','--avg-frames','2','--normalize-dv',
               '--gate-thresh-mV','0.6','--gate-extra-frames','1','--mask-bad-frac','0.05',
               '--seed','13105', '--path-b-analog-depth','2']
        label = f"prag_p5_pathb_amp_sa_ch{ch}_avg2_norm_g0p6e1_m0p05_d2"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_both,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} pragmatic build-path jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_single_tuning.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_good = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    optics_amp4 = 'configs/packs/overlays/optics_stage_f_amp_g4.yaml'
    optics_sa_soft = 'configs/packs/overlays/optics_stage_g_saturable_soft.yaml'

    # Single-channel Path A tuning sweeps: window, gating, hysteresis, normalization
    p1_sweeps = [
        ('p1_tune_w8_norm',   ['--base-window-ns','8.0','--normalize-dv']),
        ('p1_tune_w12_norm',  ['--base-window-ns','12.0','--normalize-dv']),
        ('p1_tune_w10_gate',  ['--base-window-ns','10.0','--gate-thresh-mV','0.4','--gate-extra-frames','1']),
        ('p1_tune_w10_hyst',  ['--base-window-ns','10.0','--comp-hysteresis-mV','0.5']),
    ]
    for tag, extra in p1_sweeps:
        cmd = ['--trials','480','--no-sweeps','--no-drift','--light-output','--apply-calibration',
               '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
               '--classifier','avg','--channels','1','--seed','13201','--avg-frames','1'] + extra
        label = f"single_{tag}"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_good,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Single-channel Path B tuning: amp gain lower, soft SA, window sweep
    p3_sweeps = [
        ('p3_amp4_w5',  optics_amp4,   ['--base-window-ns','5.0']),
        ('p3_amp4_w8',  optics_amp4,   ['--base-window-ns','8.0']),
        ('p3_sa_soft_w5', optics_sa_soft, ['--base-window-ns','5.0']),
        ('p3_sa_soft_w8', optics_sa_soft, ['--base-window-ns','8.0']),
    ]
    for tag, opt, extra in p3_sweeps:
        cmd = ['--trials','480','--no-sweeps','--no-drift','--light-output','--apply-calibration',
               '--no-adaptive-input','--classifier','avg','--channels','1','--avg-frames','1',
               '--seed','13202','--path-b-analog-depth','1'] + extra
        label = f"single_{tag}"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': opt,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} single-channel tuning jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_single_verify_and_sweeps.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_good = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    optics_sa_soft = 'configs/packs/overlays/optics_stage_g_saturable_soft.yaml'
    optics_amp_sa_soft = 'configs/packs/overlays/optics_stage_fg_amp_sat_soft.yaml'
    optics_iso_strong = 'configs/packs/overlays/optics_projector_iso_strong.yaml'

    # Verify single-PD 0.0 BER claims with multi-seed, higher trials
    seeds = ['14101','14102','14103','14104']
    for s in seeds:
        # Path A verify
        cmd = ['--trials','2000','--no-sweeps','--no-drift','--light-output','--apply-calibration',
               '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
               '--classifier','avg','--channels','1','--seed', s, '--avg-frames','1',
               '--base-window-ns','10.0','--normalize-dv']
        label = f"verify_single_p1_w10_norm_s{s}"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_good,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

        # Path B verify (soft SA)
        cmd = ['--trials','2000','--no-sweeps','--no-drift','--light-output','--apply-calibration',
               '--no-adaptive-input','--classifier','avg','--channels','1','--seed', s, '--avg-frames','1',
               '--path-b-analog-depth','1','--base-window-ns','5.0']
        label = f"verify_single_p3_sa_soft_w5_s{s}"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_sa_soft,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Multi-channel tuning sweeps: stronger isolation, higher window, avg3+gate, mask5
    chans = ['32','128','256','512']
    windows = ['20.0','21.0','22.0']
    for ch in chans:
        for w in windows:
            cmd = ['--trials','640','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                   '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                   '--classifier','chop','--channels', ch,
                   '--base-window-ns', w,'--avg-frames','3','--normalize-dv',
                   '--gate-thresh-mV','0.6','--gate-extra-frames','1','--mask-bad-frac','0.05',
                   '--seed','14201']
            label = f"tune_iso_strong_ch{ch}_w{w.replace('.','p')}_avg3_norm_g0p6e1_m0p05"
            jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_iso_strong,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Path B multi-ch with soft amp+SA and higher window (depth 2)
    for ch in ['128','256']:
        for w in windows:
            cmd = ['--trials','640','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                   '--no-adaptive-input','--classifier','chop','--channels', ch,
                   '--base-window-ns', w,'--avg-frames','3','--normalize-dv',
                   '--gate-thresh-mV','0.6','--gate-extra-frames','1','--mask-bad-frac','0.05',
                   '--seed','14202','--path-b-analog-depth','2']
            label = f"tune_p5_amp_sa_soft_ch{ch}_w{w.replace('.','p')}_avg3_norm_g0p6e1_m0p05_d2"
            jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_amp_sa_soft,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} verify+tuning jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_multich_refine.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_iso_stronger = 'configs/packs/overlays/optics_projector_iso_stronger.yaml'

    # Refine multi-channel: stronger isolation, avg3, normalize, lite gate 0.6, mask 5%, windows 2024
    chans = ['32','128','256','512']
    windows = ['20.0','21.0','22.0','23.0','24.0']
    for ch in chans:
        for w in windows:
            cmd = ['--trials','800','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                   '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                   '--classifier','chop','--channels', ch,
                   '--base-window-ns', w,'--avg-frames','3','--normalize-dv',
                   '--gate-thresh-mV','0.6','--gate-extra-frames','1','--mask-bad-frac','0.05',
                   '--seed','14301']
            label = f"refine_iso_stronger_ch{ch}_w{w.replace('.','p')}_avg3_norm_g0p6e1_m0p05"
            jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_iso_stronger,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} multi-channel refine jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_small_ch_scaling.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_iso_stronger = 'configs/packs/overlays/optics_projector_iso_stronger.yaml'

    # Pragmatic small-channel scaling: 2/4/8/16 ch, realistic settings
    chans = ['2','4','8','16']
    windows = ['18.0','19.0','20.0']
    for ch in chans:
        for w in windows:
            cmd = [
                '--trials','800','--no-sweeps','--no-drift','--light-output',
                '--apply-calibration','--no-adaptive-input',
                '--no-path-b','--path-b-depth','0','--no-path-b-analog',
                '--classifier','chop','--channels', ch,
                '--base-window-ns', w,
                '--avg-frames','3','--normalize-dv',
                '--gate-thresh-mV','0.6','--gate-extra-frames','1',
                '--mask-bad-frac','0.05','--seed','14401',
            ]
            label = f"scale_small_iso_ch{ch}_w{w.replace('.','p')}_avg3_norm_g0p6e1_m0p05"
            jobs.append({
                'label': label,
                'cmd': cmd,
                'optics_overlay': optics_iso_stronger,
                'comparator_overlay': comp,
                'tia_overlay': tia,
                'json_out': f"out/{label}.json",
            })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} small-channel scaling jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_refine_16_32_and_pathb.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_iso_stronger = 'configs/packs/overlays/optics_projector_iso_stronger.yaml'
    optics_amp_sa_soft = 'configs/packs/overlays/optics_stage_fg_amp_sat_soft.yaml'

    # 16/32 ch refinement: hysteresis 0.75, gate 0.4/0.6, mask 5/7, normalize on/off, windows 2022
    chans = ['16','32']
    windows = ['20.0','21.0','22.0']
    gates = ['0.4','0.6']
    masks = ['0.05','0.07']
    norms = [True, False]
    for ch in chans:
        for w in windows:
            for g in gates:
                for m in masks:
                    for n in norms:
                        base = [
                            '--trials','1000','--no-sweeps','--no-drift','--light-output',
                            '--apply-calibration','--no-adaptive-input',
                            '--no-path-b','--path-b-depth','0','--no-path-b-analog',
                            '--classifier','chop','--channels', ch,
                            '--base-window-ns', w,
                            '--avg-frames','3', '--gate-thresh-mV', g, '--gate-extra-frames','1',
                            '--mask-bad-frac', m, '--comp-hysteresis-mV','0.75', '--seed','14501',
                        ]
                        if n:
                            base += ['--normalize-dv']
                        label = f"refine_ch{ch}_w{w.replace('.','p')}_avg3_{'norm_' if n else ''}g{g.replace('.','p')}e1_m{m.replace('0.','0p')}"
                        jobs.append({'label': label,'cmd': base,'optics_overlay': optics_iso_stronger,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Extend Path B multi-channel tests beyond MVP: depth=3, windows 2022, 128/256 ch, avg3 + normalize + gate 0.6, mask 5%
    for ch in ['128','256']:
        for w in windows:
            cmd = [
                '--trials','1000','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                '--no-adaptive-input','--classifier','chop','--channels', ch,
                '--base-window-ns', w,'--avg-frames','3','--normalize-dv',
                '--gate-thresh-mV','0.6','--gate-extra-frames','1','--mask-bad-frac','0.05',
                '--seed','14502','--path-b-analog-depth','3'
            ]
            label = f"extend_p5_d3_ch{ch}_w{w.replace('.','p')}_avg3_norm_g0p6e1_m0p05"
            jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_amp_sa_soft,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} refine 16/32 and pathB depth3 jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_refine_next_batch.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_iso_extreme = 'configs/packs/overlays/optics_projector_iso_extreme.yaml'
    optics_iso_stronger = 'configs/packs/overlays/optics_projector_iso_stronger.yaml'
    optics_amp_sa_soft = 'configs/packs/overlays/optics_stage_fg_amp_sat_soft.yaml'

    # 16 ch push: extreme isolation, avg3, normalize, gates 0.4 vs 0.6, mask 3/5%, windows 2123
    windows_16 = ['21.0','22.0','23.0']
    for w in windows_16:
        for g in ['0.4','0.6']:
            for m in ['0.03','0.05']:
                cmd = ['--trials','1200','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                       '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                       '--classifier','chop','--channels','16','--base-window-ns', w,
                       '--avg-frames','3','--normalize-dv','--gate-thresh-mV', g,'--gate-extra-frames','1',
                       '--mask-bad-frac', m,'--comp-hysteresis-mV','0.75','--seed','14601']
                label = f"next_ch16_w{w.replace('.','p')}_avg3_norm_g{g.replace('.','p')}e1_m{m.replace('0.','0p')}"
                jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_iso_extreme,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # 32 ch: try extreme isolation + norm off vs on, gates 0.4/0.6, windows 2123, mask 5/7%
    windows_32 = ['21.0','22.0','23.0']
    for w in windows_32:
        for g in ['0.4','0.6']:
            for m in ['0.05','0.07']:
                for norm in [True, False]:
                    cmd = ['--trials','1200','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                           '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                           '--classifier','chop','--channels','32','--base-window-ns', w,
                           '--avg-frames','3','--gate-thresh-mV', g,'--gate-extra-frames','1',
                           '--mask-bad-frac', m,'--comp-hysteresis-mV','0.75','--seed','14602']
                    if norm:
                        cmd += ['--normalize-dv']
                    label = f"next_ch32_w{w.replace('.','p')}_avg3_{'norm_' if norm else ''}g{g.replace('.','p')}e1_m{m.replace('0.','0p')}"
                    jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_iso_extreme,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Path B 128/256 ch depth=3 retune: amp gain 2/4 dB variants via label (overlay fixed), windows 2022
    for ch in ['128','256']:
        for w in ['20.0','21.0','22.0']:
            cmd = ['--trials','1200','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                   '--no-adaptive-input','--classifier','chop','--channels', ch,
                   '--base-window-ns', w,'--avg-frames','3','--normalize-dv',
                   '--gate-thresh-mV','0.6','--gate-extra-frames','1','--mask-bad-frac','0.05',
                   '--seed','14603','--path-b-analog-depth','3']
            label = f"next_p5_d3_ch{ch}_w{w.replace('.','p')}_avg3_norm_g0p6e1_m0p05"
            jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_amp_sa_soft,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} next-batch refine jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_iteration_batch.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_iso_extreme = 'configs/packs/overlays/optics_projector_iso_extreme.yaml'
    optics_iso_boost = 'configs/packs/overlays/optics_iso_boost.yaml'
    optics_amp_sa_soft = 'configs/packs/overlays/optics_stage_fg_amp_sat_soft.yaml'

    # A) 16 ch: iso_boost (more signal), norm on/off, mask 3/5%, gates 0.4/0.6, windows 2123
    for w in ['21.0','22.0','23.0']:
        for g in ['0.4','0.6']:
            for m in ['0.03','0.05']:
                for norm in [True, False]:
                    cmd = ['--trials','1400','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                           '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                           '--classifier','chop','--channels','16','--base-window-ns', w,
                           '--avg-frames','3','--gate-thresh-mV', g,'--gate-extra-frames','1',
                           '--mask-bad-frac', m,'--comp-hysteresis-mV','0.75','--seed','14701']
                    if norm:
                        cmd += ['--normalize-dv']
                    label = f"iter_ch16_w{w.replace('.','p')}_avg3_{'norm_' if norm else ''}g{g.replace('.','p')}e1_m{m.replace('0.','0p')}"
                    jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_iso_boost,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # B) 32 ch: iso_boost and iso_extreme compare with norm on, mask 5/7%, gate 0.6, windows 2123
    for overlay_tag, overlay in [('iso_boost', optics_iso_boost), ('iso_extreme', optics_iso_extreme)]:
        for w in ['21.0','22.0','23.0']:
            for m in ['0.05','0.07']:
                cmd = ['--trials','1400','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                       '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                       '--classifier','chop','--channels','32','--base-window-ns', w,
                       '--avg-frames','3','--normalize-dv','--gate-thresh-mV','0.6','--gate-extra-frames','1',
                       '--mask-bad-frac', m,'--comp-hysteresis-mV','0.75','--seed','14702']
                label = f"iter_ch32_{overlay_tag}_w{w.replace('.','p')}_avg3_norm_g0p6e1_m{m.replace('0.','0p')}"
                jobs.append({'label': label,'cmd': cmd,'optics_overlay': overlay,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # C) Path B: 128/256 ch depth=3 with iso_extreme, try gate 0.4 vs 0.6, windows 2123
    for ch in ['128','256']:
        for w in ['21.0','22.0','23.0']:
            for g in ['0.4','0.6']:
                cmd = ['--trials','1400','--no-sweeps','--no-drift','--light-output','--apply-calibration',
                       '--no-adaptive-input','--classifier','chop','--channels', ch,
                       '--base-window-ns', w,'--avg-frames','3','--normalize-dv',
                       '--gate-thresh-mV', g,'--gate-extra-frames','1','--mask-bad-frac','0.05',
                       '--seed','14703','--path-b-analog-depth','3']
                label = f"iter_p5_d3_ch{ch}_w{w.replace('.','p')}_avg3_norm_g{g.replace('.','p')}e1_m0p05"
                jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_amp_sa_soft,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} iteration batch jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_lidar_like_suite.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_ambient = 'configs/packs/overlays/optics_ambient_stress.yaml'

    # Compare lock-in vs chop/avg under ambient stress at small channel counts
    chans = ['1','2','8','16']
    windows = ['18.0','19.0','20.0']
    for ch in chans:
        for w in windows:
            # Lock-in path
            cmd_li = [
                '--trials','800','--no-sweeps','--light-output','--apply-calibration',
                '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                '--classifier','lockin','--lockin','--channels', ch,
                '--base-window-ns', w, '--avg-frames','2', '--mask-bad-frac','0.05', '--seed','14801'
            ]
            label = f"lidar_like_lockin_ch{ch}_w{w.replace('.','p')}_avg2_m0p05"
            jobs.append({'label': label,'cmd': cmd_li,'optics_overlay': optics_ambient,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

            # Baseline chop/avg
            cmd_bl = [
                '--trials','800','--no-sweeps','--light-output','--apply-calibration',
                '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                '--classifier','chop','--chop','--channels', ch,
                '--base-window-ns', w, '--avg-frames','3', '--normalize-dv', '--gate-thresh-mV','0.6','--gate-extra-frames','1',
                '--mask-bad-frac','0.05', '--seed','14802'
            ]
            label = f"lidar_like_baseline_ch{ch}_w{w.replace('.','p')}_avg3_norm_g0p6e1_m0p05"
            jobs.append({'label': label,'cmd': cmd_bl,'optics_overlay': optics_ambient,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} LiDAR-like ambient lock-in vs baseline jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_accept_and_calib.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    # Best-known overlays per TUNING.md: E2 + C2 + B2
    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    # Acceptance presets: Robust and Fast (multi-seed)
    seeds = ['9101','9102','9103']
    for w in ['18.95','19.00','19.05']:
        # Robust: avg3 + lite gating (0.6, +1), mask ~0.09375
        for s in seeds:
            cmd = [
                '--trials','1200','--no-sweeps','--light-output','--apply-calibration',
                '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                '--classifier','chop','--channels','16','--base-window-ns', w,
                '--avg-frames','3','--gate-thresh-mV','0.6','--gate-extra-frames','1','--mask-bad-frac','0.09375',
                '--seed', s,
            ]
            label = f"accept_robust_ch16_w{w.replace('.','p')}_avg3_m0.09375_s{s}_g0p6e1"
            jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

        # Fast: avg2 + lite gating
        for s in seeds:
            cmd = [
                '--trials','1200','--no-sweeps','--light-output','--apply-calibration',
                '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                '--classifier','chop','--channels','16','--base-window-ns', w,
                '--avg-frames','2','--gate-thresh-mV','0.6','--gate-extra-frames','1','--mask-bad-frac','0.09375',
                '--seed', s,
            ]
            label = f"accept_fast_ch16_w{w.replace('.','p')}_avg2_m0.09375_s{s}_g0p6e1"
            jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Per-tile vth calibration: export/import flow at 16 and 32 channels
    for ch in ['16','32']:
        # Export pass
        cmd = [
            '--trials','600','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3',
            '--mask-bad-frac','0.09375','--seed','9201',
        ]
        label = f"calib_vth_export_ch{ch}_w19p0_avg3_m0.09375_s9201"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'export_vth': f"out/{label}_vth.json",'json_out': f"out/{label}.json"})
        # Import pass
        cmd2 = [
            '--trials','600','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3',
            '--mask-bad-frac','0.09375','--seed','9202',
        ]
        label2 = f"calib_vth_import_ch{ch}_w19p0_avg3_m0.09375_s9202"
        jobs.append({'label': label2,'cmd': cmd2,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'import_vth': f"out/{label}_vth.json",'json_out': f"out/{label2}.json"})

    # Path B deeper with lower per-stage gain + soft SA bias: d=4..5
    optics_amp4 = 'configs/packs/overlays/optics_stage_f_amp_g4.yaml'
    optics_sa_soft = 'configs/packs/overlays/optics_stage_g_saturable_soft.yaml'
    for d in ['4','5']:
        for w in ['18.90','19.00','19.10']:
            for tag, opt in (('amp4', optics_amp4), ('sa_soft', optics_sa_soft)):
                cmd = [
                    '--trials','400','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input',
                    '--classifier','chop','--channels','16','--base-window-ns', w,'--avg-frames','3',
                    '--mask-bad-frac','0.09375','--seed','9301','--path-b-analog-depth', d,
                ]
                label = f"pathb_{tag}_d{d}_ch16_w{w.replace('.','p')}_avg3_m0.09375_s9301"
                jobs.append({'label': label,'cmd': cmd,'optics_overlay': opt,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Cold input A/B vs digital (Path A only), with speckle/metastability stress
    optics_speckle = 'configs/packs/overlays/optics_speckle_stress.yaml'
    comp_meta = 'configs/packs/overlays/comparator_metastable_stress.yaml'
    for mode, extra in (
        ('cold_lockin_avg2', ['--classifier','lockin','--lockin','--avg-frames','2']),
        ('digital_avg3', ['--classifier','avg','--avg-frames','3','--normalize-dv']),
    ):
        cmd = [
            '--trials','600','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--channels','16','--base-window-ns','19.0','--mask-bad-frac','0.09375','--seed','9401',
        ] + extra
        label = f"ab_{mode}_ch16_w19p0_m0.09375_s9401_spkm"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_speckle,'comparator_overlay': comp_meta,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} acceptance+calibration jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_vthopt_and_norm.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    channels = ['16','32']
    masks = ['0.075','0.09375','0.11']
    gates = [('0.6','1'), ('0.8','1')]
    seeds = ['9511','9512']

    for ch in channels:
        for m in masks:
            for g in gates:
                for s in seeds:
                    # Without normalization
                    cmd = [
                        '--trials','900','--no-sweeps','--light-output','--apply-calibration',
                        '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                        '--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3',
                        '--mask-bad-frac', m,'--seed', s,'--gate-thresh-mV', g[0],'--gate-extra-frames', g[1],
                        '--optimize-vth','--opt-vth-iters','3','--opt-vth-step-mV','0.2','--opt-vth-use-mask',
                    ]
                    label = f"vthopt_ch{ch}_w19p0_avg3_m{m}_s{s}_g{g[0].replace('.','p')}e{g[1]}"
                    jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

                    # With normalization
                    cmd2 = list(cmd) + ['--normalize-dv']
                    label2 = f"vthopt_norm_ch{ch}_w19p0_avg3_m{m}_s{s}_g{g[0].replace('.','p')}e{g[1]}"
                    jobs.append({'label': label2,'cmd': cmd2,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label2}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} vthopt+normalize jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_pd_bank_mvp.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    for ch in ['2','4','8','16']:
        for w in ['18.5','19.0','19.5']:
            cmd = [
                '--trials','1000','--no-sweeps','--light-output','--apply-calibration',
                '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                '--classifier','chop','--channels', ch,'--base-window-ns', w,'--avg-frames','3',
                '--mask-bad-frac','0.09375','--seed','9601','--gate-thresh-mV','0.6','--gate-extra-frames','1',
            ]
            label = f"pdbank_mvp_ch{ch}_w{w.replace('.','p')}_avg3_m0.09375_s9601_g0p6e1"
            jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} PD bank MVP jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_precision_and_boost.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp_prec = 'configs/packs/overlays/comparator_stage_c3_precision.yaml'
    tia_prec = 'configs/packs/overlays/tia_stage_b3_precision.yaml'
    optics_iso_boost = 'configs/packs/overlays/optics_iso_boost.yaml'
    optics_iso_boost2 = 'configs/packs/overlays/optics_iso_boost2.yaml'

    for optics in (optics_iso_boost, optics_iso_boost2):
        for ch in ['16','32']:
            for w in ['18.9','19.0','19.1']:
                for m in ['0.09375','0.11']:
                    cmd = [
                        '--trials','1000','--no-sweeps','--light-output','--apply-calibration',
                        '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                        '--classifier','chop','--channels', ch,'--base-window-ns', w,'--avg-frames','3',
                        '--mask-bad-frac', m,'--seed','9701','--gate-thresh-mV','0.6','--gate-extra-frames','1',
                    ]
                    label = f"prec_boost_ch{ch}_w{w.replace('.','p')}_avg3_m{m}_s9701_g0p6e1_{Path(optics).stem}"
                    jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp_prec,'tia_overlay': tia_prec,'json_out': f"out/{label}.json"})

    # Tile gain variation sweep to estimate equalization needs
    optics_gainvar = 'configs/packs/overlays/optics_projector_iso_strong.yaml'
    for pct in ['0.0','1.0','2.0','3.0']:
        cmd = [
            '--trials','900','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--classifier','chop','--channels','32','--base-window-ns','19.0','--avg-frames','3',
            '--mask-bad-frac','0.09375','--seed','9711','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        ]
        label = f"gainvar_estimate_ch32_w19p0_avg3_m0.09375_s9711_g0p6e1_{pct}pct"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_gainvar,'comparator_overlay': comp_prec,'tia_overlay': tia_prec,'json_out': f"out/{label}.json",'tile_gain_sigma_pct': pct})

    # Path B deeper with combined softer amp+SA
    optics_amp_sa_soft = 'configs/packs/overlays/optics_stage_fg_amp_sat_soft.yaml'
    for d in ['6']:
        for w in ['18.9','19.0','19.1']:
            cmd = [
                '--trials','480','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input',
                '--classifier','chop','--channels','16','--base-window-ns', w,'--avg-frames','3',
                '--mask-bad-frac','0.09375','--seed','9721','--path-b-analog-depth', d,
            ]
            label = f"pathb_amp_sa_soft_d{d}_ch16_w{w.replace('.','p')}_avg3_m0.09375_s9721"
            jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_amp_sa_soft,'comparator_overlay': comp_prec,'tia_overlay': tia_prec,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} precision+boost jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_hysteresis_sweep.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    optics = 'configs/packs/overlays/optics_iso_boost2.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    channels = ['16','32']
    windows = ['18.9','19.0','19.1']
    hysteresis = ['0.3','0.4','0.5','0.7','0.8']

    for ch in channels:
        for w in windows:
            for h in hysteresis:
                cmd = [
                    '--trials','900','--no-sweeps','--light-output','--apply-calibration',
                    '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                    '--classifier','chop','--channels', ch,'--base-window-ns', w,'--avg-frames','3',
                    '--mask-bad-frac','0.09375','--seed','9801','--gate-thresh-mV','0.6','--gate-extra-frames','1',
                    '--comp-hysteresis-mV', h,
                ]
                label = f"hyst_ch{ch}_w{w.replace('.','p')}_avg3_m0.09375_s9801_g0p6e1_h{h.replace('.','p')}"
                jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} hysteresis sweep jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_accept_upper_and_slow.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    optics_upper = 'configs/packs/overlays/optics_upper_bound.yaml'
    optics_e2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp_c2 = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia_b2 = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    seeds = ['9901','9902']
    # Upper bound optics, see if plateau breaks
    for s in seeds:
        cmd = [
            '--trials','1400','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--classifier','chop','--channels','16','--base-window-ns','19.0','--avg-frames','3',
            '--mask-bad-frac','0.09375','--seed', s,'--gate-thresh-mV','0.6','--gate-extra-frames','1',
        ]
        label = f"accept_upper_ch16_w19p0_avg3_m0.09375_s{s}_g0p6e1"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_upper,'comparator_overlay': comp_c2,'tia_overlay': tia_b2,'json_out': f"out/{label}.json"})

    # Slow-mode acceptance: longer window to see if integration lifts SNR
    for w in ['24.0','28.0']:
        cmd = [
            '--trials','1200','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--classifier','chop','--channels','16','--base-window-ns', w,'--avg-frames','3',
            '--mask-bad-frac','0.09375','--seed','9903','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        ]
        label = f"accept_slow_ch16_w{w.replace('.','p')}_avg3_m0.09375_s9903_g0p6e1"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_e2,'comparator_overlay': comp_c2,'tia_overlay': tia_b2,'json_out': f"out/{label}.json"})

    # Normalized acceptance variant
    for s in seeds:
        cmd = [
            '--trials','1200','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--classifier','chop','--channels','16','--base-window-ns','19.0','--avg-frames','3',
            '--mask-bad-frac','0.09375','--seed', s,'--gate-thresh-mV','0.6','--gate-extra-frames','1',
            '--normalize-dv',
        ]
        label = f"accept_norm_ch16_w19p0_avg3_m0.09375_s{s}_g0p6e1"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_e2,'comparator_overlay': comp_c2,'tia_overlay': tia_b2,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} upper-bound and slow-mode acceptance jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_accept_with_vth_import.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    optics_grid = 'configs/packs/overlays/optics_accept_grid256.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    # Export Vth at 16/32 ch, then import and run acceptance
    for ch in ['16','32']:
        export_label = f"accept_export_vth_ch{ch}_w19p0_avg3_m0.09375_s9951"
        export_cmd = [
            '--trials','600','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3',
            '--mask-bad-frac','0.09375','--seed','9951',
        ]
        jobs.append({'label': export_label,'cmd': export_cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'export_vth': f"out/{export_label}_vth.json",'json_out': f"out/{export_label}.json"})

        import_label = f"accept_import_vth_ch{ch}_w19p0_avg3_m0.09375_s9952"
        import_cmd = [
            '--trials','1200','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3',
            '--mask-bad-frac','0.09375','--seed','9952','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        ]
        jobs.append({'label': import_label,'cmd': import_cmd,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'import_vth': f"out/{export_label}_vth.json",'json_out': f"out/{import_label}.json"})

    # High-res projector-like grid acceptance variant (16 ch)
    for w in ['18.95','19.00','19.05']:
        label = f"accept_grid256_ch16_w{w.replace('.','p')}_avg3_m0.09375_s9961_g0p6e1"
        cmd = [
            '--trials','1200','--no-sweeps','--light-output','--apply-calibration',
            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
            '--classifier','chop','--channels','16','--base-window-ns', w,'--avg-frames','3',
            '--mask-bad-frac','0.09375','--seed','9961','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        ]
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_grid,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} acceptance with Vth import and grid256 jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_accept_combo_plus_pathb8.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_e2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    optics_grid512 = 'configs/packs/overlays/optics_accept_grid512.yaml'

    # Combined acceptance: Vth import + normalize + strong hysteresis
    for ch in ['16','32']:
        export_label = f"accept_combo_export_vth_ch{ch}_w19p0_avg3_m0.09375_s9971"
        jobs.append({
            'label': export_label,
            'cmd': ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3','--mask-bad-frac','0.09375','--seed','9971'],
            'optics_overlay': optics_e2,'comparator_overlay': comp,'tia_overlay': tia,
            'export_vth': f"out/{export_label}_vth.json",'json_out': f"out/{export_label}.json"
        })
        import_label = f"accept_combo_import_norm_h0p8_ch{ch}_w19p0_avg3_m0.09375_s9972_g0p6e1"
        jobs.append({
            'label': import_label,
            'cmd': ['--trials','1400','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3','--mask-bad-frac','0.09375','--seed','9972','--gate-thresh-mV','0.6','--gate-extra-frames','1','--normalize-dv','--comp-hysteresis-mV','0.8'],
            'optics_overlay': optics_e2,'comparator_overlay': comp,'tia_overlay': tia,
            'import_vth': f"out/{export_label}_vth.json",'json_out': f"out/{import_label}.json"
        })

    # Grid512 acceptance variant at 16 ch
    for w in ['18.95','19.0','19.05']:
        label = f"accept_grid512_ch16_w{w.replace('.','p')}_avg3_m0.09375_s9973_g0p6e1_norm_h0p8"
        cmd = ['--trials','1400','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels','16','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac','0.09375','--seed','9973','--gate-thresh-mV','0.6','--gate-extra-frames','1','--normalize-dv','--comp-hysteresis-mV','0.8']
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_grid512,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    # Path B depth=8, low per-stage gain with soft SA
    optics_amp4 = 'configs/packs/overlays/optics_stage_f_amp_g4.yaml'
    optics_sa_soft = 'configs/packs/overlays/optics_stage_g_saturable_soft.yaml'
    for opt, tag in ((optics_amp4,'amp4'), (optics_sa_soft,'sa_soft')):
        cmd = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','16','--base-window-ns','19.0','--avg-frames','3','--mask-bad-frac','0.09375','--seed','9981','--path-b-analog-depth','8']
        label = f"pathb_d8_{tag}_ch16_w19p0_avg3_m0.09375_s9981"
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': opt,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} acceptance combo + PathB d8 jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_dual_array_vs_single.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    # Strong isolation overlays
    optics_iso2 = 'configs/packs/overlays/optics_iso_boost2.yaml'
    optics_grid512 = 'configs/packs/overlays/optics_accept_grid512.yaml'

    windows = ['18.95','19.00','19.05']

    # 16 ch vs two 8 ch arrays
    for w in windows:
        # Single 16-ch acceptance
        label = f"cmp_single16_w{w.replace('.','p')}_avg3_m0.09375_s10011_g0p6e1_iso2"
        cmd = ['--trials','1200','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels','16','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac','0.09375','--seed','10011','--gate-thresh-mV','0.6','--gate-extra-frames','1']
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_iso2,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

        # Two 8-ch arrays (A,B) with separate seeds
        for tag, seed in (('A','10021'),('B','10022')):
            lab = f"cmp_dual_8x2_{tag}_w{w.replace('.','p')}_avg3_m0.09375_s{seed}_g0p6e1_grid512"
            cmd8 = ['--trials','1200','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels','8','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac','0.09375','--seed',seed,'--gate-thresh-mV','0.6','--gate-extra-frames','1']
            jobs.append({'label': lab,'cmd': cmd8,'optics_overlay': optics_grid512,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab}.json"})

    # 32 ch vs four 8 ch arrays
    for w in windows:
        # Single 32-ch acceptance
        label = f"cmp_single32_w{w.replace('.','p')}_avg3_m0.09375_s10012_g0p6e1_iso2"
        cmd = ['--trials','1200','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels','32','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac','0.09375','--seed','10012','--gate-thresh-mV','0.6','--gate-extra-frames','1']
        jobs.append({'label': label,'cmd': cmd,'optics_overlay': optics_iso2,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})
        # Four 8-ch arrays
        for tag, seed in (('A','10031'),('B','10032'),('C','10033'),('D','10034')):
            lab = f"cmp_quad_8x4_{tag}_w{w.replace('.','p')}_avg3_m0.09375_s{seed}_g0p6e1_grid512"
            cmd8 = ['--trials','1200','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels','8','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac','0.09375','--seed',seed,'--gate-thresh-mV','0.6','--gate-extra-frames','1']
            jobs.append({'label': lab,'cmd': cmd8,'optics_overlay': optics_grid512,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} dual-array vs single-array jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_big_batch_remaining.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics_e2 = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    optics_iso2 = 'configs/packs/overlays/optics_iso_boost2.yaml'

    # Acceptance variants: normalize + vth import; normalize only; vth import only (16/32 ch)
    for ch in ['16','32']:
        # export map once
        export_label = f"big_export_vth_ch{ch}_w19p0_avg3_m0.09375_s10101"
        export_cmd = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3','--mask-bad-frac','0.09375','--seed','10101']
        jobs.append({'label': export_label,'cmd': export_cmd,'optics_overlay': optics_e2,'comparator_overlay': comp,'tia_overlay': tia,'export_vth': f"out/{export_label}_vth.json",'json_out': f"out/{export_label}.json"})
        # import + normalize
        for tag, extra in (
            ('imp_norm', ['--normalize-dv']),
            ('imp_only', []),
            ('norm_only', ['--normalize-dv']),
        ):
            lab = f"big_accept_{tag}_ch{ch}_w19p0_avg3_m0.09375_s10102_g0p6e1"
            cmd = ['--trials','1200','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3','--mask-bad-frac','0.09375','--seed','10102','--gate-thresh-mV','0.6','--gate-extra-frames','1'] + extra
            job = {'label': lab,'cmd': cmd,'optics_overlay': optics_iso2,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab}.json"}
            if tag in ('imp_norm','imp_only'):
                job['import_vth'] = f"out/{export_label}_vth.json"
            jobs.append(job)

    # Path B extra checks: d=2..6 with iso2 optics at 16 ch
    for d in ['2','3','4','5','6']:
        lab = f"big_pathb_iso2_d{d}_ch16_w19p0_avg3_m0.09375_s10111"
        cmd = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','16','--base-window-ns','19.0','--avg-frames','3','--mask-bad-frac','0.09375','--seed','10111','--path-b-analog-depth', d]
        jobs.append({'label': lab,'cmd': cmd,'optics_overlay': optics_iso2,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} remaining big-batch jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_tier_sensitivity.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    # Tiers: Stage A hygiene vs Stage E2 power/iso boost; comparator/TIA: trims vs precision
    optics_tiers = [
        ('A', 'configs/packs/overlays/optics_stage_a_hygiene.yaml'),
        ('E2', 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'),
        ('ISO2', 'configs/packs/overlays/optics_iso_boost2.yaml'),
    ]
    comp_tiers = [
        ('C2', 'configs/packs/overlays/comparator_stage_c2_trims.yaml'),
        ('C3', 'configs/packs/overlays/comparator_stage_c3_precision.yaml'),
    ]
    tia_tiers = [
        ('B2', 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'),
        ('B3', 'configs/packs/overlays/tia_stage_b3_precision.yaml'),
    ]

    channels = ['8','16']
    windows = ['18.95','19.0','19.05']

    for (o_tag, o_path) in optics_tiers:
        for (c_tag, c_path) in comp_tiers:
            for (t_tag, t_path) in tia_tiers:
                for ch in channels:
                    for w in windows:
                        label = f"tier_{o_tag}_{c_tag}_{t_tag}_ch{ch}_w{w.replace('.','p')}_avg3_m0.09375_s10201_g0p6e1"
                        cmd = [
                            '--trials','1000','--no-sweeps','--light-output','--apply-calibration',
                            '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                            '--classifier','chop','--channels', ch,'--base-window-ns', w,'--avg-frames','3',
                            '--mask-bad-frac','0.09375','--seed','10201','--gate-thresh-mV','0.6','--gate-extra-frames','1',
                        ]
                        jobs.append({'label': label,'cmd': cmd,'optics_overlay': o_path,'comparator_overlay': c_path,'tia_overlay': t_path,'json_out': f"out/{label}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} tier sensitivity jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_gain_equalization_suite.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'
    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

    # Export dv-span (simulated here via vth export placeholder), then import a gain map and rerun
    # We emulate gain equalization by using --vth-scale and --vth-inline as proxies (runner supports these)

    for ch in ['16','32']:
        # Baseline export
        exp = f"gainexp_ch{ch}_w19p0_avg3_m0.09375_s10301"
        cmd_exp = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3','--mask-bad-frac','0.09375','--seed','10301']
        jobs.append({'label': exp,'cmd': cmd_exp,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'export_vth': f"out/{exp}_vth.json",'json_out': f"out/{exp}.json"})

        # Equalized import + normalization + lite gating
        imp = f"gaineq_norm_ch{ch}_w19p0_avg3_m0.09375_s10302_g0p6e1"
        cmd_imp = ['--trials','1200','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3','--mask-bad-frac','0.09375','--seed','10302','--gate-thresh-mV','0.6','--gate-extra-frames','1','--normalize-dv']
        jobs.append({'label': imp,'cmd': cmd_imp,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'import_vth': f"out/{exp}_vth.json",'json_out': f"out/{imp}.json"})

        # Equalized import without normalization (to isolate the effect)
        imp2 = f"gaineq_only_ch{ch}_w19p0_avg3_m0.09375_s10303_g0p6e1"
        cmd_imp2 = ['--trials','1200','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog','--classifier','chop','--channels', ch,'--base-window-ns','19.0','--avg-frames','3','--mask-bad-frac','0.09375','--seed','10303','--gate-thresh-mV','0.6','--gate-extra-frames','1']
        jobs.append({'label': imp2,'cmd': cmd_imp2,'optics_overlay': optics,'comparator_overlay': comp,'tia_overlay': tia,'import_vth': f"out/{exp}_vth.json",'json_out': f"out/{imp2}.json"})

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} gain equalization jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_bom_option_sims.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    # Curated BOM tiers (budget/mid/lab) using vendor packs
    tiers = [
        (
            'budget',
            'configs/packs/vendors/emitters/ushio_HL8518MG_typ.yaml',
            'configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-10_typ.yaml',
            'configs/packs/vendors/sensors/vishay_BPW34_typ.yaml',
            'configs/packs/vendors/tias/texas_instruments_OPA857EVM_typ.yaml',
            'configs/packs/vendors/comparators/texas_instruments_TLV3501_typ.yaml',
        ),
        (
            'mid',
            'configs/packs/vendors/emitters/thorlabs_L850P200_typ.yaml',
            'configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-5_typ.yaml',
            'configs/packs/vendors/sensors/thorlabs_FDS1010_typ.yaml',
            'configs/packs/vendors/tias/thorlabs_TIA60_typ.yaml',
            'configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml',
        ),
        (
            'lab',
            'configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml',
            'configs/packs/vendors/optics/thorlabs_Engineered-Diffuser-3_typ.yaml',
            'configs/packs/vendors/sensors/thorlabs_FDS1010_typ.yaml',
            'configs/packs/vendors/tias/femto_DLPCA-200_typ.yaml',
            'configs/packs/vendors/comparators/analog_devices_LTC6752_typ.yaml',
        ),
    ]

    windows = ['18.95','19.00','19.05']
    for tag, emit, optx, sensor, tia, comp in tiers:
        for ch in ['8','16']:
            for w in windows:
                label = f"bom_{tag}_ch{ch}_w{w.replace('.','p')}_avg3_m0.09375_s10401_g0p6e1"
                cmd = [
                    '--trials','1000','--no-sweeps','--light-output','--apply-calibration',
                    '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                    '--classifier','chop','--channels', ch,'--base-window-ns', w,'--avg-frames','3',
                    '--mask-bad-frac','0.09375','--seed','10401','--gate-thresh-mV','0.6','--gate-extra-frames','1',
                ]
                jobs.append({
                    'label': label,
                    'cmd': cmd,
                    'emitter_pack': emit,
                    'optics_pack': optx,
                    'sensor_pack': sensor,
                    'tia_pack': tia,
                    'comparator_pack': comp,
                    'json_out': f"out/{label}.json",
                })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} curated BOM option jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_costdown_emitters.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)

    jobs: list[dict] = []

    comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
    tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
    optics = 'configs/packs/overlays/optics_stage_e2_power_mod.yaml'

    # Emitter variants: budget noisy diode, VCSEL 8-ch, baseline packs
    emitters = [
        ('budget', 'configs/packs/overlays/emitter_budget_noisy.yaml'),
        ('vcsel8', 'configs/packs/overlays/emitter_vcsel_array_8ch.yaml'),
        ('obistyp', 'configs/packs/vendors/emitters/coherent_OBIS-850-nm_typ.yaml'),
    ]

    for tag, emit_pack in emitters:
        for ch in ['8','16']:
            label = f"emit_{tag}_ch{ch}_w19p0_avg3_m0.09375_s10501_g0p6e1"
            cmd = [
                '--trials','1000','--no-sweeps','--light-output','--apply-calibration',
                '--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
                '--classifier','chop','--channels', ch,'--base-window-ns', '19.0','--avg-frames','3',
                '--mask-bad-frac','0.09375','--seed','10501','--gate-thresh-mV','0.6','--gate-extra-frames','1',
            ]
            jobs.append({
                'label': label,
                'cmd': cmd,
                'emitter_pack': emit_pack,
                'optics_overlay': optics,
                'comparator_overlay': comp,
                'tia_overlay': tia,
                'json_out': f"out/{label}.json",
            })

    with queue.open('a', encoding='utf-8') as f:
        for j in jobs:
            f.write(json.dumps(j, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} cost-down emitter jobs to {queue}")


if __name__ == '__main__':
    main()





-----------------------

.\scripts\append_cband_mvp_patha.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber = 'configs/packs/overlays/fiber_cband_loop_typ.yaml'
	recv = 'configs/packs/overlays/receiver_ingaas_typ.yaml'
	comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
	tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'

	for w in ['12.0','16.0','19.0','24.0']:
		for avg in ['2','3']:
			label = f"cband_mvp_patha_w{w.replace('.','p')}_avg{avg}_m0.09375_s11001"
			cmd = [
				'--trials','800','--no-sweeps','--light-output','--apply-calibration',
				'--no-adaptive-input','--no-cold-input','--no-path-b','--path-b-depth','0','--no-path-b-analog',
				'--classifier','chop','--channels','1','--base-window-ns', w,'--avg-frames', avg,
				'--mask-bad-frac','0.09375','--seed','11001','--gate-thresh-mV','0.6','--gate-extra-frames','1',
			]
			jobs.append({'label': label,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': fiber,'sensor_pack': recv,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band MVP Path A jobs to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_pathb_loops.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber = 'configs/packs/overlays/fiber_cband_loop_typ.yaml'
	comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
	tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
	soa = 'configs/packs/overlays/soa_chain_soft.yaml'
	edfa = 'configs/packs/overlays/edfa_chain_typ.yaml'

	depths = ['1','2','3','4','5','6']
	windows = ['12.0','16.0','19.0']
	modes = [
		('soa', soa),
		('edfa', edfa),
	]
	for tag, gain in modes:
		for d in depths:
			for w in windows:
				label = f"cband_pathb_{tag}_d{d}_w{w.replace('.','p')}_avg3_m0.09375_s11101"
				cmd = [
					'--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input',
					'--classifier','chop','--channels','1','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac','0.09375',
					'--seed','11101','--path-b-analog-depth', d,
				]
				jobs.append({'label': label,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': fiber,'comparator_overlay': comp,'tia_overlay': tia,'optics_pack': gain,'json_out': f"out/{label}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band Path B loop jobs to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_dwdm_tile.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber = 'configs/packs/overlays/fiber_cband_loop_typ.yaml'
	comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
	tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
	soa = 'configs/packs/overlays/soa_chain_soft.yaml'

	# Model 8 wavelengths as 8 logical channels with near-zero crosstalk
	# Sweep per-\u03bb VOAs (mask proxy), window, and depth=2..4
	for w in ['12.0','16.0','19.0']:
		for d in ['2','3','4']:
			for m in ['0.05','0.09375']:
				label = f"cband_dwdm_tile_w{w.replace('.','p')}_d{d}_avg3_m{m}_s11201"
				cmd = [
					'--trials','700','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input',
					'--classifier','chop','--channels','8','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac', m,
					'--seed','11201','--path-b-analog-depth', d,
				]
				jobs.append({'label': label,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': fiber,'comparator_overlay': comp,'tia_overlay': tia,'optics_pack': soa,'json_out': f"out/{label}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band DWDM tile jobs to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_realism_sweeps.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber = 'configs/packs/overlays/fiber_cband_loop_typ.yaml'
	comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
	tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
	recv_typ = 'configs/packs/overlays/receiver_ingaas_typ.yaml'
	recv_low = 'configs/packs/overlays/receiver_ingaas_lowbw.yaml'
	soa_stress = 'configs/packs/overlays/soa_chain_stress.yaml'
	edfa_stress = 'configs/packs/overlays/edfa_chain_stress.yaml'
	dwdm_imp = 'configs/packs/overlays/dwdm_crosstalk_ripple.yaml'

	# Shorter windows for GHz push; deeper loops; impairments overlays
	windows = ['8.0','10.0','12.0']
	depths = ['2','3','4','6','8']
	masks = ['0.05','0.09375']

	for w in windows:
		for d in depths:
			for m in masks:
				# SOA stress
				lab = f"cband_real_soa_d{d}_w{w.replace('.','p')}_avg3_m{m}_s11301"
				cmd = ['--trials','700','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','1','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac', m,'--seed','11301','--path-b-analog-depth', d]
				jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': fiber,'optics_pack': soa_stress,'comparator_overlay': comp,'tia_overlay': tia,'sensor_pack': recv_typ,'json_out': f"out/{lab}.json"})
				# EDFA stress + DWDM impairments + low-BW receiver
				lab2 = f"cband_real_edfa_dwdm_lowrx_d{d}_w{w.replace('.','p')}_avg3_m{m}_s11302"
				cmd2 = ['--trials','700','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','8','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac', m,'--seed','11302','--path-b-analog-depth', d]
				jobs.append({'label': lab2,'cmd': cmd2,'emitter_pack': emitter,'optics_overlay': dwdm_imp,'optics_pack': edfa_stress,'comparator_overlay': comp,'tia_overlay': tia,'sensor_pack': recv_low,'json_out': f"out/{lab2}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band realism sweep jobs to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_ghz_throughput_and_budget.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber = 'configs/packs/overlays/fiber_cband_loop_typ.yaml'
	comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
	tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
	recv_low = 'configs/packs/overlays/receiver_ingaas_lowbw.yaml'
	soa_budget = 'configs/packs/overlays/soa_chain_budget.yaml'
	edfa_budget = 'configs/packs/overlays/edfa_chain_budget.yaml'

	# GHz timing windows and jitter proxy (we piggyback via shorter windows and low-BW receiver)
	windows = ['6.0','8.0','10.0']
	depths = ['2','4','6','8']
	masks = ['0.05','0.09375']

	for w in windows:
		for d in depths:
			for m in masks:
				# Budget SOA path, single-\u03bb
				lab = f"cband_ghz_soa_budget_d{d}_w{w.replace('.','p')}_avg3_m{m}_s11401"
				cmd = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','1','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac', m,'--seed','11401','--path-b-analog-depth', d]
				jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': fiber,'optics_pack': soa_budget,'comparator_overlay': comp,'tia_overlay': tia,'sensor_pack': recv_low,'json_out': f"out/{lab}.json"})
				# Budget EDFA + DWDM tile (8 \u03bb) to assess throughput
				lab2 = f"cband_ghz_edfa_budget_tile_d{d}_w{w.replace('.','p')}_avg3_m{m}_s11402"
				cmd2 = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','8','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac', m,'--seed','11402','--path-b-analog-depth', d]
				jobs.append({'label': lab2,'cmd': cmd2,'emitter_pack': emitter,'optics_overlay': fiber,'optics_pack': edfa_budget,'comparator_overlay': comp,'tia_overlay': tia,'sensor_pack': recv_low,'json_out': f"out/{lab2}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band GHz throughput & budget jobs to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_ghz_extreme.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber = 'configs/packs/overlays/fiber_cband_loop_typ.yaml'
	comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
	tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
	edfa_budget = 'configs/packs/overlays/edfa_chain_budget.yaml'
	soa_budget = 'configs/packs/overlays/soa_chain_budget.yaml'

	windows = ['6.0','8.0','10.0']
	depths = ['10','12','16','24','32']
	masks = ['0.05']

	for w in windows:
		for d in depths:
			# Single- SOA budget extreme
			lab = f"cband_ext_soa_d{d}_w{w.replace('.','p')}_s11501"
			cmd = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','1','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac', masks[0],'--seed','11501','--path-b-analog-depth', d]
			job = {'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': fiber,'optics_pack': soa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab}.json"}
			# Inject system and comparator jitter via args understood by runner
			job['lane_skew_ps_rms'] = 12.0
			job['pmd_ps_rms'] = 12.0
			job['comp_prop_jitter_ps_rms'] = 10.0
			jobs.append(job)
			# 8- EDFA budget extreme
			lab2 = f"cband_ext_edfa_tile_d{d}_w{w.replace('.','p')}_s11502"
			cmd2 = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','8','--base-window-ns', w,'--avg-frames','3','--mask-bad-frac', masks[0],'--seed','11502','--path-b-analog-depth', d]
			job2 = {'label': lab2,'cmd': cmd2,'emitter_pack': emitter,'optics_overlay': fiber,'optics_pack': edfa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab2}.json"}
			job2['lane_skew_ps_rms'] = 12.0
			job2['pmd_ps_rms'] = 12.0
			job2['comp_prop_jitter_ps_rms'] = 10.0
			jobs.append(job2)

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band extreme GHz jobs to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_must_fail_then_pass.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber = 'configs/packs/overlays/fiber_cband_loop_typ.yaml'
	comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
	tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
	soa_budget = 'configs/packs/overlays/soa_chain_budget.yaml'
	edfa_budget = 'configs/packs/overlays/edfa_chain_budget.yaml'

	# 1) Back-reflection spike stress, single- SOA at 6 ns, depth 12
	lab1 = 'cband_mf_refl_soa_d12_w6p0_s11601'
	cmd1 = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','1','--base-window-ns','6.0','--avg-frames','3','--mask-bad-frac','0.05','--seed','11601','--path-b-analog-depth','12']
	jobs.append({'label': lab1,'cmd': cmd1,'emitter_pack': emitter,'optics_overlay': fiber,'optics_pack': soa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab1}.json"})

	# 2)  drift across AWG slope: emulate by setting higher dwdm_slope and add temp change via emitter drift
	lab2 = 'cband_mf_ldrift_edfa_tile_d10_w6p0_s11602'
	cmd2 = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','8','--base-window-ns','6.0','--avg-frames','3','--mask-bad-frac','0.05','--seed','11602','--path-b-analog-depth','10']
	jobs.append({'label': lab2,'cmd': cmd2,'emitter_pack': emitter,'optics_overlay': fiber,'optics_pack': edfa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab2}.json"})

	# 3) Worst-case isolation DWDM + high total launch power (tile)
	lab3 = 'cband_mf_xtalk_tile_d10_w6p0_s11603'
	cmd3 = ['--trials','600','--no-sweeps','--light-output','--apply-calibration','--no-adaptive-input','--classifier','chop','--channels','8','--base-window-ns','6.0','--avg-frames','3','--mask-bad-frac','0.05','--seed','11603','--path-b-analog-depth','10']
	job3 = {'label': lab3,'cmd': cmd3,'emitter_pack': emitter,'optics_overlay': 'configs/packs/overlays/dwdm_crosstalk_ripple.yaml','optics_pack': edfa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab3}.json"}
	jobs.append(job3)

	# Follow-up passes can be added with calibration flags once hooks exist

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band must-fail tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_recover_with_cal.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber_typ = 'configs/packs/overlays/fiber_cband_loop_typ.yaml'
	fiber_stress = 'configs/packs/overlays/fiber_cband_loop_stress.yaml'
	comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
	tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
	soa_budget = 'configs/packs/overlays/soa_chain_budget.yaml'
	edfa_budget = 'configs/packs/overlays/edfa_chain_budget.yaml'

	# Recovery knobs: normalization + lite gating + small averaging + masking + Vth auto-zero
	recover_flags = [
		'--classifier','chop',
		'--normalize-dv','--normalize-eps-v','1e-6',
		'--avg-frames','3','--use-avg-frames-for-path-a',
		'--gate-thresh-mV','0.6',
		'--mask-bad-frac','0.05',
		'--apply-calibration'
	]

	# Mirror test 1 (SOA reflection) with recovery flags
	lab1 = 'cband_recover_refl_soa_d12_w6p0_s11611_v3'
	cmd1 = ['--trials','600','--no-sweeps','--light-output','--channels','1','--base-window-ns','6.0','--seed','11611','--path-b-analog-depth','12'] + recover_flags
	jobs.append({'label': lab1,'cmd': cmd1,'emitter_pack': emitter,'optics_overlay': fiber_stress,'optics_pack': soa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab1}.json"})

	# Mirror test 2 (EDFA  drift tile) with recovery flags
	lab2 = 'cband_recover_ldrift_edfa_tile_d10_w6p0_s11612_v3'
	cmd2 = ['--trials','600','--no-sweeps','--light-output','--channels','8','--base-window-ns','6.0','--seed','11612','--path-b-analog-depth','10'] + recover_flags
	jobs.append({'label': lab2,'cmd': cmd2,'emitter_pack': emitter,'optics_overlay': fiber_stress,'optics_pack': edfa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab2}.json"})

	# Mirror test 3 (DWDM crosstalk+ripple tile) with recovery flags
	lab3 = 'cband_recover_xtalk_tile_d10_w6p0_s11613_v3'
	cmd3 = ['--trials','600','--no-sweeps','--light-output','--channels','8','--base-window-ns','6.0','--seed','11613','--path-b-analog-depth','10'] + recover_flags
	jobs.append({'label': lab3,'cmd': cmd3,'emitter_pack': emitter,'optics_overlay': 'configs/packs/overlays/dwdm_crosstalk_ripple.yaml','optics_pack': edfa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{lab3}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band recovery tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_recover_sweeps.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber_stress = 'configs/packs/overlays/fiber_cband_loop_stress.yaml'
	comp = 'configs/packs/overlays/comparator_stage_c2_trims.yaml'
	tia = 'configs/packs/overlays/tia_stage_b2_low_noise.yaml'
	soa_budget = 'configs/packs/overlays/soa_chain_budget.yaml'
	edfa_budget = 'configs/packs/overlays/edfa_chain_budget.yaml'

	recover_flags = [
		'--classifier','chop',
		'--normalize-dv','--normalize-eps-v','1e-6',
		'--avg-frames','3','--use-avg-frames-for-path-a',
		'--gate-thresh-mV','0.6',
		'--mask-bad-frac','0.05',
		'--apply-calibration'
	]

	# Sweep 1: BER vs window for 8-ch EDFA tile under stress
	for win in [4.0, 5.0, 6.0, 8.0, 10.0]:
		label = f'cband_recover_win_sweep_edfa8_w{str(win).replace(".","p")}ns_s120{int(win*10):02d}'
		cmd = ['--trials','600','--no-sweeps','--light-output','--channels','8','--base-window-ns',str(win),'--seed',str(12000+int(win*10)),'--path-b-analog-depth','10'] + recover_flags
		jobs.append({'label': label,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': fiber_stress,'optics_pack': edfa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

	# Sweep 2: BER vs depth for 1-ch SOA under stress at 6 ns
	for depth in [8, 12, 16, 24, 32]:
		label = f'cband_recover_depth_sweep_soa1_d{depth}_w6p0ns_s121{depth:02d}'
		cmd = ['--trials','600','--no-sweeps','--light-output','--channels','1','--base-window-ns','6.0','--seed',str(12100+depth),'--path-b-analog-depth',str(depth)] + recover_flags
		jobs.append({'label': label,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': fiber_stress,'optics_pack': soa_budget,'comparator_overlay': comp,'tia_overlay': tia,'json_out': f"out/{label}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band recovery sweep tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_ghz_highstress.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	fiber_stress = 'configs/packs/overlays/fiber_cband_loop_stress.yaml'
	comp_jit_5 = 'configs/packs/overlays/comparator_jitter_5ps.yaml'
	comp_jit_15 = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	clk_jit_8 = 'configs/packs/overlays/clock_jitter_8ps.yaml'
	clk_jit_20 = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	tia_bw_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'
	tia_bw_300 = 'configs/packs/overlays/tia_bw_300mhz_slew.yaml'
	edfa_ase_06 = 'configs/packs/overlays/edfa_ase_tight_obpf.yaml'
	edfa_ase_08 = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	soa_g15 = 'configs/packs/overlays/soa_gain1p5_sat_strong.yaml'
	soa_g30 = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	opt_dwdm = 'configs/packs/overlays/optics_hyperstress_dwdm.yaml'

	wins = [6.0, 8.0, 10.0]
	depths = [10, 12, 16, 24, 32]

	# 8- EDFA tile high-stress grid
	for win in wins:
		for ase in ['06','08']:
			for clk in ['8','20']:
				for comp in ['5','15']:
					for tbw in ['100','300']:
						lab = f'cband_hs_edfa8_w{str(win).replace(".","p")}ns_ase{ase}_clk{clk}_cj{comp}_bw{tbw}'
						cmd = ['--trials','600','--no-sweeps','--light-output','--channels','8','--base-window-ns',str(win),'--seed','13100','--path-b-analog-depth','12','--classifier','chop','--avg-frames','3','--normalize-dv','--normalize-eps-v','1e-6','--mask-bad-frac','0.05','--apply-calibration']
						jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_dwdm,'optics_pack': edfa_ase_06 if ase=='06' else edfa_ase_08,'comparator_overlay': comp_jit_5 if comp=='5' else comp_jit_15,'tia_overlay': tia_bw_100 if tbw=='100' else tia_bw_300,'clock_pack': clk_jit_8 if clk=='8' else clk_jit_20,'json_out': f"out/{lab}.json"})

	# 1- SOA single-channel depth sweep at high stress
	for depth in depths:
		for win in wins:
			for sg in ['15','30']:
				lab = f'cband_hs_soa1_d{depth}_w{str(win).replace(".","p")}ns_g{sg}'
				cmd = ['--trials','600','--no-sweeps','--light-output','--channels','1','--base-window-ns',str(win),'--seed','13200','--path-b-analog-depth',str(depth),'--classifier','chop','--avg-frames','3','--normalize-dv','--normalize-eps-v','1e-6','--mask-bad-frac','0.05','--apply-calibration']
				jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': fiber_stress,'optics_pack': soa_g15 if sg=='15' else soa_g30,'comparator_overlay': comp_jit_15,'tia_overlay': tia_bw_300,'clock_pack': clk_jit_20,'json_out': f"out/{lab}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} c-band high-stress GHz tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_harsher_micro.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	opt_nl = 'configs/packs/overlays/optics_harsher_nonlinear.yaml'
	edfa_tight = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	soa_strong = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	comp_j = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	clk_j = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	tia_300 = 'configs/packs/overlays/tia_bw_300mhz_slew.yaml'

	# EDFA 8- under nonlinear optics at 6 ns
	lab1 = 'cband_harsh_nl_edfa8_w6p0ns'
	cmd1 = ['--trials','600','--no-sweeps','--light-output','--channels','8','--base-window-ns','6.0','--seed','14101','--path-b-analog-depth','12','--classifier','chop','--avg-frames','3','--normalize-dv','--normalize-eps-v','1e-6','--mask-bad-frac','0.05','--apply-calibration']
	jobs.append({'label': lab1,'cmd': cmd1,'emitter_pack': emitter,'optics_overlay': opt_nl,'optics_pack': edfa_tight,'comparator_overlay': comp_j,'clock_pack': clk_j,'tia_overlay': tia_300,'json_out': f"out/{lab1}.json"})

	# SOA 1- with strong saturation at 6 ns
	lab2 = 'cband_harsh_nl_soa1_w6p0ns'
	cmd2 = ['--trials','600','--no-sweeps','--light-output','--channels','1','--base-window-ns','6.0','--seed','14102','--path-b-analog-depth','16','--classifier','chop','--avg-frames','3','--normalize-dv','--normalize-eps-v','1e-6','--mask-bad-frac','0.05','--apply-calibration']
	jobs.append({'label': lab2,'cmd': cmd2,'emitter_pack': emitter,'optics_overlay': opt_nl,'optics_pack': soa_strong,'comparator_overlay': comp_j,'clock_pack': clk_j,'tia_overlay': tia_300,'json_out': f"out/{lab2}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} harsher nonlinear tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_control_bounded_highstress.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	dwdm_adj = 'configs/packs/overlays/dwdm_adjacent_-28db.yaml'
	opt_nl = 'configs/packs/overlays/optics_harsher_nonlinear.yaml'
	edfa_hi = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	soa_hi = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	comp_j = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	clk_j = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'

	# Control-bounded flags: weaker normalize, no masking, no use-avg-frames, calibration on but less powerful
	flags_weak = [
		'--classifier','chop',
		'--normalize-dv','--normalize-eps-v','5e-3',
		'--avg-frames','2',
		'--apply-calibration',
		'--no-adaptive-input',
	]

	# EDFA 8- harsh, bounded control (push timing stress via overlays)
	lab1 = 'cband_cb_edfa8_w6p0ns_adj28_cjit20_v2'
	cmd1 = ['--trials','600','--no-sweeps','--light-output','--channels','8','--base-window-ns','6.0','--seed','15101','--path-b-analog-depth','12','--json','out/cband_cb_edfa8_w6p0ns_adj28_cjit20_v2.json'] + flags_weak
	jobs.append({'label': lab1,'cmd': cmd1,'emitter_pack': emitter,'optics_overlay': opt_nl,'optics_pack': edfa_hi,'comparator_overlay': comp_j,'clock_pack': clk_j,'tia_overlay': tia_100,'json_out': 'out/cband_cb_edfa8_w6p0ns_adj28_cjit20_v2.json'})

	# SOA 1- harsh, bounded control
	lab2 = 'cband_cb_soa1_w6p0ns_cjit20_v2'
	cmd2 = ['--trials','600','--no-sweeps','--light-output','--channels','1','--base-window-ns','6.0','--seed','15102','--path-b-analog-depth','16','--json','out/cband_cb_soa1_w6p0ns_cjit20_v2.json'] + flags_weak
	jobs.append({'label': lab2,'cmd': cmd2,'emitter_pack': emitter,'optics_overlay': opt_nl,'optics_pack': soa_hi,'comparator_overlay': comp_j,'clock_pack': clk_j,'tia_overlay': tia_100,'json_out': 'out/cband_cb_soa1_w6p0ns_cjit20_v2.json'})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} control-bounded high-stress tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_extreme_burn.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	opt_ext = 'configs/packs/overlays/optics_harsher_nonlinear_extreme.yaml'
	edfa_hi = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	soa_hi = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	clk_20 = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	cj_15 = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'

	# Flag sets
	weak_cal = ['--classifier','chop','--normalize-dv','--normalize-eps-v','1e-2','--avg-frames','2','--apply-calibration','--no-adaptive-input']
	no_cal = ['--classifier','avg','--avg-frames','1','--no-drift','--no-sweeps','--no-cal']

	# EDFA 8- extreme: no calibration
	for win in [6.0, 8.0]:
		lab = f'cband_ext_edfa8_w{str(win).replace(".","p")}ns_nocal'
		cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns',str(win),'--seed','16101','--path-b-analog-depth','12'] + no_cal
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ext,'optics_pack': edfa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	# EDFA 8- extreme: weak calibration + lambda drift ramp (simulate via emitter temp)
	for dlam in [0.2, 0.4, 0.6, 1.0]:
		lab = f'cband_ext_edfa8_w6p0ns_weakcal_dlam{str(dlam).replace(".","p")}nm'
		cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns','6.0','--seed','16102','--path-b-analog-depth','12'] + weak_cal
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ext,'optics_pack': edfa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	# SOA 1- extreme: no calibration and weak calibration
	for mode, flags in [('nocal', no_cal), ('weakcal', weak_cal)]:
		lab = f'cband_ext_soa1_w6p0ns_{mode}'
		cmd = ['--trials','600','--light-output','--channels','1','--base-window-ns','6.0','--seed','16103','--path-b-analog-depth','16'] + flags
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ext,'optics_pack': soa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} extreme burn tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_extreme_scrambler.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	opt_ext = 'configs/packs/overlays/optics_harsher_nonlinear_extreme.yaml'
	edfa_hi = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	soa_hi = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	clk_20 = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	cj_15 = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'

	weak_cal = ['--classifier','chop','--normalize-dv','--normalize-eps-v','1e-2','--avg-frames','2','--apply-calibration','--no-adaptive-input']
	no_cal = ['--classifier','avg','--avg-frames','1','--no-drift','--no-sweeps','--no-cal']

	# EDFA 8- with scrambler
	for mode, flags in [('nocal', no_cal), ('weakcal', weak_cal)]:
		lab = f'cband_scram_edfa8_w6p0ns_{mode}'
		cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns','6.0','--seed','17101','--path-b-analog-depth','12'] + flags
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ext,'optics_pack': edfa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	# SOA 1- with scrambler
	for mode, flags in [('nocal', no_cal), ('weakcal', weak_cal)]:
		lab = f'cband_scram_soa1_w6p0ns_{mode}'
		cmd = ['--trials','600','--light-output','--channels','1','--base-window-ns','6.0','--seed','17102','--path-b-analog-depth','16'] + flags
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ext,'optics_pack': soa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} scrambler extreme tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_ultra_burn.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	opt_ultra = 'configs/packs/overlays/optics_harsher_nonlinear_ultra.yaml'
	edfa_hi = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	soa_hi = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	clk_20 = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	cj_15 = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'
	therm = 'configs/packs/overlays/thermal_ramp_2cph.yaml'

	weak_cal = ['--classifier','chop','--normalize-dv','--normalize-eps-v','2e-2','--avg-frames','2','--apply-calibration','--no-adaptive-input']
	no_cal = ['--classifier','avg','--avg-frames','1','--no-drift','--no-sweeps','--no-cal']
	no_gate_norm = ['--classifier','avg','--avg-frames','1','--no-sweeps']

	# EDFA-8 ultra harsh: nocal / weakcal / no_gate_norm
	for mode, flags in [('nocal', no_cal), ('weakcal', weak_cal), ('nogate', no_gate_norm)]:
		lab = f'cband_ultra_edfa8_w6p0ns_{mode}'
		cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns','6.0','--seed','18101','--path-b-analog-depth','12'] + flags
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ultra,'optics_pack': edfa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'thermal_pack': therm,'json_out': f"out/{lab}.json"})

	# SOA-1 ultra harsh: nocal / weakcal / no_gate_norm
	for mode, flags in [('nocal', no_cal), ('weakcal', weak_cal), ('nogate', no_gate_norm)]:
		lab = f'cband_ultra_soa1_w6p0ns_{mode}'
		cmd = ['--trials','600','--light-output','--channels','1','--base-window-ns','6.0','--seed','18102','--path-b-analog-depth','16'] + flags
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ultra,'optics_pack': soa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'thermal_pack': therm,'json_out': f"out/{lab}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} ultra burn tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_power_bathtub.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter_base = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	emitter_low = 'configs/packs/overlays/emitter_cband_power_5mw.yaml'
	opt_ultra = 'configs/packs/overlays/optics_harsher_nonlinear_ultra.yaml'
	edfa_hi = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	soa_hi = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	clk_20 = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	cj_15 = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'

	weak_cal = ['--classifier','chop','--normalize-dv','--normalize-eps-v','2e-2','--avg-frames','2','--apply-calibration','--no-adaptive-input']

	# EDFA-8 power sweep at 6 ns
	for p in ['5mw','base']:
		lab = f'cband_bath_edfa8_w6p0ns_{p}'
		emitter = emitter_low if p=='5mw' else emitter_base
		cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns','6.0','--seed','19101','--path-b-analog-depth','12'] + weak_cal
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ultra,'optics_pack': edfa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	# SOA-1 power sweep at 6 ns
	for p in ['5mw','base']:
		lab = f'cband_bath_soa1_w6p0ns_{p}'
		emitter = emitter_low if p=='5mw' else emitter_base
		cmd = ['--trials','600','--light-output','--channels','1','--base-window-ns','6.0','--seed','19102','--path-b-analog-depth','16'] + weak_cal
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ultra,'optics_pack': soa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} power bathtub tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_verbose_edfa_bath.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter_base = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	emitter_low = 'configs/packs/overlays/emitter_cband_power_5mw.yaml'
	opt_ultra = 'configs/packs/overlays/optics_harsher_nonlinear_ultra.yaml'
	edfa_hi = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	clk_20 = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	cj_15 = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'

	tweak_cal = ['--classifier','chop','--normalize-dv','--normalize-eps-v','2e-2','--avg-frames','2','--apply-calibration','--no-adaptive-input']

	for p, emitter in [('5mw', emitter_low), ('base', emitter_base)]:
		lab = f'cband_bath_edfa8_w6p0ns_{p}_verbose'
		cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns','6.0','--seed','20101','--path-b-analog-depth','12'] + tweak_cal
		jobs.append({
			'label': lab,
			'cmd': cmd,
			'verbose': True,
			'emitter_pack': emitter,
			'optics_overlay': opt_ultra,
			'optics_pack': edfa_hi,
			'comparator_overlay': cj_15,
			'clock_pack': clk_20,
			'tia_overlay': tia_100,
			'json_out': f'out/{lab}.json'
		})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f'appended {len(jobs)} verbose EDFA bathtub jobs to {queue}')


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_harsh_followup.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter_base = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	emitter_hi = 'configs/packs/overlays/emitter_cband_power_40mw.yaml'
	opt_ultra = 'configs/packs/overlays/optics_harsher_nonlinear_ultra.yaml'
	edfa_hi = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	soa_hi = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	clk_20 = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	cj_15 = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'

	weak_cal = ['--classifier','chop','--normalize-dv','--normalize-eps-v','2e-2','--avg-frames','2','--apply-calibration','--no-adaptive-input']
	no_cal = ['--classifier','avg','--avg-frames','1','--no-sweeps','--no-cal']

	# EDFA-8 at 6/8/10 ns, no/weak cal
	for win in ['6.0','8.0','10.0']:
		for mode, flags in [('nocal', no_cal), ('weakcal', weak_cal)]:
			lab = f'cband_harsh_edfa8_w{win.replace(".","p")}ns_{mode}'
			cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns',win,'--seed','21101','--path-b-analog-depth','12'] + flags
			jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter_base,'optics_overlay': opt_ultra,'optics_pack': edfa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	# SOA-1 at depths 24/32, no/weak cal
	for depth in [24,32]:
		for mode, flags in [('nocal', no_cal), ('weakcal', weak_cal)]:
			lab = f'cband_harsh_soa1_d{depth}_w6p0ns_{mode}'
			cmd = ['--trials','600','--light-output','--channels','1','--base-window-ns','6.0','--seed','21102','--path-b-analog-depth',str(depth)] + flags
			jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter_base,'optics_overlay': opt_ultra,'optics_pack': soa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	# EDFA-8 high power 40 mW at 6 ns, weak cal
	lab = 'cband_harsh_edfa8_w6p0ns_hiP40mw_weakcal'
	cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns','6.0','--seed','21103','--path-b-analog-depth','12'] + weak_cal
	jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter_hi,'optics_overlay': opt_ultra,'optics_pack': edfa_hi,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} harsh follow-up tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_ultra_marginality.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	opt_ultra = 'configs/packs/overlays/optics_harsher_nonlinear_ultra.yaml'
	edfa_hi = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	soa_hi = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	clk_30 = 'configs/packs/overlays/clock_jitter_30ps.yaml'
	comp_ms = 'configs/packs/overlays/comparator_metastable_strong.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'

	no_cal = ['--classifier','avg','--avg-frames','1','--no-sweeps','--no-cal','--no-adaptive-input']

	# EDFA-8 ultra marginality
	lab1 = 'cband_ultra_marginal_edfa8_w6p0ns_nocal'
	cmd1 = ['--trials','600','--light-output','--channels','8','--base-window-ns','6.0','--seed','22101','--path-b-analog-depth','12'] + no_cal
	jobs.append({'label': lab1,'cmd': cmd1,'emitter_pack': emitter,'optics_overlay': opt_ultra,'optics_pack': edfa_hi,'comparator_overlay': comp_ms,'clock_pack': clk_30,'tia_overlay': tia_100,'json_out': f"out/{lab1}.json"})

	# SOA-1 ultra marginality
	lab2 = 'cband_ultra_marginal_soa1_w6p0ns_nocal'
	cmd2 = ['--trials','600','--light-output','--channels','1','--base-window-ns','6.0','--seed','22102','--path-b-analog-depth','16'] + no_cal
	jobs.append({'label': lab2,'cmd': cmd2,'emitter_pack': emitter,'optics_overlay': opt_ultra,'optics_pack': soa_hi,'comparator_overlay': comp_ms,'clock_pack': clk_30,'tia_overlay': tia_100,'json_out': f"out/{lab2}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} ultra marginality tests to {queue}")


if __name__ == '__main__':
	main()



-----------------------

.\scripts\append_cband_lambda_ramp.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)
	jobs: list[dict] = []
	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	edfa = 'configs/packs/overlays/edfa_ase_high_tight_obpf.yaml'
	opt_ultra = 'configs/packs/overlays/optics_harsher_nonlinear_ultra.yaml'
	clk_20 = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	cj_15 = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'
	tweak_cal = ['--classifier','chop','--normalize-dv','--normalize-eps-v','2e-2','--avg-frames','2','--apply-calibration','--no-adaptive-input']
	for dlam_nm in [0.2, 0.4, 0.6, 1.0]:
		lab = f'cband_lramps_edfa8_w6p0ns_dlam{str(dlam_nm).replace(".","p")}nm'
		cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns','6.0','--seed','24101','--path-b-analog-depth','12'] + tweak_cal
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ultra,'optics_pack': edfa,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})
	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} lambda drift tests to {queue}")


if __name__ == '__main__':
	main()







-----------------------

.\scripts\append_cband_soa_burst_memory.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	opt_ultra = 'configs/packs/overlays/optics_harsher_nonlinear_ultra.yaml'
	soa = 'configs/packs/overlays/soa_gain3p0_sat_strong.yaml'
	clk_20 = 'configs/packs/overlays/clock_jitter_20ps.yaml'
	cj_15 = 'configs/packs/overlays/comparator_jitter_15ps.yaml'
	tia_100 = 'configs/packs/overlays/tia_bw_100mhz_slew.yaml'

	no_cal = ['--classifier','avg','--avg-frames','1','--no-sweeps','--no-cal']

	# Use a label indicating burst pattern; test.py will still drive random ternary, so this is a placeholder for now.
	for depth in [12, 16]:
		lab = f'cband_soa_burst_d{depth}_w6p0ns_nocal'
		cmd = ['--trials','600','--light-output','--channels','1','--base-window-ns','6.0','--seed','25101','--path-b-analog-depth',str(depth)] + no_cal
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ultra,'optics_pack': soa,'comparator_overlay': cj_15,'clock_pack': clk_20,'tia_overlay': tia_100,'json_out': f"out/{lab}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} SOA burst memory tests to {queue}")


if __name__ == '__main__':
	main()







-----------------------

.\scripts\append_cband_ghz_grade_stack.py
from __future__ import annotations
import json
from pathlib import Path


def main() -> None:
	queue = Path('queue/probes.jsonl')
	queue.parent.mkdir(parents=True, exist_ok=True)

	jobs: list[dict] = []

	emitter = 'configs/packs/overlays/emitter_cband_dfb_typ.yaml'
	opt_ultra = 'configs/packs/overlays/optics_harsher_nonlinear_ultra.yaml'
	soa_fast = 'configs/packs/overlays/soa_fast_tau.yaml'
	tia_fast = 'configs/packs/overlays/tia_bw_3000mhz_slew.yaml'
	clk_10 = 'configs/packs/overlays/clock_jitter_20ps.yaml'  # keep 20 ps; sub-ns will show sensitivity
	comp = 'configs/packs/overlays/comparator_jitter_15ps.yaml'

	weak_cal = ['--classifier','chop','--normalize-dv','--normalize-eps-v','2e-2','--avg-frames','2','--apply-calibration','--no-adaptive-input']

	for win in [1.5, 1.2, 1.0, 0.8]:
		lab = f'ghz_stack_edfa8_w{str(win).replace(".","p")}ns'
		cmd = ['--trials','600','--light-output','--channels','8','--base-window-ns',str(win),'--seed','27101','--path-b-analog-depth','12'] + weak_cal
		jobs.append({'label': lab,'cmd': cmd,'emitter_pack': emitter,'optics_overlay': opt_ultra,'optics_pack': soa_fast,'comparator_overlay': comp,'clock_pack': clk_10,'tia_overlay': tia_fast,'json_out': f"out/{lab}.json"})

	with queue.open('a', encoding='utf-8') as f:
		for j in jobs:
			f.write(json.dumps(j, separators=(',', ':')) + '\n')
	print(f"appended {len(jobs)} GHz-grade stack tests to {queue}")


if __name__ == '__main__':
	main()








-----------------------

.\scripts\append_mvp_and_tile.py
from __future__ import annotations
import json
from pathlib import Path

def append_jobs(jobs: list[dict]) -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)
    with queue.open('a', encoding='utf-8') as f:
        for job in jobs:
            f.write(json.dumps(job, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} MVP/tile jobs to {queue}")

def main() -> None:
    jobs: list[dict] = []

    # Single-channel MVP (one-pass) using low-cost LED + budget front-end.
    mvp_cmd = [
        '--trials','400','--light-output','--channels','1','--base-window-ns','6.0','--seed','7001',
        '--classifier','chop','--chop','--avg-frames','2','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        '--apply-calibration','--mask-bad-frac','0.0','--no-adaptive-input','--no-cold-input','--no-path-b',
        '--decoder-linear','--decoder-samples','200','--use-decoder-for-path-a','--normalize-dv'
    ]
    jobs.append({
        'label': 'mvp_sc1_led_w6p0',
        'cmd': mvp_cmd,
        'emitter_pack': 'configs/packs/tmp_led_array.yaml',
        'optics_pack': 'configs/packs/tmp_codex_optics_medium.yaml',
        'sensor_pack': 'configs/packs/tmp_budget_sensor.yaml',
        'tia_pack': 'configs/packs/tmp_budget_tia.yaml',
        'comparator_pack': 'configs/packs/tmp_budget_comparator.yaml',
        'clock_pack': 'configs/packs/tmp_budget_clock.yaml',
        'thermal_pack': 'configs/packs/thermal_typ.yaml',
        'json_out': 'out/mvp_sc1_led_w6p0.json'
    })

    # 8-channel split tile baseline (low-cost stack, low crosstalk optics).
    tile_cmd = [
        '--trials','400','--light-output','--channels','8','--base-window-ns','6.0','--seed','6023',
        '--classifier','chop','--chop','--avg-frames','2','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        '--apply-calibration','--mask-bad-frac','0.0625','--no-adaptive-input','--no-cold-input','--no-path-b',
        '--decoder-linear','--decoder-samples','200','--use-decoder-for-path-a','--normalize-dv'
    ]
    jobs.append({
        'label': 'tile8_lowcost_w6p0',
        'cmd': tile_cmd,
        'emitter_pack': 'configs/packs/tmp_led_array.yaml',
        'optics_pack': 'configs/packs/tmp_codex_optics_lowct.yaml',
        'sensor_pack': 'configs/packs/tmp_budget_sensor.yaml',
        'tia_pack': 'configs/packs/tmp_budget_tia.yaml',
        'comparator_pack': 'configs/packs/tmp_budget_comparator.yaml',
        'clock_pack': 'configs/packs/tmp_budget_clock.yaml',
        'thermal_pack': 'configs/packs/thermal_typ.yaml',
        'json_out': 'out/tile8_lowcost_w6p0.json'
    })

    # 16-channel dual-wavelength tile (WDM + mode mixing proxy).
    wdm_cmd = [
        '--trials','400','--light-output','--channels','16','--base-window-ns','6.0','--seed','7201',
        '--classifier','chop','--chop','--avg-frames','2','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        '--apply-calibration','--mask-bad-frac','0.0625','--no-adaptive-input','--decoder-linear','--decoder-samples','200',
        '--use-decoder-for-path-a','--normalize-dv'
    ]
    jobs.append({
        'label': 'tile16_wdm_dual',
        'cmd': wdm_cmd,
        'emitter_pack': 'configs/packs/overlays/emitter_dual_wdm.yaml',
        'optics_pack': 'configs/packs/overlays/optics_mode_mix_dual.yaml',
        'sensor_pack': 'configs/packs/tmp_budget_sensor.yaml',
        'tia_pack': 'configs/packs/tmp_budget_tia.yaml',
        'comparator_pack': 'configs/packs/tmp_budget_comparator.yaml',
        'clock_pack': 'configs/packs/tmp_budget_clock.yaml',
        'thermal_pack': 'configs/packs/thermal_typ.yaml',
        'json_out': 'out/tile16_wdm_dual.json'
    })

    append_jobs(jobs)

if __name__ == '__main__':
    main()



-----------------------

.\scripts\append_lowcost_stress.py
from __future__ import annotations
import json
from pathlib import Path

def append_jobs(jobs: list[dict]) -> None:
    queue = Path('queue/probes.jsonl')
    queue.parent.mkdir(parents=True, exist_ok=True)
    with queue.open('a', encoding='utf-8') as f:
        for job in jobs:
            f.write(json.dumps(job, separators=(',', ':')) + '\n')
    print(f"appended {len(jobs)} low-cost stress jobs to {queue}")

def main() -> None:
    jobs: list[dict] = []

    # High crosstalk + drift stress with calibration enabled.
    stress_cmd = [
        '--trials','400','--light-output','--channels','8','--base-window-ns','6.0','--seed','7123',
        '--classifier','chop','--chop','--avg-frames','2','--gate-thresh-mV','0.6','--gate-extra-frames','1',
        '--apply-calibration','--mask-bad-frac','0.0625','--no-adaptive-input','--no-cold-input','--no-path-b',
        '--decoder-linear','--decoder-samples','200','--use-decoder-for-path-a','--normalize-dv'
    ]
    jobs.append({
        'label': 'tile8_ctstress_cal',
        'cmd': stress_cmd,
        'emitter_pack': 'configs/packs/tmp_led_array.yaml',
        'optics_pack': 'configs/packs/tmp_codex_optics_highct.yaml',
        'sensor_pack': 'configs/packs/tmp_budget_sensor.yaml',
        'tia_pack': 'configs/packs/tmp_budget_tia.yaml',
        'comparator_pack': 'configs/packs/tmp_budget_comparator.yaml',
        'clock_pack': 'configs/packs/tmp_budget_clock_heavy.yaml',
        'thermal_pack': 'configs/packs/tmp_thermal_drift_heavy.yaml',
        'json_out': 'out/tile8_ctstress_cal.json'
    })

    # Same hardware, mitigations removed to map failure boundary.
    stress_nomitig_cmd = [
        '--trials','400','--light-output','--channels','8','--base-window-ns','6.0','--seed','7124',
        '--classifier','chop','--chop','--avg-frames','1','--gate-thresh-mV','0.0','--gate-extra-frames','0',
        '--apply-calibration','--mask-bad-frac','0.0','--no-adaptive-input','--no-cold-input','--no-path-b',
        '--decoder-linear','--decoder-samples','200','--use-decoder-for-path-a'
    ]
    jobs.append({
        'label': 'tile8_ctstress_nomitig',
        'cmd': stress_nomitig_cmd,
        'emitter_pack': 'configs/packs/tmp_led_array_stress.yaml',
        'optics_pack': 'configs/packs/tmp_codex_optics_highct.yaml',
        'sensor_pack': 'configs/packs/tmp_budget_sensor.yaml',
        'tia_pack': 'configs/packs/tmp_budget_tia.yaml',
        'comparator_pack': 'configs/packs/tmp_budget_comparator.yaml',
        'clock_pack': 'configs/packs/tmp_budget_clock_heavy.yaml',
        'thermal_pack': 'configs/packs/tmp_thermal_drift_heavy.yaml',
        'json_out': 'out/tile8_ctstress_nomitig.json'
    })

    append_jobs(jobs)

if __name__ == '__main__':
    main()



-----------------------

.\scripts\debug_pathb.py
import os
import sys
import numpy as np
import yaml

ROOT = os.path.dirname(os.path.dirname(__file__))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

from looking_glass.orchestrator import Orchestrator, SystemParams
from looking_glass.sim.emitter import EmitterParams
from looking_glass.sim.optics import OpticsParams
from looking_glass.sim.sensor import PDParams
from looking_glass.sim.tia import TIAParams
from looking_glass.sim.comparator import ComparatorParams
from looking_glass.sim.clock import ClockParams


def load_yaml(path, cls, channels=None):
    base = cls()
    if channels is not None and hasattr(base, "channels"):
        base.channels = channels
    with open(os.path.join(ROOT, path), 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f) or {}
    for k, v in data.items():
        if hasattr(base, k):
            setattr(base, k, v)
    if channels is not None and hasattr(base, "channels"):
        base.channels = channels
    return base


def confusion(optics_pack):
    channels = 8
    sys_p = SystemParams(channels=channels, window_ns=9.0, seed=321, reset_analog_state_each_frame=False)
    emit = load_yaml('configs/packs/overlays/emitter_pathb_premium.yaml', EmitterParams, channels)
    optx = load_yaml(optics_pack, OpticsParams)
    pd = PDParams()
    tia = load_yaml('configs/packs/overlays/tia_pathb_premium.yaml', TIAParams)
    comp = load_yaml('configs/packs/overlays/comparator_pathb_premium.yaml', ComparatorParams)
    clk = ClockParams(window_ns=9.0, jitter_ps_rms=45.0)
    orch = Orchestrator(sys_p, emit, optx, pd, tia, comp, clk)
    rng = np.random.default_rng(777)
    counts = {(t, o): 0 for t in (-1, 0, 1) for o in (-1, 0, 1)}
    errs = []
    for _ in range(400):
        tern = rng.integers(-1, 2, size=channels)
        res = orch.step(force_ternary=tern)
        out = np.array(res['t_out'], dtype=int)
        errs.append(np.mean(out != tern))
        for t, o in zip(tern, out):
            counts[(int(t), int(o))] += 1
    print('pack:', optics_pack)
    for t in (-1, 0, 1):
        row = [counts[(t, o)] for o in (-1, 0, 1)]
        print(f'  t={t}: {row}')
    print('  median BER:', float(np.median(errs)))


if __name__ == '__main__':
    confusion('configs/packs/overlays/optics_pathb_soa_mzi.yaml')
    confusion('configs/packs/overlays/optics_pathb_soa_mzi_clamp.yaml')
    confusion('configs/packs/overlays/optics_pathb_soa_mzi_clean.yaml')



-----------------------

.\scripts\debug_pathb_compare.py
import os
import sys
import numpy as np
import yaml

ROOT = os.path.dirname(os.path.dirname(__file__))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

from looking_glass.orchestrator import Orchestrator, SystemParams
from looking_glass.sim.emitter import EmitterParams
from looking_glass.sim.optics import OpticsParams
from looking_glass.sim.sensor import PDParams
from looking_glass.sim.tia import TIAParams
from looking_glass.sim.comparator import ComparatorParams
from looking_glass.sim.clock import ClockParams


def load_yaml(path, cls, channels=None):
    base = cls()
    if channels is not None and hasattr(base, "channels"):
        base.channels = channels
    with open(path, 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f) or {}
    for k, v in data.items():
        if hasattr(base, k):
            setattr(base, k, v)
    if channels is not None and hasattr(base, "channels"):
        base.channels = channels
    return base


def compare_step_vs_manual(trials=200):
    channels = 8
    sys_p = SystemParams(channels=channels, window_ns=9.0, seed=321, reset_analog_state_each_frame=False)
    emit = load_yaml('configs/packs/overlays/emitter_pathb_premium.yaml', EmitterParams, channels)
    optx = load_yaml('configs/packs/overlays/optics_pathb_soa_mzi_clamp.yaml', OpticsParams)
    pd = PDParams()
    tia = load_yaml('configs/packs/overlays/tia_pathb_premium.yaml', TIAParams)
    comp = load_yaml('configs/packs/overlays/comparator_pathb_premium.yaml', ComparatorParams)
    clk = ClockParams(window_ns=9.0, jitter_ps_rms=45.0)
    orch = Orchestrator(sys_p, emit, optx, pd, tia, comp, clk)
    rng = np.random.default_rng(4321)
    errs_step = []
    errs_manual = []
    for _ in range(trials):
        tern0 = rng.integers(-1, 2, size=channels)
        res = orch.step(force_ternary=tern0)
        errs_step.append(np.mean(np.array(res['t_out']) != tern0))
        dt = float(orch.clk.sample_window())
        Pp, Pm = orch.emit.simulate(tern0, dt, orch.sys.temp_C)
        Pp, Pm, _, _ = orch.optx.simulate(Pp, Pm, dt)
        Ip = orch.pd.simulate(Pp, dt)
        Im = orch.pd.simulate(Pm, dt)
        Vp = orch.tia.simulate(Ip, dt)
        Vm = orch.tia.simulate(Im, dt)
        out = orch.comp.simulate(Vp, Vm, orch.sys.temp_C)
        errs_manual.append(np.mean(out != tern0))
    print('step median', float(np.median(errs_step)))
    print('manual median', float(np.median(errs_manual)))


if __name__ == '__main__':
    compare_step_vs_manual()



-----------------------

.\scripts\debug_pathb_diff.py
import os
import sys
import numpy as np
import yaml

ROOT = os.path.dirname(os.path.dirname(__file__))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

from looking_glass.sim.optics import OpticsParams
from looking_glass.sim.emitter import EmitterParams


def load_yaml(path, cls, channels=None):
    base = cls()
    if channels is not None and hasattr(base, "channels"):
        base.channels = channels
    with open(os.path.join(ROOT, path), 'r', encoding='utf-8') as f:
        data = yaml.safe_load(f) or {}
    for k, v in data.items():
        if hasattr(base, k):
            setattr(base, k, v)
    if channels is not None and hasattr(base, "channels"):
        base.channels = channels
    return base


def debug_diff(optics_pack):
    from looking_glass.sim.optics import Optics
    params = load_yaml(optics_pack, OpticsParams)
    optx = Optics(params)
    emit = load_yaml('configs/packs/overlays/emitter_pathb_premium.yaml', EmitterParams, channels=8)
    rng = np.random.default_rng(0)
    diff_emit = []
    diff_after = []
    for _ in range(400):
        tern = rng.integers(-1, 2, size=8)
        Pp, Pm = optx.rng.normal(0,0,0), optx.rng.normal(0,0,0)  # placeholder



-----------------------

.\scripts\pathb_characterize.py
import argparse
import json
import os
import sys
import numpy as np
import yaml

ROOT = os.path.dirname(os.path.dirname(__file__))
if ROOT not in sys.path:
    sys.path.insert(0, ROOT)

from looking_glass.sim.optics import OpticsParams, Optics
from looking_glass.sim.emitter import EmitterParams
from looking_glass.sim.sensor import PDParams
from looking_glass.sim.tia import TIAParams
from looking_glass.sim.comparator import ComparatorParams
from looking_glass.sim.clock import ClockParams
from looking_glass.orchestrator import Orchestrator, SystemParams


def load_pack(path, cls, channels=None):
    base = cls()
    if channels is not None and hasattr(base, "channels"):
        base.channels = channels
    with open(path, "r", encoding="utf-8") as f:
        data = yaml.safe_load(f) or {}
    for k, v in data.items():
        if hasattr(base, k):
            setattr(base, k, v)
    if channels is not None and hasattr(base, "channels"):
        base.channels = channels
    return base


def build_optics(path):
    params = load_pack(path, OpticsParams)
    return Optics(params)


def transfer_curve(optics, total_mw=2.0, span_mw=4.0, steps=41, dt_ns=9.0):
    diffs = np.linspace(-span_mw, span_mw, steps)
    result = []
    for d in diffs:
        plus_in = np.array([0.5 * total_mw + 0.5 * d])
        minus_in = np.array([0.5 * total_mw - 0.5 * d])
        plus_in = np.clip(plus_in, 0.0, None)
        minus_in = np.clip(minus_in, 0.0, None)
        p_out, m_out, _, _ = optics.simulate(plus_in, minus_in, dt_ns)
        diff_out = float(p_out[0] - m_out[0])
        result.append({
            "diff_in_mw": float(d),
            "diff_out_mw": diff_out,
            "servo_bias_mw": float(optics._servo_bias[0] if optics._servo_bias is not None else 0.0)
        })
    return result


def osnr_growth(optics, passes=6, total_mw=2.0, diff_mw=0.0, dt_ns=9.0):
    plus = np.array([0.5 * total_mw + 0.5 * diff_mw])
    minus = np.array([0.5 * total_mw - 0.5 * diff_mw])
    stages = []
    for _ in range(passes):
        plus, minus, _, _ = optics.simulate(plus, minus, dt_ns)
        total = plus + minus
        diff = plus - minus
        stages.append({
            "total_mw": float(total[0]),
            "diff_mw": float(diff[0])
        })
    return stages


def ternary_histogram(emitter_path, optics_path, tia_path, comp_path, clock_path, channels=8, trials=400, window_ns=9.0, seed=321):
    sys_p = SystemParams(channels=channels, window_ns=window_ns, seed=seed, reset_analog_state_each_frame=False)
    emit = load_pack(emitter_path, EmitterParams, channels)
    optx = load_pack(optics_path, OpticsParams)
    pd = PDParams()
    tia = load_pack(tia_path, TIAParams)
    comp = load_pack(comp_path, ComparatorParams)
    clk = load_pack(clock_path, ClockParams)
    orch = Orchestrator(sys_p, emit, optx, pd, tia, comp, clk)
    rng = np.random.default_rng(seed + 99)
    counts = {(t, o): 0 for t in (-1, 0, 1) for o in (-1, 0, 1)}
    servo_trace = []
    for _ in range(trials):
        tern = rng.integers(-1, 2, size=channels)
        res = orch.step(force_ternary=tern)
        out = np.array(res.get("t_out", tern), dtype=int)
        for t, o in zip(tern, out):
            counts[(int(t), int(o))] += 1
        if hasattr(orch.optx, "_servo_bias") and orch.optx._servo_bias is not None:
            servo_trace.append(float(np.mean(orch.optx._servo_bias)))
    return {
        "counts": {f"{t}->{o}": c for (t, o), c in counts.items()},
        "servo_bias_trace": servo_trace
    }


def main():
    parser = argparse.ArgumentParser(description="Characterize Path B optics stack")
    parser.add_argument("--optics", required=True, help="Optics overlay YAML path")
    parser.add_argument("--emitter", required=True, help="Emitter pack")
    parser.add_argument("--tia", required=True, help="TIA pack")
    parser.add_argument("--comparator", required=True, help="Comparator pack")
    parser.add_argument("--clock", required=True, help="Clock pack")
    parser.add_argument("--channels", type=int, default=8)
    parser.add_argument("--window-ns", type=float, default=9.0)
    parser.add_argument("--trials", type=int, default=400)
    parser.add_argument("--passes", type=int, default=6)
    parser.add_argument("--json", default=None)
    args = parser.parse_args()

    optics = build_optics(args.optics)
    transfer = transfer_curve(optics, dt_ns=args.window_ns)
    optics = build_optics(args.optics)
    growth = osnr_growth(optics, passes=args.passes, dt_ns=args.window_ns)
    hist = ternary_histogram(
        emitter_path=args.emitter,
        optics_path=args.optics,
        tia_path=args.tia,
        comp_path=args.comparator,
        clock_path=args.clock,
        channels=args.channels,
        trials=args.trials,
        window_ns=args.window_ns,
    )
    data = {
        "transfer_curve": transfer,
        "osnr_growth": growth,
        "ternary_histogram": hist
    }
    if args.json:
        with open(args.json, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=2)
    else:
        print(json.dumps(data, indent=2))


if __name__ == "__main__":
    main()



-----------------------

.\scripts\run_tdm_mvp.py
import json
import subprocess
import sys
from pathlib import Path


PY = sys.executable or "python"
ROOT = Path(__file__).resolve().parents[1]
TEST = ROOT / "examples" / "test.py"
OUT = ROOT / "out"


def run(cmd):
    print("RUN:", " ".join(map(str, cmd)))
    r = subprocess.run(cmd, capture_output=True, text=True)
    if r.returncode != 0:
        print(r.stdout)
        print(r.stderr)
        raise SystemExit(r.returncode)
    return r


def call_test(json_out: Path, extra: list[str]):
    cmd = [
        PY, str(TEST),
        "--trials", "240",
        "--channels", "16",
        "--base-window-ns", "10",
        "--classifier", "chop",
        "--avg-frames", "2",
        "--apply-calibration",
        "--no-adaptive-input",
        "--no-cold-input",
        "--no-sweeps",
        "--emitter-pack", "configs/packs/tmp_lowcost_emitter_boost.yaml",
        "--sensor-pack", "configs/packs/overlays/receiver_ingaas_typ.yaml",
        "--tia-pack", "configs/packs/overlays/tia_stage_b2_low_noise.yaml",
        "--comparator-pack", "configs/packs/overlays/tuned_comparator.yaml",
        "--clock-pack", "configs/packs/overlays/clock_jitter_20ps.yaml",
        "--normalize-dv",
        "--path-b-depth", "5",
        "--path-b-analog-depth", "5",
        "--path-b-balanced",
        "--path-b-calibrate-vth",
        "--path-b-calibrate-vth-scale", "0.5",
        "--path-b-calibrate-vth-passes", "64",
        "--path-b-stage-gains-db", "2.0,1.0,0,-0.25,-0.25",
        "--path-b-vth-schedule", "12,12,8,6,5",
        "--json", str(json_out),
        "--quiet",
    ]
    cmd.extend(extra)
    OUT.mkdir(parents=True, exist_ok=True)
    run(cmd)
    with json_out.open("r", encoding="utf-8") as f:
        return json.load(f)


def mvp_suite(rotate: bool = False):
    cases = [
        ("mvp_16_strongsa_k8", [
            "--optics-pack", "configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml",
            "--path-b-sparse-active-k", "8", "--path-b-eval-active-only",
        ]),
        ("mvp_16_lightsa_k4", [
            "--optics-pack", "configs/packs/tmp_codex_optics_medium_voa2_lightSA.yaml",
            "--path-b-sparse-active-k", "4", "--path-b-eval-active-only",
        ]),
        ("mvp_32_strongsa_k8", [
            "--channels", "32",
            "--optics-pack", "configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml",
            "--path-b-sparse-active-k", "8", "--path-b-eval-active-only",
        ]),
        ("mvp_32_strongsa_k16", [
            "--channels", "32",
            "--optics-pack", "configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml",
            "--path-b-sparse-active-k", "16", "--path-b-eval-active-only",
        ]),
    ]
    out = {}
    for label, extra in cases:
        if rotate:
            extra = list(extra) + ["--path-b-sparse-rotate"]
        js = OUT / f"{label}.json"
        res = call_test(js, extra)
        out[label] = {
            "path_b": (res.get("path_b") or {}),
        }
    print(json.dumps(out, indent=2))


def tdm_stability(label: str, optics_pack: str, k: int, epochs: int = 6, trials: int = 240, seed0: int = 11001):
    series = []
    for e in range(epochs):
        seed = seed0 + e
        js = OUT / f"{label}_epoch{e+1}.json"
        extra = [
            "--optics-pack", optics_pack,
            "--path-b-sparse-active-k", str(k), "--path-b-eval-active-only",
            "--seed", str(seed),
            "--trials", str(trials),
        ]
        res = call_test(js, extra)
        pb = res.get("path_b") or {}
        series.append({
            "seed": seed,
            "analog_p50_ber": pb.get("analog_p50_ber"),
            "tdm_symbols_per_s": pb.get("tdm_symbols_per_s"),
        })
    report = {"label": label, "k": k, "epochs": series}
    outp = OUT / f"{label}_stability.json"
    outp.write_text(json.dumps(report, indent=2), encoding="utf-8")
    print(json.dumps(report, indent=2))


if __name__ == "__main__":
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument("mode", choices=["suite", "stability"])
    ap.add_argument("--optics", default="configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml")
    ap.add_argument("--k", type=int, default=8)
    ap.add_argument("--epochs", type=int, default=6)
    ap.add_argument("--trials", type=int, default=240)
    ap.add_argument("--label", default="tdm16_strongsa_k8")
    ap.add_argument("--rotate", action="store_true", help="Use deterministic subset rotation in suite")
    args = ap.parse_args()
    if args.mode == "suite":
        mvp_suite(rotate=args.rotate)
    else:
        tdm_stability(args.label, args.optics, args.k, args.epochs, args.trials)



-----------------------

.\scripts\summarize_tdm.py
import json, sys, csv, glob
from pathlib import Path


def extract_minimal(path: Path):
    d = json.loads(path.read_text(encoding='utf-8'))
    pb = d.get('path_b') or {}
    e2e = d.get('end_to_end') or {}
    out = {
        'file': str(path),
        'analog_p50_ber': pb.get('analog_p50_ber'),
        'ber_ci95_lo': (pb.get('ber_ci95') or {}).get('lo'),
        'ber_ci95_hi': (pb.get('ber_ci95') or {}).get('hi'),
        'sparse_active_k': pb.get('sparse_active_k'),
        'tdm_symbols_per_s': pb.get('tdm_symbols_per_s'),
        'tdm_pj_per_symbol_est': pb.get('tdm_pj_per_symbol_est'),
        'amp_type': pb.get('amp_type'),
        'voa_post_db': pb.get('voa_post_db'),
        'sat_abs_on': pb.get('sat_abs_on'),
        'sat_I_sat': pb.get('sat_I_sat'),
        'sat_alpha': pb.get('sat_alpha'),
        'e2e_tokens_per_s': e2e.get('tokens_per_s'),
        'e2e_combined_ber': e2e.get('combined_p50_ber_independent'),
    }
    return out


def main():
    if len(sys.argv) < 3:
        print('Usage: python scripts/summarize_tdm.py out/*.json out/tdm_summary.csv')
        sys.exit(2)
    *inputs, out_csv = sys.argv[1:]
    rows = []
    files: list[Path] = []
    for pat in inputs:
        p = Path(pat)
        if p.exists():
            files.append(p)
            continue
        # Try glob expansion (supports absolute and relative patterns)
        for g in glob.glob(pat):
            gp = Path(g)
            if gp.exists():
                files.append(gp)
        # Fallback: relative glob via Path().glob
        try:
            for gp in Path().glob(pat):
                files.append(gp)
        except Exception:
            pass
    for p in files:
        try:
            rows.append(extract_minimal(p))
        except Exception:
            pass
    if not rows:
        print('No inputs matched.')
        return
    keys = ['file','analog_p50_ber','ber_ci95_lo','ber_ci95_hi','sparse_active_k','tdm_symbols_per_s','tdm_pj_per_symbol_est','amp_type','voa_post_db','sat_abs_on','sat_I_sat','sat_alpha','e2e_tokens_per_s','e2e_combined_ber']
    Path(out_csv).parent.mkdir(parents=True, exist_ok=True)
    with open(out_csv, 'w', newline='', encoding='utf-8') as f:
        w = csv.DictWriter(f, fieldnames=keys)
        w.writeheader()
        for r in rows:
            w.writerow({k: r.get(k) for k in keys})
    print(f'Wrote {len(rows)} rows to {out_csv}')


if __name__ == '__main__':
    main()



-----------------------

.\scripts\run_scenario_tdm.py
import json
import subprocess
from pathlib import Path


def load_yaml_or_json(path: str) -> dict:
    p = Path(path)
    text = p.read_text(encoding="utf-8")
    try:
        import yaml  # type: ignore
        return yaml.safe_load(text) or {}
    except Exception:
        try:
            return json.loads(text)
        except Exception:
            # very simple key: value parser
            out = {}
            for line in text.splitlines():
                s = line.strip()
                if not s or s.startswith('#') or ':' not in s:
                    continue
                k, v = s.split(':', 1)
                out[k.strip()] = v.strip().strip("\"'")
            return out


def build_cmd_from_scenario(scn: dict, json_out: Path, *, k: int, rotate: bool, trials: int | None = None) -> list[str]:
    py = str((Path(__file__).resolve().parents[1] / '.venv' / 'Scripts' / 'python.exe'))
    test = str((Path(__file__).resolve().parents[1] / 'examples' / 'test.py'))
    cmd = [
        py, test,
        '--trials', str(trials if trials is not None else int(scn.get('trials', 240))),
        '--channels', str(int(scn.get('channels', 16))),
        '--base-window-ns', str(float(scn.get('window_ns', 10.0))),
        '--classifier', 'chop', '--avg-frames', '2', '--apply-calibration', '--no-adaptive-input', '--no-cold-input', '--no-sweeps',
        '--normalize-dv', '--path-b-depth', '5', '--path-b-analog-depth', '5', '--path-b-balanced',
        '--path-b-calibrate-vth', '--path-b-calibrate-vth-scale', '0.5', '--path-b-calibrate-vth-passes', '64',
        '--path-b-stage-gains-db', '2.0,1.0,0,-0.25,-0.25', '--path-b-vth-schedule', '12,12,8,6,5',
        '--json', str(json_out), '--quiet',
        '--path-b-sparse-active-k', str(int(k)), '--path-b-eval-active-only',
    ]
    if rotate:
        cmd.append('--path-b-sparse-rotate')

    # Map packs
    packs = {
        'emitter_pack': '--emitter-pack',
        'optics_pack': '--optics-pack',
        'sensor_pack': '--sensor-pack',
        'tia_pack': '--tia-pack',
        'comparator_pack': '--comparator-pack',
        'clock_pack': '--clock-pack',
        'thermal_pack': '--thermal-pack',
    }
    for key, flag in packs.items():
        val = scn.get(key)
        if isinstance(val, dict) and 'path' in val:
            val = val['path']
        if isinstance(val, str) and val.strip():
            cmd += [flag, val.strip()]
    return cmd


def run_cmd(cmd: list[str]) -> dict:
    p = subprocess.run(cmd, capture_output=True, text=True)
    if p.returncode != 0:
        print(p.stdout)
        print(p.stderr)
        raise SystemExit(p.returncode)
    # The JSON is written to file; return {}
    return {}


def main():
    import argparse
    ap = argparse.ArgumentParser()
    ap.add_argument('scenario', help='Scenario YAML path')
    ap.add_argument('--k', type=int, default=8)
    ap.add_argument('--rotate', action='store_true')
    ap.add_argument('--trials', type=int, default=None)
    ap.add_argument('--json', type=str, default=None)
    args = ap.parse_args()

    scn = load_yaml_or_json(args.scenario)
    out_path = Path(args.json or (Path('out') / 'scenario_tdm.json'))
    out_path.parent.mkdir(parents=True, exist_ok=True)
    cmd = build_cmd_from_scenario(scn, out_path, k=args.k, rotate=bool(args.rotate), trials=args.trials)
    print('RUN:', ' '.join(cmd))
    run_cmd(cmd)
    print('WROTE:', str(out_path))


if __name__ == '__main__':
    main()




-----------------------

.\scripts\run_tdm_sweep.py
import itertools, subprocess, json, sys
from pathlib import Path


def run(cmd):
    print('RUN', ' '.join(cmd))
    subprocess.run(cmd, check=True)


def main():
    root = Path(__file__).resolve().parents[1]
    py = root / '.venv' / 'Scripts' / 'python.exe'
    test_py = root / 'examples' / 'test.py'
    outdir = root / 'out'
    outdir.mkdir(exist_ok=True)
    optics = {
        'strong': 'configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml',
        'light': 'configs/packs/tmp_codex_optics_medium_voa2_lightSA.yaml',
    }
    base = [
        str(py), str(test_py),
        '--trials', '240', '--base-window-ns', '10', '--classifier', 'chop', '--avg-frames', '2',
        '--apply-calibration', '--no-adaptive-input', '--no-cold-input', '--no-sweeps', '--light-output',
        '--emitter-pack', 'configs/packs/tmp_lowcost_emitter_boost.yaml',
        '--sensor-pack', 'configs/packs/overlays/receiver_ingaas_typ.yaml',
        '--tia-pack', 'configs/packs/overlays/tia_stage_b2_low_noise.yaml',
        '--comparator-pack', 'configs/packs/overlays/tuned_comparator.yaml',
        '--clock-pack', 'configs/packs/overlays/clock_jitter_20ps.yaml',
        '--normalize-dv', '--path-b-depth', '5', '--path-b-analog-depth', '5', '--path-b-balanced',
        '--path-b-calibrate-vth', '--path-b-calibrate-vth-scale', '0.5', '--path-b-calibrate-vth-passes', '64',
        '--path-b-stage-gains-db', '2.0,1.0,0,-0.25,-0.25', '--path-b-vth-schedule', '12,12,8,6,5',
        '--path-b-eval-active-only', '--path-b-sparse-rotate'
    ]
    combos = []
    for ch in (16, 32):
        for tier, opt in optics.items():
            for k in (4, 8):
                combos.append((ch, tier, opt, k, 'emitter', 0.0))
                combos.append((ch, tier, opt, k, 'eo_switch', 0.5))
    rows = []
    for ch, tier, opt, k, mode, t_sw in combos:
        tag = f'tdm_sweep_{ch}ch_{tier}_k{k}_{mode}_tsw{t_sw}'.replace('.', 'p')
        out = outdir / f'{tag}.json'
        cmd = base + [
            '--channels', str(ch), '--optics-pack', opt, '--path-b-sparse-active-k', str(k),
            '--tdm-switch-mode', str(mode), '--tdm-switch-t-ns', str(t_sw),
            '--json', str(out), '--quiet'
        ]
        run(cmd)
        rows.append(str(out))
    # Summarize
    summ = outdir / 'tdm_sweep_summary.csv'
    run([str(py), str(root / 'scripts' / 'summarize_tdm.py'), *rows, str(summ)])
    print('Sweep summary at', summ)


if __name__ == '__main__':
    main()



-----------------------

.\scripts\summarize_pathb.py
import json, sys

def pick(d, keys):
    return {k: d.get(k) for k in keys if k in d}

def summarize(path):
    d = json.load(open(path, 'r'))
    pb = d.get('path_b') or {}
    rm = d.get('path_b_return_map') or {}
    out = {
        'file': path,
        'path_b': pick(pb, ['analog_depth','analog_p50_ber','digital_p50_ber','tdm_symbols_per_s','tdm_micro_passes','tdm_recenter_events','tdm_recenter_duty']),
        'return_map': pick(rm, ['median_stage_slope','max_stage_slope'])
    }
    print(json.dumps(out, indent=2))

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print('usage: python scripts/summarize_pathb.py <json> [<json> ...]')
        sys.exit(1)
    for p in sys.argv[1:]:
        summarize(p)



-----------------------

.\tests\test_emitter.py
from pathlib import Path
import sys

import numpy as np

sys.path.insert(0, str(Path(__file__).resolve().parents[1]))

from looking_glass.sim.emitter import EmitterArray, EmitterParams


def test_pushpull_temperature_scaling_once():
    params = EmitterParams(
        channels=1,
        power_mw_per_ch=2.0,
        temp_coeff_pct_per_C=5.0,
        modulation_mode="pushpull",
        pushpull_alpha=0.6,
        rin_dbhz=float("-inf"),
    )
    emitter = EmitterArray(params, rng=np.random.default_rng(42))
    temp_C = 45.0
    ternary = np.array([1], dtype=int)

    Pp, Pm = emitter.simulate(ternary, dt_ns=1.0, temp_C=temp_C)

    temp_scale = 1.0 + (temp_C - 25.0) * params.temp_coeff_pct_per_C / 100.0
    total = params.power_mw_per_ch * temp_scale
    half = 0.5 * total
    add = 0.5 * params.pushpull_alpha * total

    np.testing.assert_allclose(Pp, half + add)
    np.testing.assert_allclose(Pm, half - add)


def test_extinction_temperature_scaling_once():
    params = EmitterParams(
        channels=3,
        power_mw_per_ch=1.5,
        temp_coeff_pct_per_C=7.5,
        modulation_mode="extinction",
        extinction_db=25.0,
        rin_dbhz=float("-inf"),
    )
    emitter = EmitterArray(params, rng=np.random.default_rng(123))
    temp_C = 35.0
    ternary = np.array([1, 0, -1], dtype=int)

    Pp, Pm = emitter.simulate(ternary, dt_ns=1.0, temp_C=temp_C)

    temp_scale = 1.0 + (temp_C - 25.0) * params.temp_coeff_pct_per_C / 100.0
    on = params.power_mw_per_ch * temp_scale
    off = on * 10 ** (-params.extinction_db / 10.0)

    np.testing.assert_allclose(Pp, [on, off, off])
    np.testing.assert_allclose(Pm, [off, off, on])



-----------------------

.\tests\test_scenario_optional_packs.py
from pathlib import Path
import sys

repo_root = Path(__file__).resolve().parent.parent
if str(repo_root) not in sys.path:
    sys.path.insert(0, str(repo_root))

from looking_glass.scenario import build_orchestrator_from_scenario


def test_build_orchestrator_without_optional_packs():
    scenario_path = repo_root / "configs" / "scenarios" / "pd_only.yaml"

    orch, trials, scn = build_orchestrator_from_scenario(scenario_path)

    assert trials == 5
    assert "camera_pack" not in scn
    assert "thermal_pack" not in scn

    # Optional packs should not be instantiated when missing from the scenario
    assert orch.cam is None
    assert orch.therm is None

    # A single step should execute without raising even without optional packs
    result = orch.step()
    assert "ber" in result
    assert "energy_pj" in result



-----------------------

.\tests\test_tdm_flags.py
from pathlib import Path
import sys
import json
import subprocess


REPO = Path(__file__).resolve().parents[1]


def _run(cmd: list[str]):
    p = subprocess.run(cmd, cwd=str(REPO), capture_output=True, text=True)
    if p.returncode != 0:
        raise AssertionError(f"cmd failed: {' '.join(cmd)}\nSTDOUT:\n{p.stdout}\nSTDERR:\n{p.stderr}")
    return p


def test_scenario_tdm_passthrough_runs(tmp_path: Path):
    out_json = tmp_path / "scenario_tdm_out.json"
    cmd = [
        sys.executable,
        "-m",
        "looking_glass.scenario",
        str(REPO / "configs" / "scenarios" / "tdm_16_lightsa_k4.yaml"),
        "--trials",
        "60",
        "--tdm-k",
        "4",
        "--tdm-eval-active-only",
        "--json",
        str(out_json),
    ]
    _run(cmd)
    assert out_json.exists(), "scenario TDM JSON was not created"
    data = json.loads(out_json.read_text(encoding="utf-8"))
    assert isinstance(data, dict) and (data.get("path_b") is not None)
    assert (data["path_b"].get("analog_p50_ber") is not None)


def test_sparse_rotate_smoke(tmp_path: Path):
    out_json = tmp_path / "tdm_rotate_out.json"
    cmd = [
        sys.executable,
        str(REPO / "examples" / "test.py"),
        "--trials",
        "60",
        "--channels",
        "16",
        "--base-window-ns",
        "10",
        "--classifier",
        "chop",
        "--avg-frames",
        "2",
        "--apply-calibration",
        "--no-adaptive-input",
        "--no-cold-input",
        "--no-sweeps",
        "--emitter-pack",
        "configs/packs/tmp_lowcost_emitter_boost.yaml",
        "--optics-pack",
        "configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml",
        "--sensor-pack",
        "configs/packs/overlays/receiver_ingaas_typ.yaml",
        "--tia-pack",
        "configs/packs/overlays/tia_stage_b2_low_noise.yaml",
        "--comparator-pack",
        "configs/packs/overlays/tuned_comparator.yaml",
        "--clock-pack",
        "configs/packs/overlays/clock_jitter_20ps.yaml",
        "--normalize-dv",
        "--path-b-depth",
        "5",
        "--path-b-analog-depth",
        "5",
        "--path-b-balanced",
        "--path-b-calibrate-vth",
        "--path-b-calibrate-vth-scale",
        "0.5",
        "--path-b-calibrate-vth-passes",
        "32",
        "--path-b-stage-gains-db",
        "2.0,1.0,0,-0.25,-0.25",
        "--path-b-vth-schedule",
        "12,12,8,6,5",
        "--path-b-sparse-active-k",
        "4",
        "--path-b-eval-active-only",
        "--path-b-sparse-rotate",
        "--json",
        str(out_json),
        "--quiet",
    ]
    _run(cmd)
    data = json.loads(out_json.read_text(encoding="utf-8"))
    pb = data.get("path_b") or {}
    assert pb.get("analog_p50_ber") is not None
    # Ensure throughput metrics exist in sparse mode
    assert pb.get("tdm_symbols_per_s") is not None




-----------------------

.\docs\MVP_TDM_BOM.md
MVP TDM (Path B) Hardware Outline

Scope
- Single bank: 1632 channels ternary loop with timedivision multiplexing (TDM), 10 ns window, analog depth 5.
- Targets: 00.125 median BER depending on optics tier and K (active channels per frame), 510 Msym/s per bank.

Blocks and Requirements
- Emitter
  - Packs: tmp_lowcost_emitter_boost.yaml (1550 nm), pushpull capable.
  - Notes: stable power per channel, modest RIN; perframe activation scheduling (digital) to drive K active channels.
- Optics (SA + Amp)
  - StrongSA option: tmp_codex_optics_medium_voa2_soa_strongsa*.yaml for K up to 8 at ~0 BER (16 ch) and viable 32 ch.
  - LightSA option: tmp_codex_optics_medium_voa2_lightSA.yaml for K=4 at 0 BER, K=8 around 0.125 BER.
  - Include small VOA/MZM trims per channel if available (future margin) but not mandatory for TDM K8.
- Sensor (PD)
  - Overlay: receiver_ingaas_typ.yaml; balanced PD sum/diff path preferred (sim: --path-b-balanced).
- TIA
  - Overlay: tia_stage_b2_low_noise.yaml; ~15 k, ~55 MHz BW; low input noise; modest peaking.
- Comparator
  - Overlay: tuned_comparator.yaml; perchannel offset trim (DAC) and small perchannel vth trims.
  - Hysteresis small but nonzero; input noise  0.4 mV rms class is acceptable.
- Clock
  - Overlay: clock_jitter_20ps.yaml; 10 ns base window; 20 ps rms jitter OK.
- Thermal
  - Optional pack for drift modeling; periodic recentering supported in software; TDM results robust at K=8 without frequent retrim on sim drift.

Operations Recipe (Simproven)
- Autozero comparator offsets at start: --path-b-calibrate-vth --path-b-calibrate-vth-scale 0.5 --path-b-calibrate-vth-passes 64
- Stage schedule (baseline): --path-b-stage-gains-db "2.0,1.0,0,-0.25,-0.25" --path-b-vth-schedule "12,12,8,6,5"
- Balanced PD and dv normalization: --path-b-balanced --normalize-dv
- TDM sparse activation and rotation:
  - --path-b-sparse-active-k K (K=4 or 8)
  - --path-b-eval-active-only (evaluate BER on active subset)
  - --path-b-sparse-rotate (cycle deterministic subsets)

Performance Map (Sim)
- 16 ch, strongSA: K=8  ~10 Msym/s, 0 BER; K=4  ~5 Msym/s, 0 BER.
- 16 ch, lightSA: K=4  ~5 Msym/s, 0 BER; K=8  ~10 Msym/s, ~0.125 BER (median).
- 32 ch, strongSA: K=8  ~5 Msym/s, 0 BER; K=16  ~10 Msym/s, ~0.0625 BER.

Procurement Notes (nonexhaustive)
- Prioritize: lownoise TIA and comparator with offset DAC; optics SA tier per K; decent emitter power/RIN; stable 10 ns clock.
- Nicetohave: small perchannel optical trims (VOA/MZM), thermal control (TEC) on emitter/sensor.

Reproduction
- See README TDM Path B (MVP recipe) and scripts/run_tdm_mvp.py.




-----------------------

.\docs\DEMO_COMMANDS.md
# Demo Commands

Use these as copy/paste run presets. Extract minimal metrics using the Python helper below or a PowerShell oneliner.

1) 1channel 0BER (6 ns, strongSA)
python examples/test.py --trials 400 --channels 1 --base-window-ns 6 --seed 6201 --classifier chop --avg-frames 2 --apply-calibration --mask-bad-frac 0.0625 --no-adaptive-input --no-cold-input --no-cal --no-sweeps --light-output --emitter-pack configs/packs/tmp_lowcost_emitter_boost.yaml --optics-pack configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa_single.yaml --sensor-pack configs/packs/overlays/receiver_ingaas_typ.yaml --tia-pack configs/packs/overlays/tia_stage_b2_low_noise.yaml --comparator-pack configs/packs/overlays/tuned_comparator.yaml --clock-pack configs/packs/overlays/clock_jitter_20ps.yaml --normalize-dv --path-b-depth 5 --path-b-analog-depth 5 --path-b-enable-amp --path-b-balanced --path-b-calibrate-vth --path-b-calibrate-optical --path-b-calibrate-vth-apply-guard --path-b-vth-schedule 0.3,0.35,0.4,0.45,0.5 --path-b-stage-gains-db=-0.5,-0.25,0,0,0.25 --path-b-guard-gain-mW 0.02 --path-b-return-map --return-map-passes 64 --return-map-deadzone-mW 0.002 --json out/pathb_ch1_strongsa_w6.json --quiet

2) 8channel premium (12 ns)
python examples/test.py --trials 900 --channels 8 --base-window-ns 12 --seed 6233 --classifier chop --avg-frames 2 --apply-calibration --mask-bad-frac 0.125 --no-adaptive-input --no-cold-input --no-cal --no-sweeps --light-output --emitter-pack configs/packs/tmp_lowcost_emitter_boost.yaml --optics-pack configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa_ch8.yaml --sensor-pack configs/packs/overlays/receiver_ingaas_typ.yaml --tia-pack configs/packs/overlays/tia_stage_b2_low_noise.yaml --comparator-pack configs/packs/overlays/tuned_comparator_pathb.yaml --clock-pack configs/packs/overlays/clock_jitter_20ps.yaml --normalize-dv --path-b-depth 5 --path-b-analog-depth 5 --path-b-enable-amp --path-b-balanced --path-b-calibrate-vth --path-b-calibrate-optical --path-b-calibrate-vth-apply-guard --path-b-vth-schedule 0.3,0.35,0.4,0.45,0.5 --path-b-stage-gains-db=-0.5,-0.25,0,0,0.2 --path-b-guard-gain-mW 0.02 --path-b-return-map --return-map-passes 64 --return-map-deadzone-mW 0.002 --json out/pathb_ch8_strongsa_w12.json --quiet

3) 8channel budget (12 ns)
python examples/test.py --trials 900 --channels 8 --base-window-ns 12 --seed 6234 --classifier chop --avg-frames 2 --apply-calibration --mask-bad-frac 0.125 --no-adaptive-input --no-cold-input --no-cal --no-sweeps --light-output --emitter-pack configs/packs/tmp_lowcost_emitter_boost.yaml --optics-pack configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa_ch8.yaml --sensor-pack configs/packs/tmp_budget_sensor.yaml --tia-pack configs/packs/tmp_budget_tia.yaml --comparator-pack configs/packs/tmp_budget_comparator.yaml --clock-pack configs/packs/overlays/clock_jitter_20ps.yaml --normalize-dv --path-b-depth 5 --path-b-analog-depth 5 --path-b-enable-amp --path-b-balanced --path-b-calibrate-vth --path-b-calibrate-optical --path-b-calibrate-vth-apply-guard --path-b-vth-schedule 0.3,0.35,0.4,0.45,0.5 --path-b-stage-gains-db=-0.5,-0.25,0,0,0.2 --path-b-guard-gain-mW 0.02 --path-b-return-map --return-map-passes 64 --return-map-deadzone-mW 0.002 --json out/pathb_ch8_w12_budget.json --quiet

4) 16ch TDM, strongSA, K=8 (0BER at ~10 Msym/s)
python examples/test.py --trials 800 --channels 16 --base-window-ns 10 --seed 7001 --classifier chop --avg-frames 2 --apply-calibration --mask-bad-frac 0.0625 --no-adaptive-input --no-cold-input --no-cal --no-sweeps --light-output --emitter-pack configs/packs/tmp_lowcost_emitter_boost.yaml --optics-pack configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml --sensor-pack configs/packs/overlays/receiver_ingaas_typ.yaml --tia-pack configs/packs/overlays/tia_stage_b2_low_noise.yaml --comparator-pack configs/packs/overlays/tuned_comparator.yaml --clock-pack configs/packs/overlays/clock_jitter_20ps.yaml --normalize-dv --path-b-depth 5 --path-b-analog-depth 5 --path-b-enable-amp --path-b-balanced --path-b-sparse-active-k 8 --path-b-eval-active-only --json out/tdm16_strongsa_k8_w10.json --quiet

5) 16ch TDM, lightSA, K=4 (0BER at ~5 Msym/s)
python examples/test.py --trials 800 --channels 16 --base-window-ns 10 --seed 7002 --classifier chop --avg-frames 2 --apply-calibration --mask-bad-frac 0.0625 --no-adaptive-input --no-cold-input --no-cal --no-sweeps --light-output --emitter-pack configs/packs/tmp_lowcost_emitter_boost.yaml --optics-pack configs/packs/tmp_codex_optics_medium_voa2_lightSA.yaml --sensor-pack configs/packs/overlays/receiver_ingaas_typ.yaml --tia-pack configs/packs/overlays/tia_stage_b2_low_noise.yaml --comparator-pack configs/packs/overlays/tuned_comparator.yaml --clock-pack configs/packs/overlays/clock_jitter_20ps.yaml --normalize-dv --path-b-depth 5 --path-b-analog-depth 5 --path-b-enable-amp --path-b-balanced --path-b-sparse-active-k 4 --path-b-eval-active-only --json out/tdm16_lightsa_k4_w10.json --quiet

6) Deeploop TDM preset (~30 micropasses, ~4.7% duty)
python examples/test.py --trials 800 --channels 16 --base-window-ns 10 --seed 9041 --classifier chop --avg-frames 3 --apply-calibration --mask-bad-frac 0.0625 --no-adaptive-input --no-cold-input --no-cal --no-sweeps --light-output --emitter-pack configs/packs/tmp_lowcost_emitter_boost.yaml --optics-pack configs/packs/tmp_codex_optics_medium_voa2_soa_strongsa.yaml --sensor-pack configs/packs/overlays/receiver_ingaas_typ.yaml --tia-pack configs/packs/overlays/tia_stage_b2_low_noise.yaml --comparator-pack configs/packs/overlays/tuned_comparator.yaml --clock-pack configs/packs/overlays/clock_jitter_20ps.yaml --normalize-dv --path-b-depth 5 --path-b-analog-depth 5 --path-b-enable-amp --path-b-balanced --path-b-sparse-active-k 8 --path-b-eval-active-only --path-b-calibrate-vth --path-b-calibrate-optical --path-b-calibrate-vth-apply-guard --path-b-vth-schedule 0.25,0.3,0.35,0.4,0.45 --path-b-stage-gains-db=-1.0,-0.5,-0.25,0,0.1 --path-b-guard-gain-mW 0.01 --path-b-digital-guard --path-b-digital-deadzone-mV 0.6 --path-b-digital-guard-passes 3 --path-b-tdm-recenter-interval 64 --json out/tdm16_strongsa_d5_g3_r64_k8_tuned.json --quiet

Minimal result extraction
PowerShell:
(Get-Content -Raw out\tdm16_strongsa_k8_w10.json | ConvertFrom-Json).path_b | Select-Object analog_p50_ber, tdm_symbols_per_s, tdm_micro_passes

Python:
python scripts/summarize_pathb.py out/tdm16_strongsa_k8_w10.json out/tdm16_strongsa_d5_g3_r64_k8_tuned.json



-----------------------

.\docs\TODO\quantum_identity_paper_ising_randomness.txt
Heres the short take, then concrete implications for our build + sim.

What this paper actually nails

Resource boundary (clean criterion): In passive linear optics (mirrors/BS/phase shifters + number-resolving detection), every fixed-N fermion state with N2 can show Bell non-locality; bosons can too unless the state is single-mode type, i.e., reducible by a unitary to all particles in one mode. Those single-mode-type boson states are always locally simulable with a generic hidden-variable model. The proof leans on a refined YurkeStoler test and extends to many particles/modes (incl. a special treatment of NOON states). 

s41534-025-01086-x

Operational framing: They purposely exclude extra quantum resources (homodyne, ancillary states, POVMs); the optical network itself is treated as classical, so any non-classical behavior must come from the input state. Thats the point: non-locality is a property of the state, not the interferometer. 

s41534-025-01086-x

Compact signature of classically simulable inputs: For single-mode-type boson states, the Fock coefficients factor into a multinomial over a mode-amplitude vector 

U (effectively all photons started in one mode, then went through a unitary). That structure is exactly what a local model copies. 

s41534-025-01086-x

What this means for our project (telecom-scale analog/RC loop with MDM + camera readout)

Were decisively on the classically simulable side by defaultand thats okay.
We use bright lasers, passive mixing, EDFAs/SOAs (active gain), and intensity cameras. Our inputs are coherent/thermalnot fixed-N Fockand photon number isnt conserved (amplifiers add ASE). The papers non-locality results target fixed-N, passive, number-resolving detection. So we should not expect Bell non-locality to emergeand we dont need it for analog acceleration or wide-fanout I/O. 

s41534-025-01086-x

The single-mode-type = free picture gives us a fast simulator path.
If a stage of our loop can be reduced to one optical mode in  passive unitary  camera, the state statistics are governed by a multinomial over the mode-amplitude vector 

U. That lets the sim propagate just mode amplitudes + multinomial (or Gaussian/Poisson) noise, instead of doing heavy quantum numerics. Treat single-mode-type as a flag for use the cheap sim. 

s41534-025-01086-x

When/if we do want quantum-ish correlations, passive complexity isnt enough.
Per the paper, upping interferometer depth or mode count doesnt create non-local resources; you must prepare non-single-mode states (e.g., two-mode squeezed, independent single-photons, proper NOON) and keep number conservation + number-resolving detection. Thats orthogonal to our throughput goal (and clashes with EDFAs). 

s41534-025-01086-x

Calibration bonus: The YurkeStoler logic is a handy calibration idea even if we stay classical. Those two-mode filters and erasure constructs map cleanly to mode-selective testing in MDM lanterns. We can borrow the procedural scaffolding (not the Bell test) to validate multi-mode mixing matrices and crosstalk empirically. 

s41534-025-01086-x

Concrete upgrades for the simulator (to be more afraid in the right places)

State-class switch: Add a top-level state class toggle per stage:
class = SINGLE_MODE_TYPE | MULTIMODE_FIXED_N | COHERENT | THERMAL.

If SINGLE_MODE_TYPE (our usual): simulate with amplitude vector 

U, multinomial/Poisson shot noise, ASE and saturable-gain models.

If MULTIMODE_FIXED_N (only in lab tests): enable a fixed-N path with event-ready post-selection blocks (YurkeStoler, NOON erasure) and number-resolving counters to validate non-local circuits (for research mode only). 

s41534-025-01086-x

Single-mode reducibility detector:
Given any (bosonic, fixed-N) coefficient tensor 




n
	

, attempt a rank-1 multinomial fit 




(



)







n
	


(
n
N
	

)
	


i
	

U
i
n
i
	

	

.

Success  label as single-mode type  route to fast sim.

Fail  mark as non-single-mode (potentially non-local if you also enforce number conservation and use number-resolving detection). 

s41534-025-01086-x

Noise that breaks the theorems assumptions:
Make ASE, gain saturation, and phase diffusion first-class knobs. Show that even if a stage started as fixed-N, amplification and loss with stochastic re-injection erase the preconditions for any Bell-type advantagethis documents why our production loop is safely classical. 

s41534-025-01086-x

Mode-wise resource dashboard:
At each pass, report: photon number conservation (Yes/No), detection type (intensity vs number-resolving), single-mode reducibility (Yes/No). If its Yes/Yes/Yes, annotate: This stage is locally simulable under passive linear opticsno hidden quantum resource here. 

s41534-025-01086-x

Design takeaways we can steal

Amplitude-vector representation: Treat each passive block as evolving a mode-amplitude vector; keep a multinomial/Poisson sampler for counts. This mirrors the papers compact encoding for single-mode-type boson states and gives us a principled, lightweight sim core. 

s41534-025-01086-x

Event-ready filtering as a metrology tool: The two-particle filter + erasure constructs suggest practical mode-selective diagnostics (we can implement classical analogs with faint beams + gated cameras) to verify the mixing matrix of our MDM/lantern stack. 

s41534-025-01086-x

Dont chase quantum via passive depth: If we ever want genuine quantum resources, invest in sources (SPDC/two-mode squeezing, single-photon emitters) and number-resolving detectors, not deeper passive meshes. Otherwise, lean into classical parallelism + optics-in-the-loop nonlinearity (SOA/EDFA saturation, EOMs) for speed/energy wins. 

s41534-025-01086-x

Bottom line for us

Our telecom-scale, camera-read system doesnt need Bell non-locality to deliver huge bandwidth/parallelism gains; the paper simply clarifies why passive optics alone wont conjure free quantum.

Use their single-mode-type criterion as a guardrail in the sim (cheap path) and as a design sanity check (were not accidentally relying on fragile quantum effects).

If we later explore quantum-enhanced variants, this paper gives the minimal conditions (non-single-mode fixed-N inputs + passive optics + number-resolving) and even test-circuits to start from.

If you want, I can add the single-mode reducibility fit + dashboard to the sim scaffolding next.



<< USER QUESTION LOST >>



Short answer: not with some mods. Your telecom-grade fiber/lasers/EDFAs live squarely in the classical optics regime. To get a quantum processor, you must move into one of two true-quantum photonic stacksand both require major, specialized kit.

What it would actually take

A) Discrete-variable (DV) / single-photon route (KLM/cluster-state, boson sampling, etc.)

Detectors: You need single-photon detectors with very low dark counts and high efficiency at 1550 nm. In practice that means SNSPDs, which are superb but cryogenic (typically <3 K with a closed-cycle cryocooler). Room-temp InGaAs APDs exist at 1550 nm, but theyre gated, noisier, and limit fidelity/rates. 
AIP Publishing
+1

Sources: Indistinguishable, high-purity single-photon sources (quantum dots or SPDC/PPLN waveguides) with active filtering/synchronization. Scaling is brutally sensitive to loss and indistinguishability. 
arXiv

Interferometers + feed-forward: Ultra-low-loss, phase-stable meshes and ultrafast feed-forward switching (for measurement-based logic). Even in fiber, you need precision stabilization and fast EO/AO switches. 
arXiv

Reality check: You can do experiments (QKD, small cluster states, boson-sampling-like demos), but a fault-tolerant DV computer is far beyond telecom gear + tweaks. (Photonic quantum advantage demos exist, but theyre not universal processors.) 
Science

B) Continuous-variable (CV) / squeezed-light route (measurement-based CVQC)

Sources: Strong, stable squeezed states (OPOs) with high dB squeezing;

Readout: Balanced homodyne detection (room-temperature photodiodes are fine);

Big lift: Building large, low-loss CV cluster states and achieving error correction quality (e.g., GKP states) is the hard part. Conceptually more room-temp friendly, practically still very hard to scale fault-tolerantly. 
MDPI
+2
Semantic Scholar
+2

Power / performance reality (ballpark)

Gate/step rate: Ultimately limited by your source repetition (MHzGHz class in best labs) and detector/electronics latency; classical optics can stream at tens100s of GHz equivalent bandwidth, but quantum rates are throttled by single-photon or squeezing hardware.

Energy: Per-photon energy is tiny, but the support systems arent: pump lasers (W-class electrical), and if you use SNSPDs, a cryocooler often draws hundreds of watts. A small multi-channel DV setup is typically hundreds of watts to a few kW wall-plugincluding control and temperature stabilizationyet only drives modest logical throughput compared to GPUs. 
AIP Publishing

Compute class: With aggressive engineering you might build few-mode/few-qubit demonstrators or specialized simulators (e.g., small boson sampling, CV cluster toy models). Competing with a single 5090/A100 on general workloads is not currently realistic for a DIY photonic quantum rig.

How your current fiber-optics platform helps (and where it doesnt)

Helps: 1550 nm ecosystem is perfect for low-loss routing, WDM, fast modulators, and homodyne chains. Its a great base for quantum comms experiments (QKD/time-bin entanglement) and for classical analog photonic acceleration (your RC/AOC-style loops).

Doesnt help enough: To become a quantum processor, you still need:

true quantum light (single photons or squeezed states at scale),

ultra-low-loss interferometers with sub-wavelength phase stability,

high-efficiency detectors (likely cryogenic at 1550 nm for DV),

fast measurement-based feed-forward, and

a fault-tolerance story (error correction & very low loss). 
arXiv
+1

A practical path if you want quantum-flavored progress

Stay classical for compute (your ternary/analog loop) and add quantum-ready ports: polarization-maintaining spurs, low-loss couplers, stabilized local oscillator for homodyne.

CV sandbox (room-temp): Add a small OPO squeezer + homodyne to explore CV inference/filters; great for research, not yet a quantum advantage engine. 
MDPI

DV sandbox (cryogenic): If you really want single-photon logic, budget for an SNSPD system + timing electronics and a stable interferometer tile; aim for post-selected gates and photonic sampling demos first. 
AIP Publishing

Bottom line

Your fiberoptic analog computer is a fantastic near-term acceleratorno cryogenics, high bandwidth, easy scaling, immediate usefulnessvery much like Microsofts AOC philosophy, but classical.

Turning that into a quantum processor is not a small step: its a whole different stack with sources, detectors, stabilization, and error correction that are well beyond telecom gear plus a few parts. For now, treat quantum as a side-track research module, not the main path to performance.






----

context reset due to space.  new thread:


Does this paper's discovery of identity being a possible explanation for quantum effects unlock the ability to turn our classical fiberoptic rig into a quantum-capable processor, with some modifications?  Stick only to exploring implications of this paper specifically - I know it's hugely impractical to get quantum effects (cooling or ridiculously low errors) through previously known methods



----

Short answer: this paper doesnt suddenly turn a classical fiber rig into a universal quantum computer, but it does say something surprisingly strong and very relevant for you: with only passive linear optics (beam splitters, phase shifters, mirrors) and detectors, multi-particle states of identical particles already carry a non-local resource. Concretely, all multi-fermion states and most multi-boson states (i.e., most multi-photon states) can violate a Bell inequality in some passive-optics experimentas long as the state is not reducible to a single mode. Thats a property of the state, not of fancy nonlinear devices. 

s41534-025-01086-x

 

s41534-025-01086-x

 

s41534-025-01086-x

What the paper actually proves (and why it matters for your rig)

Passive linear optics are treated as classical plumbing. Any non-classical behavior you observe must come from the input state you feed that plumbing. Your fibers, splitters, and phase shifters qualify. 

s41534-025-01086-x

Main criterion (Theorem 1): a fixed-N identical-particle state is a genuine non-local resource for passive linear optics iff it is not of single-mode type. Single-mode type means that by some passive unitary 

U you could concentrate all 

N quanta into one mode; those states are the only ones that fail to produce Bell non-locality in this framework. 

s41534-025-01086-x

 

s41534-025-01086-x

Consequences:

No Bell non-locality from any single-particle state (boson or fermion). You need 


2
N2. 

s41534-025-01086-x

For 


2
N2: all fermionic states work; most bosonic states work except the single-mode ones. Photons are bosons, so the practical rule for you is: prepare multi-photon states that cannot be passively collapsed to one mode. 

s41534-025-01086-x

 

s41534-025-01086-x

Does this unlock a quantum-capable processor path for your fiber setup?

Yesbut in a precise sense. The result tells you that with modest modifications you can make your fiber platform demonstrate Bell non-locality and exploit indistinguishability as a usable quantum resourcewithout invoking nonlinear optics or cryogenics. Thats meaningful quantum capability, even if its not general-purpose quantum computation. You would still be operating within passive linear optics + detection, but now with states chosen/engineered to be non-single-mode and fixed-N. 

s41534-025-01086-x

 

s41534-025-01086-x

This is not the same as showing you can run an arbitrary quantum algorithm. The paper speaks about Bell non-locality as an operational resource in this optical model, not about universal quantum computing or fault-tolerant gates. Still, it is a clean, architecture-compatible doorway to quantum behavior in your fiber stack.

What modifications your rig would need (driven only by the paper)

Prepare fixed-N, indistinguishable multi-photon states at your telecom wavelength(s). The theorem is stated for definite particle-number states 



=


1
+

+


=



1





1




=
n
1
	

++n
M
	

=N
	


n
1
	

n
M
	

	

n
1
	

n
M
	

. Weak coherent light wont strictly meet this; heralded or otherwise number-constrained sources do. 

s41534-025-01086-x

 

s41534-025-01086-x

Ensure the state is not single-mode type. Design your source/network so no passive unitary 

U could rotate it to 


,
0
,

,
0

N,0,,0. In practice, populate multiple modes (paths/polarizations/time bins) with nontrivial correlations. 

s41534-025-01086-x

Use only passive linear optics for processing (your existing fibers, couplers, beam splitters, phase shifters) and detectors. Thats exactly the operational class the paper analyzes. 

s41534-025-01086-x

 

s41534-025-01086-x

Implement a Bell-testable layout. The paper highlights the classic YurkeStoler two-mode, two-particle test as a useful lemmastart there to validate non-locality in your platform before scaling. 

s41534-025-01086-x

 

s41534-025-01086-x

What this means for your simulator (what to add/measure)

State class: Add a Fock-space model with fixed 

N over 

M modes (occupation basis) and a check for single-mode reducibility (i.e., does there exist a unitary 



(

)
UU(M) such that 




=


,
0
,

,
0

U=N,0,,0?)those states should be flagged as classically simulable in this framework. 

s41534-025-01086-x

 

s41534-025-01086-x

Optical network: Restrict transformations to passive unitaries on modes (your simulator already models couplers/phase shifters; ensure it composes to a unitary 

U). 

s41534-025-01086-x

Non-locality witness: Include Bell-inequality evaluation (e.g., CHSH-type appropriate to your two-party projections) after distributing modes to sites A/B/ as in the papers abstract setup. Label states/networks by non-local resource vs local. 

s41534-025-01086-x

 

s41534-025-01086-x

Minimal demo templates: Provide built-in circuits for the YurkeStoler configuration (N=2, M=2) so you can regress-test that your modeled states violate a Bell inequality when they should. 

s41534-025-01086-x

 

s41534-025-01086-x

Design heuristics: Prefer multi-mode bosonic states with mode entanglement (not passively concentratable) for quantum-capable runs; mark single-particle cases as guaranteed-local to save simulation time. 

s41534-025-01086-x

What not to infer from this paper

It doesnt claim universal quantum computation, fault tolerance, or speedups for arbitrary algorithms within passive linear optics. It does say indistinguishability + the right multi-mode occupancy is enough to yield Bell non-locality with your existing classical optical toolboxan experimentally actionable bar for quantum capability on your platform. 

s41534-025-01086-x

 

s41534-025-01086-x

Bottom line: If you can (i) prepare fixed-

N, indistinguishable multi-photon states, and (ii) ensure theyre not single-mode type, your fiber rigusing only passive optics and detectorscan demonstrate and exploit a genuine quantum resource (Bell non-locality) that comes purely from particle identity. Thats a clean, near-term, paper-aligned path to quantum-capable behavior in your architecture. 

s41534-025-01086-x

 

s41534-025-01086-x


----


What can that quantum resource be used for, pragmatically?  I understand it's not general quantum computation, but what slice of quantum capabilities does it represent?  Can we achieve more than that with similar hardware expansions or cooperation between multiple rigs?

----


<<I think context collapsed and it reset to ask this question without the paper context again>>


Great question. Heres the pragmatic way to think about the quantum resource that your 1550 nm, WDM/MDM, fiber-loop rig can tapwithout jumping to full, fault-tolerant QC.

What quantum you already have (or can add cheaply)

#Shot-noiselimited coherent light
With decent lasers, low-RIN pumps, and balanced detection, your measurements are fundamentally limited by photon (Poisson) statistics. That gives you:

A reproducible, irreducible noise floor (quantum noise) you can treat as a hardware annealing temperature or a source of calibrated stochasticity for optimization and learning.

Predictable SNR scaling with optical power and bandwidth for principled trades.

#Phase-sensitive amplification (PSA) / squeezing (Gaussian CV)
Drop in a parametric stage ( PPLN waveguide or  HNLF four-wave mixing) and you get:

Quadrature-selective gain with near-0 dB noise figure (3 dB better than phase-insensitive EDFAs).

Squeezed states (310 dB typical) and two-mode entanglement between wavelength/mode pairs.
This is the workhorse quantum resource thats most compatible with your telecom stack. It lives entirely in continuous variables (CV), is room-temperature, and scales via the same WDM/MDM plumbing.

#Homodyne/heterodyne readout
Add local oscillators and balanced InGaAs receivers per /mode to access field quadratures (not just intensity). That:

Dramatically improves measurement sensitivity (shot-noise-limited with modest LO power).

Lets you steer which quadrature the PSA amplifies/suppressesi.e., implement phase-aware, low-noise recurrent dynamics.

These three together are a Gaussian CV toolkit: linear optics (mux/demux, couplers), squeezers/PSAs, and homodyne readout.

What that slice is good forpractically

Quantum-enhanced analog optimization (Ising/QUBO-like)
Time-multiplexed/-multiplexed parametric oscillators act as soft spins. Quantum noise seeds symmetry breaking; PSA/squeezing tunes an effective temperature and barrier-crossing rate. You get CIM-style heuristics with strong energy-per-solution advantages and competitive wall-clock on many dense problems.

Low-noise recurrent analog ML (your reservoir/loop)
PSA+homodyne lets you build deep optical recurrences with less cumulative noise than EDFA-based loops. You also gain complex-valued (quadrature) state evolution, richer feature maps, and tunable contraction/expansion in state space by rotating the LO and PSA phases.

Quantum-limited sensing/inference steps inside the pipeline
When layers reduce to phase estimation or small linear solves, Gaussian CV buys dB-level SNR/energy improvementsuseful for last-mile readout and for stabilizing very deep loops.

Hardware-calibrated stochasticity
The shot-noise floor acts as a principled, physically white randomness source for annealing, dropout-like regularization, and exploration in RL-style controllers.

Correlated noise / entanglement across modes
Two-mode squeezing between s (or MDM modes) gives you controllable correlations. In practice this is handy for consensus dynamics, constraint propagation, or structured priorswithout heavy digital coupling.

What it is not

Not universal, fault-tolerant quantum computing. Gaussian CV + homodyne is classically simulable; for true quantum advantage youd need non-Gaussian resources (single-photon sources, photon-number-resolving detectors, cubic-phaselike operations), which are a very different cost/complexity class.

Can we get more quantum with similar hardware?

Yeswithin Gaussian CV quite a lot; beyond it, only selectively.

More within Gaussian CV (near-term, pragmatic):

Add multiple PSA stages to increase squeezing (within pump-power & loss budgets).

Build cluster-like CV graphs (squeezing + beam splitters across /MDM) for larger coupled recurrent networks.

Use time multiplexing (pulse trains) together with WDM to scale spins/nodes  hardware count.

Employ phase-locked homodynes for mode-by-mode quadrature control.

Beyond Gaussian (harder):

Single-photon/PNR detection, genuine nonlinearity at the single-photon level  opens boson sampling / non-Gaussian ML, but capex/complexity explodes and it clashes with your cheap, robust, telecom OEM philosophy.

Multi-rig cooperation

Classical coupling (easy, scalable): share partial states/costs over fiber; implement measurement-feedback couplings between rigs. This reproduces large-N Ising/RC graphs with minimal latency over metro-scale fiber.

Distributed Gaussian entanglement (doable): send two-mode squeezed light between racks to create correlated subclusters; use homodyne-feedforward to enact effective long-range couplings. Useful for consensus/constraint propagation and noise shaping.

Full distributed QC (not in scope): needs non-Gaussian links or quantum memories; not aligned with cheap telecom constraints.

Concrete upgrades you can bolt onto the current plan

PSA/Squeezer module at 1550 nm

: PPLN ridge waveguide with phase-matching near C-band, or

: HNLF four-wave-mixing PSA (widely used, fiber-compatible).
Expect ~01 dB effective NF in the amplified quadrature; 36 dB squeezing is common in deployed-like conditions.

Balanced homodyne per  (or per MDM mode)

90/10 tap to inject a -matched LO; piezo or EOM for phase lock.

Dual InGaAs PDs, matched TIA, differential ADC.
This turns each readout into a phase-aware, quantum-limited measurement.

Two-mode squeezer between channel pairs

Create entangled -pairs used as correlated reservoirs or constraints.

Use WSS/WDM to pick which pairs are entangled; reconfigure graph couplings optically.

Time-multiplexing inside the same loop

Pump-carved pulse trains give 1010 virtual nodes with one set of optics.

Combine with WDM for time scaling and lightweight inter-pulse couplings via measurement-feedback.

How to use it in your analog-transformer plan

Keep your ternary thresholding (simple, robust), but move the pre-threshold dynamics to PSA-stabilized quadrature space. Youll get:

Deeper effective layers before noise accumulation bites.

Tunable contraction/expansion per layer by PSA gain angle.

Lower energy per useful update vs EDFA loops.

Use two-mode squeezing to couple channels that represent attention heads or constraint pairs; correlated noise helps escape bad basins (annealing-like effect) without digital overhead.

Reserve homodyne LO phases as learnable/programmable knobsyour simulator should treat LO phase, PSA gain, and mixing angles (WSS) as layer parameters, not just passive optics.

What to ask your simulator to model (beyond classical RC)

Shot-noise explicitly (variance  optical power  bandwidth); do not treat it as generic Gaussian noisescale it physically.

Phase-sensitive gain: model PSA transfer 

(

)
G() with orthogonal quadrature de-amplification and near-0 dB NF in the amplified quadrature; include pump-phase drift.

Squeezed input states: correct quadrature covariances and inter-mode correlations for two-mode squeezing.

Homodyne LO phase loops: servo dynamics and residual phase error; SNR vs LO power; ADC quantization vs shot noise.

Loss + dispersion: per-component insertion loss, fiber dispersion over loop length, WSS ripple  all impact the reachable squeezing and stability margins.

Time-multiplexed nodes: pulse walk-off, finite PSA response, inter-pulse crosstalk via gain dynamics.

Annealing schedules: emulate effective temperature via PSA gain ramp and injected quantum/technical noise; compare to classical noise injection at equal energy.

TL;DR

The realistic quantum slice you getwithout breaking your cost modelis Gaussian CV photonics: squeezing/PSA + homodyne on coherent states.

Thats already valuable: lower-noise deep optical loops, CIM-style optimization, structured correlations, and hardware-calibrated stochasticityall with telecom parts.

You can scale it by WDMtime-multiplexing and multi-rig classical/entangled couplings.

To go beyond that (true quantum advantage), youd need non-Gaussian resources, which are a different project.

If you want, I can sketch a PSA+homodyne drop-in for one  of your current loop (BOM + control signals) so you can prototype the Gaussian-CV path on the bench next.





-----

<<better answer after rerunning>>

Short answer: yesyou can make your classical fiber rig quantum-capable (in a precise, testable way) using only passive linear optics and detectors, provided you feed it fixed-N, indistinguishable multi-photon states that arent reducible to a single mode. Thats the papers main criterion for when passive optics can show Bell non-locality, i.e., a genuine quantum resource you can harness without nonlinearity, cryo, or ancillas. 

s41534-025-01086-x

What that resource buys you (practically)

Think Bell-grade non-local correlations rather than universal QC. Concretely:

Device-independent primitives (near-term demos). Any bona-fide Bell violation enables device-independent randomness certification, and (with higher efficiencies & spacelike separation) paths toward DI-QKD prototypes. Your platform meets the papers allowed toolbox (passive optics + number-resolving detection), so the hurdle is mostly source quality, loss, and timingnot new components. 

s41534-025-01086-x

Metrology-aligned states you can certify with only passive optics. The paper shows even NOON-type states fall on the non-local side once you add a simple quantum-erasure twist; those are exactly the states prized for sub-shot-noise phase sensing. So you can verify youve prepared metrologically useful states using the same passive toolbox you use to process them. 

s41534-025-01086-x

On-rig self-tests and calibration. Bell tests become spec checks: (i) Is my prepared state not passively concentratable to one mode? (ii) Do dual-rail encodings survive the network? (iii) Does the YurkeStoler template ring up a violation? This gives you a tight acceptance loop for indistinguishability, mode-matching, and phase stability. 

s41534-025-01086-x

Reservoir/analog ML add-on. Non-classical interference patterns are an extra resource knob in your optical reservoir: you can toggle between classical and identity-powered regimes without changing the hardware classhandy for ablation studies and for pushing beyond classical kernel baselines while staying in fiber.

How to get there on your rig (paper-faithful upgrades)

All within the papers rules (passive unitaries + detectors, fixed-N states):

Sources: move beyond weak coherent light to fixed-N, indistinguishable telecom photons (heralded SPDC in PPLN/W chips; time-bin or dual-rail encodings).

Non-single-mode preparation: ensure population across 2 modes so the state cant be unitarily collapsed to |N,0,,0.

Bell templates built from passive elements: implement the YurkeStoler two-mode, two-particle test as a stock subcircuit; add the papers two-particle filter and quantum-erasure variant to catch NOON-like cases. 

s41534-025-01086-x

Detectors: number-resolving at the ports used for post-selection and Bell readout.

Timing & layout: arrange true spacelike separation for loophole-tight runs; otherwise use event-ready post-selection as in the paper to validate the resource on bench-top scales. 

s41534-025-01086-x

What slice of quantum capability this is (and isnt)

Is: A certified ability to generate and exploit Bell non-local correlations with only passive opticsi.e., an operational quantum resource native to your architecture. Its enough to power DI randomness, foundational tests, resource certification for sensing, and to inject non-classical statistics into analog optical processors. 

s41534-025-01086-x

Isnt: Universal fault-tolerant quantum computing. The paper explicitly scopes out ancillas/POVMs/homodyne and focuses on fixed-N passive optics; it classifies which states are resources under that toolbox and stops short of complexity-theoretic speedups. 

s41534-025-01086-x

Can we push beyond this with similar hardware or multi-rig cooperation?

Within the papers envelope:

Scale N and M. Larger photon number and more modes give you richer non-local configurations while staying passive.

Distributed rigs. Two fiber benches synced by a common clock let you demonstrate spacelike Bell tests (and network-style layouts), still using only passive components at each site. The papers event-ready and dual-rail methods map cleanly to this. 

s41534-025-01086-x

Just outside the envelope (clearly marked as beyond the paper):

Add ancillas or homodyne/POVMs to access single-particle non-locality regimes and continuous-variable tricksbut thats explicitly excluded in the papers definition of classical optics. 

s41534-025-01086-x

What to teach your simulator next (minimum to be honest)

A Fock-space, fixed-N mode model; tag states as single-mode-reducible vs. non-single-mode (the papers Definition/Theorem hinge).

Built-ins for YurkeStoler, two-particle filter, and quantum-erasure circuits; compute a CHSH (or appropriate) Bell witness after event-ready post-selection.

Loss, dark counts, timing jitter, partial distinguishability knobsthen sweep to see when the violation disappears (gives you engineering margins). 

s41534-025-01086-x

Bottom line: You dont get a universal quantum computer out of passive fiber, but you do get a real, certifiable quantum resourceBell non-localityusing exactly the kind of hardware you already like. Thats immediately useful for device-independent primitives, metrology-grade state checks, and injecting non-classical behavior into your analog optical ML loop, and it scales cleanly across multiple rigs. 

s41534-025-01086-x


---


What implications would this Bell non-locality source have for AI training/inference?  Would we be able to significantly boost or unlock new dimensions of training capability vs classical gpu training?  Any papers hinting at this subject?



----


Short answer: Bell-nonlocality (in the exact passive linear optics + number-resolving detectors + fixed-N sense of the paper) is a real quantum resource, but by itself it wont turn general AI training/inference (e.g., transformers) into a GPU-beater. Where it does help is in device-independent randomness/certification, specialized samplers, and analog optimization heuristicsuseful, but not a blanket speedup for SGD, backprop, or attention.

What it can buy you (practically)

Device-independent randomness (DI-RNG). A loophole-tight Bell violation lets you certify fresh randomness for seeding SGD, RL exploration, annealing schedules, etc., with information-theoretic guaranteessomething classical QRNGs cant do. Throughput is set by source/detector rates (typically MHz), so its a niche quality upgrade, not a bulk entropy firehose.

Specialized photonic samplers as ML subroutines. Linear-optical samplers (notably Gaussian Boson Sampling) have been used for things like dense-subgraph discovery and molecular vibronic spectra, which can be repurposed as feature generators or heuristics inside hybrid pipelines. Caveat: classical spoofing/simulation keeps pace in many regimes, so advantages are workload- and scale-dependent.

Analog optimization (Ising/QUBO) heuristics. Bell-qualified states arent required here, but the same photonic plumbing supports coherent Ising machines (CIMs) that deliver attractive energy per solution and competitive wall-clock on certain combinatorial problemsuseful for meta-learning, routing, matching, or schedule subproblems around training. 
arXiv
+1

What it wont do

No known broad speedup for gradient training or transformer inference. The Bell resource classified in the paper tells you which states can show nonlocality with passive optics; it doesnt implement non-Gaussian gates, error-corrected logic, or the dense linear algebra kernels that dominate DL workloads. Quantum-kernel/feature-map ideas exist but their advantages are subtle and strongly data-dependent. 

s41534-025-01086-x

How to use it (sane goals)

DI-RNG sidecar: Build a small fixed-N, non-single-mode Bell tile and harvest certified randomness to seed/perturb classical training runs (and to verify rig integrity over time). Target: correctness > rate. 

s41534-025-01086-x

Hybrid samplers: Prototype a GBS-inspired feature tap for dense-graph or chemistry-adjacent tasks (re-rank proposals from your analog loop / digital model). Keep a classical fallback and benchmark honestly against state-of-the-art classical samplers.

Optimization module: Treat a CIM-like photonic subloop as a problem-specific accelerator called by the trainer (placement, scheduling, routing, matching), where analog heuristics shine. 
arXiv
+1

Simulator upgrades to reflect reality

Bell mode (fixed-N path): Add a switch for passive-Bell experiments: fixed-N Fock states, unitary meshes, number-resolving detection, and a CHSH-style witness. Flag single-mode type states as locally simulable to short-circuit heavy numerics.

DI-RNG throughput model: Include source brightness, heralding rate, detector efficiency/jitter, and spacelike-separation constraints to estimate certified bit rates (typically MHz-class upper bounds).

Sampler hook: Provide a pluggable interface so the photonic sampler can act as a proposal generator within training/inference pipelines; log acceptance/benefit vs classical baselines.

Bottom line

Bell non-locality (as characterized in the paper) is valuable for certification and niche subroutines, not a general accelerator for deep learning. Use it to add verifiable randomness, to explore hybrid photonic samplers, and to slot in analog optimization where it moves the needlewhile keeping GPUs for the heavy lifting. 

s41534-025-01086-x

If you want, Ill sketch a minimal DI-RNG + sampler shelf for one  on your loop (BOM + control + sim knobs) so you can bench this quickly.

----

So this enables true verifiable randomness for guaranteed-secure cryptography? Is that even possible on conventional pc rigs?

Could we run shadow tomography Ising model calculations on crystalline structures?  e.g. ising model for iodine?  If not, what would need to be able to do those?   What would we unlock if we had those calcs? (solar?)   Please give long answers


----


Great questions. Ill break this into two parts(A) verifiable randomness and (B) shadow-tomography + Ising on crystalsthen finish with concrete build/sim steps you can act on.

A) True verifiable randomness: what it is, and whether a conventional PC can do it

What verifiable really means here.
The kind youre pointing at is device-independent (DI) randomness: you certify fresh, private randomness from observed Bell-inequality violations alone, without trusting internal details of the devices. To reach that bar, you must (i) produce a Bell violation with adequately high detection efficiency and (ii) enforce appropriate causal separation/anti-signalling conditions (space-like separation or a fully event-ready causal analysis). In the particular passive linear optics model youve been exploring, the recent result you summarized tells us which states can supply the non-local resource (non-single-mode fixed-N states for bosons; all fixed-N fermion states with 


2
N2) while the optics themselves are treated as classical plumbing. 

s41534-025-01086-x

Bottom line on a normal PC:
A conventional PC alone cannot generate DI-certified randomness. It can harvest bits from an attached quantum optical (or other quantum) box and it can run the extractor proofs, but the certification comes from a loophole-tight Bell test in hardware.

What youd actually need to add to your fiber rig to reach DI-RNG:

Fixed-N indistinguishable photon sources at 1550 nm (heralded SPDC in PPLN/PPLT chips or quantum-dot emitters) configured so the prepared state is not passively reducible to a single mode. Thats the papers criterion for a genuine non-local resource under passive optics. 

s41534-025-01086-x

Number-resolving detection with high efficiency, very low dark counts, and calibrated timing.

A Bell-testable layout (YurkeStolerstyle dual-rail splitting + event-ready post-selection is explicitly discussed in the paper as sufficient to certify non-locality for the right fixed-N states), plus either space-like separation or a rigorous causal diagram showing safe post-selection. 

s41534-025-01086-x

Randomness extractor software on the PC to turn raw violation data + min-entropy bounds into uniform bits.

Throughput reality check. You can get MHz-class raw trial rates with good photonic timing, but DI extraction compresses aggressively (to guarantee security), so certified bit-rates are much smaller than raw detection rates. Its fantastic for quality (provable unpredictability), not for bulk entropy.

B) Shadow tomography Ising model calculations on crystalline structures (e.g., iodine): whats actually feasible

First, terminology sanity:

Shadow tomography / classical shadows (HuangKuengPreskill et al.) estimate many expectation values of an unknown quantum state by applying random measurements to many fresh copies of that same state. Its a quantum measurement protocol (you need repeated state preparation + randomized measurement bases).

Ising model calculations come in two flavors:

Combinatorial Ising/QUBO optimization (find ground states, max-cut, etc.). This can be mapped to coherent Ising machines (CIMs) or other analog photonicsno non-Gaussian quantum required.

Quantum Ising dynamics / many-body correlators, where you actually probe or simulate the quantum state of an interacting spin system and would benefit from shadow-tomography-style measurement schemes.

Given that split:

1) Can your present (classical telecom) fiber loop do shadow tomography of an Ising quantum state?

Not by itself. Shadow tomography requires access to repeated copies of the quantum state and randomized measurements that resolve non-commuting observables. Your current acceleration stack (coherent lasers, passive mixing, EDFAs/SOAs, camera or direct-detect readout) lives squarely in the classically simulable sector the paper calls single-mode-type in spirit (coherent/thermal light with number non-conservation from gain). Its great for analog ML and CIM-like optimization, but it doesnt prepare or maintain a non-Gaussian, many-body quantum state you could tomograph.

If you really want quantum many-body shadows, you need one of: trapped ions, Rydberg arrays, superconducting qubits, cold atoms in optical lattices, or a photonic platform with genuine non-Gaussian resources (single photons + entangling operations) and randomized measurement capability.

2) Could you do Ising optimization on crystal-like graphs with your photonics?

Yesright now. Thats the CIM/analog-Ising path: encode couplings 



J
ij
	

 in a WDM/MDM mixing matrix + measurement-feedback (or / PSA coupling), let the optical phases/amplitudes relax, and read out spins by thresholding. This finds low-energy configurations for large Ising/QUBO instances efficiently in energy and time. Its not shadow tomography, but it solves the optimization flavor of Ising problems at scale.

3) Ising for iodine specifically?

Iodine crystals are not canonical Ising magnets; standard exemplars include LiHoF (transverse-field Ising), CoNbO, certain cobalt salts, and designer platforms (Rydberg chains). If your goal is materials (e.g., photovoltaics), the right toy models are often Hubbard/Heisenberg/exciton-polaron rather than pure Ising. Where an Ising surrogate is useful is: domain formation, binary disorder, lattice gas/ordering transitions, percolationplaces where spins 



{

1
}

i
	

{1} are meaningful proxies (occupy/vacate, defect/clean, orientation choices, etc.).

So what would you need to run true shadow tomography on an Ising-like quantum state in a crystal geometry?

A quantum platform that prepares the state: e.g., a Rydberg-atom array laid out on the crystals graph (square/triangular/kagome), or a superconducting-qubit chip with Ising-like couplings, or trapped ions with tuned long-range 



J
ij
	

.

Randomized measurement access (Clifford/Pauli-like for qubits, or appropriate CV analogues), to implement the shadows.

Many repeated copies of the same state (or fast re-preparation), stable against decoherence during random measurement rounds.

Readout with high fidelity across the lattice to estimate correlators, structure factors, entanglement witnesses, etc.

Your present fiber bench can assist (control, feed-forward, fast classical post-processing, potentially Gaussian CV pre- and post-conditioning), but its not the quantum substrate.

4) What would doing those calcs unlock (esp. for solar)?

If you had reliable shadow-tomography-level access to quantum many-body states on realistic lattice graphs, youd get:

Fast, scalable estimates of many observables at once (2-point/4-point correlators, structure factors) that underlie phase diagrams (ordered  disordered, spin-glass regimes, critical exponents).

Disorder and defect physics at scale: percolation thresholds, domain wall energeticsrelevant to grain-boundary engineering and trap mitigation in perovskite and related photovoltaic materials.

Exciton and polaron transport proxies via spin-mapped models on large lattices, informing light-harvesting pathways and hot-carrier strategies.

Rapid design-of-experiments loops: measure shadows  update effective models  change synthesis/anneal parameterstight feedback for materials discovery.

For iodine itself, the win would be limited unless youre targeting a binary-choice phenomenon (occupancy/orientation/ordering) that maps naturally to Ising degrees of freedom. For PV-adjacent halides (iodide perovskites), Ising-like surrogates for cation orientation, vacancy ordering, or phase segregation can be informative, but richer models (Hubbard/Frhlich) still rule core transport.

What you can deploy now (and how it intersects the papers result)

1) DI-RNG tile (small, focused):

Add a 1550 nm heralded SPDC source + interferometric dual-rail to make fixed-

N, non-single-mode photonic states.

Implement the YurkeStoler splitter/swap and do event-ready post-selection; measure a Bell witness with number-resolving detection. The paper gives both the resource criterion (non-single-mode fixed-N) and concrete two-particle test scaffolding. This is exactly aligned to your optics toolbox. 

s41534-025-01086-x

Feed raw results to an extractor on your PC. You now own a device-independent RNG sidecar you can use to seed training, annealing, or cryptographic protocols (limited rate, maximal trust).

2) Ising/QUBO optimizer (large-N, practical):

Keep your current WDM/MDM loop, but swap EDFA stages for / phase-sensitive amplifiers (PSA) where you can; add balanced homodyne readout to reduce noise accumulation and make gain quadrature-selective.

Implement measurement-feedback couplers (FPGA in the loop) to realize arbitrary 



J
ij
	

 on big dense graphs; threshold to 

1
1 at readout.

This gives you a scalable coherent Ising machine useful today for placement/routing, matching, cluster labelling, and meta-learning subroutines that sit next to your digital training.

3) Simulator upgrades (so you dont fool yourself):

State-class switch: SINGLE_MODE_TYPE | MULTIMODE_FIXED_N | COHERENT | THERMAL. Route SINGLE_MODE-TYPE/COHERENT/THERMAL to the fast amplitude+multinomial path; only engage fixed-N/Fock numerics when you explicitly enter Bell mode.

Single-mode reducibility test for bosons (multinomial fit over a mode-amplitude vector 

U); flag as locally simulable in passive optics when it passesthis is exactly the papers dividing line. 

s41534-025-01086-x

Built-ins: YurkeStoler block; two-particle filter + quantum erasure templates; CHSH (or appropriate) witness calculators; knobs for loss, dark counts, timing jitter, distinguishability. Use these to sweep margins for losing the violation. 

s41534-025-01086-x

TL;DR

Yes, you can get true, verifiable (device-independent) randomness, but not from a PC aloneyou need a hardware Bell test. Your fiber optics are already the right class of classical plumbing; the state must carry the quantum resource (fixed-N, not single-mode). 

s41534-025-01086-x

No, your current classical photonic loop cannot do shadow tomography of quantum Ising states. For that you need a bona-fide quantum many-body platform (ions/Rydberg/qubits/photonic non-Gaussian).

Yes, you can today do large-scale Ising optimization with your photonics and use DI-RNG as a certified entropy sidecar.

If/when you do gain shadow-tomography-grade access to quantum lattice states, you unlock fast, parallel estimation of many observables that matter for materials discovery (including PV-adjacent halides), but pure Ising is only the right model for certain binary phenomena.

If you want, I can sketch a one-page BOM + optical layout for the DI-RNG tile (SPDC source, interferometer, detectors, timing, extractor) and a separate PSA+homodyne CIM loop you can bench this month.


----


>didnt know about Ising models before now.  above optics rig would be capable of those efficiently (classical Ising optimization, not true quantum obviously.  tho this would produce Bell non-locality verifiably-true randomness for fun cryptography too )

>One of Hopfield's students introduced me to the concept of spin glasses as an annealing problem that other simulated annealing problems could map to.

>Yeah I think that can be done cheaply with a secondary circuit that forces SPDC with single photon avalanche detectors collecting the output. Doesnt really require this systems feedback loop to generate the randomness. What is the response and loss rate of modern SPADs?  Is that the primary bottleneck?

can you answer this chat thread?


-----------------------

.\docs\TODO\poor_mans_quantum.txt

"""
We can emulate quantum computation of *ternary* vectors using classical wave superpositions by time-multiplexing the real and imaginary components into two phases  injecting real parts at even time steps (t % 2 = 0) using [A,a]*[B,-b] and imaginary parts at odd time steps (t % 2 = 1) using [A,a]*[b,B] 

This takes a polynomial n number of inputs and sensors to perform, for n "qubits".  However it costs 2^n energy or time to fully recover the full-term accuracy of a real quantum computer.  (No free lunch)  It also requires an underlying wave medium with facets proportional to the 2^n interactions necessary to produce sufficiently-complex waves.  That, or the wave must be run through 2^n times through a simpler medium.

This setup yields structure mathematically comparable to qubit superposition, with term interactions (i.e., Cartesian additions) forming the expected entangled combinations.  However, in physical wave media, each successive combination dilutes energy, and the recursive dot products cause amplitudes to decay  there is no normalization of the expanded terms, making most terms thermodynamically inaccessible or unreadable.  

Thus, although the system theoretically explores the full exponential state space, only a small, coherent subset survives in readable reality, echoing the effect of quantum measurement or collapse via entropy filtering.

Although the full equation is lost, the accessible complexity of terms still available is polynomially proportional to the number of "qubit" inputs.  Thus if the wave can be read quickly (e.g. an algorithm recording this sound wave with faster electric signaling) the subsequent measurement/collapse and quantum computer algorithm behaviors native to true qubits could be emulated via signal boosting/dampening (only for the accessible terms, not those which were lost to entropy)

This daemon (in the Maxwell sense) may be able to boost the signal of lower-complexity terms (those it can read accurately) to produce more complex terms (those it cant read yet) in the next time step, overcoming the above natural entropy losses but paying for them with exponential costs in energy and time.  This more closely approaches the mathematical power (but not engineering power) of a true quantum computer up to diminishing returns on accuracy/energy tradeoffs.  Still no free lunch, but it's the same model.

Hardware recap:  you can scale n qubits by scaling n hardware sensors/modes/etc, but it will still cost 2^n time (and thus energy) to expand the terms to full quantum computer emulation.  Alternatively, add 2^n sensors and scale in n linear time (but still pay 2^n energy).
Also, the underlying complexity of the wave medium must contain an exponential (2^n) number of nonlinear interaction facets for waves to produce that.   (Or it must take an exponential number of mixing passes through a smaller mixer bank)

Is that understanding correct?


-----------------------

.\docs\TODO\reservoir_tuning.txt



Self-wiring neural networks that learn structure without a single gradient

Reservoir computing is elegant: feed signals through a random recurrent network, then train only a simple linear readout. It's fast, cheap, and works surprisingly welluntil you hit a wall. That static, random wiring was never designed for your task, and performance suffers.

Tanguy Cazalets and Joni Dambre take inspiration from neuroscience to fix this. Their method, Hebbian Architecture Generation (HAG), starts from an almost empty reservoir and progressively grows connections between neurons that frequently fire togetherembodying the classic maxim "neurons that fire together wire together." No backpropagation, no gradient descent. Just unsupervised structural plasticity guided by long-horizon correlation statistics.

The results are striking. On speech and audio classification benchmarks, HAG-grown reservoirs consistently beat traditional Echo State Networks and popular plasticity rules like Intrinsic Plasticity or Anti-Oja learning. On smaller datasets (Japanese Vowels, CatsDogs), HAG matches or exceeds gradient-trained LSTMs and GRUswhile training orders of magnitude faster. The method slashes neuron-to-neuron correlation (from ~0.99 to ~0.47 on Speech Commands), expands effective dimensionality, and dramatically improves class separability metrics like silhouette scores and inter/intra-class distance ratios.

What's conceptually satisfying is why it works: by wiring together co-active units over extended time windows, HAG carves out a task-relevant subspace rather than blindly inflating dimensionality. It learns just enough structure to make classes linearly separablenothing more, nothing less.

The broader message: structural self-organization, long studied in biological neural circuits, is a practical route to adaptive machine learning. HAG bridges the efficiency of reservoir computing with the flexibility of learned architectures, all without propagating a single error signal through time. For neuromorphic hardware, physical reservoirs, and low-data regimes, that combination could matter a lot.

Paper: https://nature.com/articles/s41467-025-67137-1


- How does this all play out with our optical reservoir computing system. Think there's any way to utilize fiberoptic equipment to do that similar reservoir tuning, or maybe splitting/merging of parallel channel streams for self-organization? Or is this out of reach of our equipment class? What do you think of this paper and these findings overall


-----

Short answer: yesHAG-style self-wiring absolutely maps to your optical RC stack, and you can do most of it with the telecom-class gear youre already circling (WDM/WSS, VOAs, EDFAs, mode-mixers/lanterns, MEMS fiber switches, MZ modulators, cameras/PD arrays). Below I give (1) what the paper actually claims, (2) how to implement an optical HAG loop with your parts, (3) whats in/out of reach, and (4) what to tweak in your simulator so it doesnt overestimate results.

1) What the HAG paper actually says (in a nutshell)

Core idea. Start with (almost) no recurrent connections and grow edges between neuron pairs whose activities are highly correlated over long windowsa literal neurons that fire together wire together rule. No gradients; just unsupervised structural plasticity plus a simple linear readout. 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

Two variants. A mean-HAG (targets mean activity) and a variance-HAG (targets activity variance) with homeostatic bounds; when a unit is under-active, add an incoming edge from its most-correlated partner; when over-active, prune randomly; keep everything stable via homeostasis. 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

Non-negative (excitatory-only) weights by designgreat fit for optics. Signed weights are emulable with a differential (ww) encoding if you really need negatives. 

s41467-025-67137-1_reference

What it improves. For speech/audio classification, HAG consistently outperforms classic ESNs and popular plasticity rules (IP, Anti-Oja); on small datasets it even matches/exceeds LSTM/GRU; on large data, gradient RNNs still win. 

s41467-025-67137-1_reference

Why it works. It increases effective dimensionality, slashes pairwise neuron correlation (less redundancy), and yields tighter, better-separated clustersi.e., easier linear separation at the readout. 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

Cost vs RNNs. Event-driven rewiring is cheap; still orders of magnitude less compute than multi-epoch BPTT for LSTM/GRU. 

s41467-025-67137-1_reference

2) How to implement HAG with your fiber/MDM/WDM stack

Think of each reservoir node as a photonic tap (a spatial mode, wavelength, or path) with its own detector channel. Weights are implemented by variable coupling/attenuation into that nodes input combiner.

A. Observability (to measure long-window correlations)

Use your InGaAs PD array or the lantern + camera branch to sample each nodes intensity time-series. Accumulate rolling statistics (mean, variance) and correlations over multi-scale windows (sample T_current from a log grid, as in the paper). 

s41467-025-67137-1_reference

B. Structural growth (adding edges to under-active nodes)

Under-active node i: add one strongest-correlate j as a new input:

WDM/WSS path: route _j into is input combiner through a WSS + VOA (w step = - dB on VOA, i.e., a small gain).

MDM path: split js spatial mode with a tunable splitter/MZI (on PIC) or a MEMS variable fiber coupler (bulk) and feed i.

Free-space crossbar (DMD/SLM): add a new mirror/pixel from beam j to is lenslet.

Keep weights non-negative (natural in optics). If you need signed edges, use balanced detection: two inputs into differential photodiodes (w, w) and subtract electronically (doubling channels), exactly what the paper notes. 

s41467-025-67137-1_reference

C. Structural pruning (for over-active nodes)

Over-active node i: randomly prune one incoming edge by nudging that paths VOA up (w in weight space). Dont overthink which one; the rule is deliberately simple. 

s41467-025-67137-1_reference

D. Homeostasis & stability (the echo state analog)

Global gain loop: EDFA gain + per-branch VOAs enforce activity targets (mean-HAG) or variance targets (variance-HAG).

Saturation guard: cap any nodes intensity (_sat) by scaling back its inbound VOAs if it nears camera/PD saturation (paper uses synaptic scaling safeguard). 

s41467-025-67137-1_reference

Practical optical analog of spectral radius1: keep net loop gain  1 across the band; use soft nonlinearities (SOA saturation/MZM) to avoid blow-ups.

E. Where the reservoir lives

Mixing fabric = adjacency. You can realize the recurrent mixing with:

WSS/ROADM mesh (wavelength domain)

Mode-mux/lantern + multi-plane light conversion (spatial domain)

MEMS 3D fiber switch or DMD/SLM (free-space matrix)

Your weight update is literally a routing plus VOA tweak that the HAG control loop decides.

F. Readout

Sum the chosen taps (or camera pixels) with fixed linear coefficients (can be done digitally or with a calibrated analog combiner) and train only W_out by ridge regressionexactly as HAG assumes.

3) Is this out of reach for your equipment class?

Totally feasible. Telecom-class WSS/ROADM + VOAs + EDFAs + detectors already give you the primitives to add one connection, prune one connection, and nudge one weight. The control loop (compute correlations, pick top-rij pairs, apply w/w) lives in a PC/FPGA and runs event-driven (every few hundred msseconds), which matches motorized/thermal hardware timescales. The papers algorithm is explicitly event-driven, unsupervised, and low-compute, so youre imitating the intended regime. 

s41467-025-67137-1_reference

Signed weights? Optional; stick to excitatory-only for v1. The paper deliberately chose that constraint (and it matches optics). If later you want negatives, add differential branches. 

s41467-025-67137-1_reference

Speed. The HAG rewiring loop is slow; inference stays fast (all-optical). Thats fine: youll pre-wire on recorded streams, then freeze for deployment.

4) What to change in your simulator (so its not too happy)

Right now youre seeing 0.0 ternary error because the sim likely ignores messy physical stuff that HAG must fight against. Add these:

Homeostatic windows + event cadence. Implement mean-HAG and variance-HAG exactly: rolling statistics over multi-scale windows, random window draws, w steps, random pruning for over-active nodes, saturation scaling. Expect slower convergence and occasional edge churn. 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

Excitatory-only constraint. Forbid negatives unless using explicit w/w doubling; track channel count blow-up if you enable signed emulation. 

s41467-025-67137-1_reference

Correlation-driven growth. Use long-horizon linear correlations (and consider distance-correlation as a stricter alternative) to pick edges; dont update weights every timestep. 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

Optical non-idealities. Add wavelength/mode-dependent loss/gain ripple, PD/camera shot noise, EDFA ASE, VOA step quantization, WSS crosstalk, phase drift, detector saturation.

Cluster/separability metrics. Track pairwise neuron |r|, CEVD (effective PCA dimension), silhouette/DBI/CH indices across classes; HAGs wins show up here before accuracy. 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

Compute budget. Simulate the event-driven cost vs a gradient RNN baseline so you dont overcredit adaptation speed. 

s41467-025-67137-1_reference

5) What to steal from HAG for your build

Start sparse; grow on data. Dont random-wire a dense ROADM mesh. Begin with input  reservoir stubs and let the system add a single /mode at a time via WSS + VOA. 

s41467-025-67137-1_reference

Use variance-HAG for richer dynamics (it tended to push spectral radius/effective dimensionality more), but keep a saturation guard. 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

Measure and minimize redundancy. Design your controller to reduce |r| across channelsif average |r| creeps up, favor adding edges from less correlated partners or prune lock-step paths. 

s41467-025-67137-1_reference

Tune to the task. HAG shines on classification / low-data; forecasting gains are smaller. For long-horizon prediction, keep some scheduled pruning and lower loop gain to preserve temporal memory. 

s41467-025-67137-1_reference

6) Answering your specific questions

Can we do HAG-like tuning with fiber gear? Yes. Use WSS/VOA/EDFA knobs to add/prune/scale edges; compute correlations from PD/camera streams; iterate event-driven. This is squarely in your equipment class.

Split/merge for self-organization? Exactlysplit high-corr channels with a tunable coupler and merge into under-active nodes; prune by closing VOAs; all controllable from a microservice.

Is this out of reach? No. The only hard bit is control software and plumbing.

What do you think of the paper overall? Its a strong, biologically-inspired structural plasticity result that: (i) fits optics (non-negative weights), (ii) improves separability via decorrelation/just-enough dimensionality, and (iii) stays compute-light. Caveats: the biggest wins are on small/medium classification; LSTM/GRU still rule big data; forecasting gains are modest. 

s41467-025-67137-1_reference

 

s41467-025-67137-1_reference

If you want, I can sketch a minimal HAG controller (Python) that sits on top of a hypothetical ROADM/WSS API: it reads rolling PD/camera stats, chooses (i*,j*) pairs, and issues add/prune/w commands on the optical fabric.


-----------------------

.\docs\TODO\facebook_questions_saved.txt
Based on what you pasted (SCMP archive text) and what I can corroborate via a separate write-up, heres the most likely how they did it and the key limitations/tradeoffs vs our macro-telecom / ternary-tolerant approach.

What LightGen most likely is doing (mechanistically)

The consistent clues are:

all-optical computing chip (i.e., not photonic interconnects + electronic MACs) 

first time supporting large-scale semantic media generation models 

prior all-optical chips were small-scale classification tasks and optoelectronic cascading/multiplexing killed speed 

they built a new architecture + new training algorithm + high integration density 

That strongly suggests a monolithic/integrated photonic neural network where:

Linear transforms happen optically
Likely with some combination of:

interference meshes (MachZehnder interferometer arrays), and/or

microring resonator banks (wavelength-selective weighting), and/or

diffractive / Fourier optics on-chip (lens/DOE equivalents), and/or

a spatiotemporal latent space implemented via waveguides + delays + recirculation (their optical latent space reads like let the light live inside a structured, expandable mixing manifold, not just pass once through a mesh).

Nonlinearity and state are handled without electronics in the loop (or with minimal electronics)
For generative models, they need either:

native optical nonlinearity (harder), or

a clever iterative / fixed-point / dynamical system where the generation emerges from repeated propagation + saturation + coupling (more plausible).

Training is adapted to photonics
The write-up I found says they published in Science on Dec 19 and frames the result as an all-optical computing chip for generative models, quoting Chen Yitong on why this was hard previously. 
Even if the SCMP phrasing about unsupervised is perfectly accurate or not, the direction is credible: train in a way that matches the hardwares natural dynamics (and avoids needing extremely precise gradient transport through noisy/quantized photonic knobs).

Limitations they almost certainly have (and where we may differ)

1) I/O bottleneck still exists

Even if compute-in-flight is fast as light, you still pay to:

encode inputs into light (lasers/modulators),

read outputs back (photodiodes/cameras),

synchronize, calibrate, and digitize when needed.

This is the classic photonic-compute gotcha: you can make MACs cheap, but you cant dodge I/O + control overhead unless your whole workload lives optically end-to-end.

Our advantage (if we lean into it): the pure analog loop idea is exactly the right instinctminimize DAC/ADC crossings, keep state in the medium.

2) Precision, drift, and calibration

Integrated photonics fights:

temperature drift (phase shifts),

fabrication variation,

crosstalk between tightly packed elements,

limited effective bit-precision unless you spend on stabilization/control.

Your ternary trick is explicitly a drift-tolerance strategy: if your simulator is getting 0.0 error on naive assumptions, it should fear the real worlds continuous driftbut ternary/low-precision-robust training is one of the best counters.

3) Reconfigurability vs baked weights

A lot of photonic chips are:

either programmable but slow to reprogram (thermo-optic tuning, etc.),

or semi-fixed (fabricated patterns / passive diffractives),

or programmable but with lots of electronic tuning overhead.

Our telecom/macro approach is bulky, but its often more hackable and replaceable: swap modules, reroute fibers, change attenuators, etc.

4) Scaling isnt free linear tiling

Tiling optical compute faces:

distribution of stable optical power,

managing phase/coherence (if coherent),

thermal and packaging complexity,

yield (for large photonic die),

andagaincontrol/monitoring overhead.

So no real scaling limit is emotionally true in the physics sense, but practically false in the systems-engineering sense.

5) Task scope may be narrower than implied

If their generative demos are strongly shaped to their hardware (very plausible), the chip may excel at a family of models/operators rather than general transformer inner layers.

That doesnt make it badit just means its more like:

a very fast special operator (e.g., optical latent operator / diffusion-ish step), than

a general programmable computer.

Do they have limitations we dont?

Two big ones you might avoid with the macro-telecom path:

Yield / fabrication lock-in: you arent betting everything on a single dense photonic die that has to be perfect.

Thermal cross-talk on chip: your components are physically separated; you can isolate, heatsink, and over-instrument them.

But youll likely have other limitations they avoid:

Size / latency / energy per useful op might be worse for macro setups (fiber delay lengths, discrete components, big drivers).

Bandwidth density (ops/s per cubic cm) will be vastly better on-chip for them.

Bottom line

My best read: LightGen is probably a high-integration photonic dynamical compute fabric designed so generative behavior emerges with minimal electronic cascading, and its a real step beyond photonic CNN toy demos. 
But it almost certainly still has the classic photonic pain points: I/O, calibration, drift, tuning overhead, and narrower programmability than a GPU.

If you want, paste the actual Science paper title/DOI (or upload it if you have it) and Ill do a much more concrete, line-by-line what they built + exactly what we should copy/avoid pass.
Mon 1:52PM
You sent
This is a strong, mostly-correct framing, and importantly its not hype in the way most 1000 faster headlines are. Ill do a plausibility / sanity pass, separating:

1. What is solid and accurate


2. What is directionally right but overstated


3. What to tighten to avoid self-owning the argument


4. How this maps cleanly onto your project (and AOC)




---

1. What you got right (and this is the core insight)

 The speedup is class-conditional, not absolute

You correctly reject the faster calculator framing.

The speedup exists because:

The problem is naturally continuous

The physics already solves the equation

Digital hardware is emulating what the medium does for free


Thats not marketingthats literally how analog computing works when it works.

This matches:

Peking Universitys RRAM solver

Microsoft AOC

Optical VMM / lens-based convolution

Photonic reservoir computing


All of them exploit the same fact:

Some computations are more naturally represented as fields than as instructions.





---

 The century-old problem is correctly identified

You nailed this. Analog computing historically failed because of:

1. Error accumulation


2. No convergence guarantees



This is exactly why digital wonnot because it was faster, but because it was predictable.

Whats new (and genuinely new):

Precision enforced by dynamics, not representation




This is the key modern shift, and it shows up everywhere:

Contractive systems

Fixed-point solvers

Energy minimization

Lyapunov stability

Implicit layers / deep equilibrium models


This is not a minor fix. Its a foundational reframing.


---

 The matrix is the memory is not rhetoric

This is a physically correct statement in:

RRAM crossbars

Optical masks / lenses

Phase-change materials

Holographic storage

Project Silicastyle volumetric encoding


It directly attacks the memory wall, which is the dominant cost in modern AI.

This is why:

GPUs scale poorly in energy

TPU-like accelerators are brittle

SRAM proximity matters more than FLOPs


So yes: this targets the real bottleneck.


---

2. Where its right but slightly overstated

 O(1) time needs a qualifier

The physical solve is effectively constant-time with respect to matrix size, but bounded by:

Wire RC constants

Optical path length

Settling time / relaxation time

Noise floor


A more defensible phrasing:

Time complexity weakly dependent on matrix size, dominated by physical settling constants rather than algorithmic loops.




Still devastating for digitalbut safer.


---

 No real scaling limit

There are scaling limits, just not the ones digital people think about.

Analog limits are:

Crosstalk

Thermal drift

Fabrication mismatch

Calibration overhead

Signal-to-noise ratio

Fan-in / fan-out geometry


The key difference:

These limits scale with physics, not with parameter count.




So linear tiling is feasiblebut not infinitely free.


---

 GPU datacenter replacement is true only asymptotically

Near-term reality:

These systems are co-processors

They accelerate inner loops, not full stacks

Digital still handles control, routing, verification


Your later framing (layered computation) already fixes thislean on that.


---

3. What I would tighten to make this bulletproof

Here are a few edits that make this argument unassailable instead of merely impressive.

Replace:

1000 faster than Nvidia GPUs




With:

For memory-bound linear algebra and optimization problems, analog physical solvers collapse algorithmic depth into material dynamics, yielding order-of-magnitude improvements in energy and wall-clock time.




Same meaning. No headline bait.


---

Replace:

Precision does not require discreteness




With:

Precision does not require discrete representationonly stable, contractive dynamics.




That sentence alone is publishable.


---

Clarify the training claim

This part is ambitious but plausible:

Burn to glass as you go, never convert to digital




Better phrased as:

Inference-first

Training as hybrid

Weights slowly annealed / re-encoded


This matches what Microsoft, IMEC, and photonic RC groups actually do.


---

4. How this maps onto your project (this is the important part)

Your ternary trick is not a gimmick  its strategic

Microsoft AOC:

Uses continuous values

Requires calibration and correction

Pays precision tax in optics + sensors


Your approach:

Ternary weights

Wide noise margins

Physics-friendly quantization


This is extremely smart, because:

It tolerates drift

It simplifies readout

It reduces calibration burden

It maps well onto optical phase/amplitude buckets


You are trading:

A bit of theoretical optimality for:

Massive practical robustness


Thats how real hardware wins.


---

Telecom hardware is not worse  its more mature

Academic photonic chips:

Amazing demos

Fragile

Hard to manufacture

Years from scale


Telecom optics:

Temperature hardened

Field-tested

Cheap at volume

Designed for long-haul stability


Youre effectively saying:

Lets accept some inefficiency to buy decades of engineering maturity.




That is exactly how Ethernet beat exotic interconnects.


---

Your architecture vs AOC / Peking chip

Aspect	Peking RRAM	Microsoft AOC	Your approach

Medium	Electrical (RRAM)	Free-space optics	Fiber + optics
Precision	Analog + iterative	Analog + digital twin	Ternary + dynamics
Memory	Crossbar	Optical mask	Fiber / phase
Scalability	Chip-limited	Optics-limited	Network-limited
Robustness	Medium	Medium	High
Cost curve	ASIC-heavy	Lab hardware	Commodity telecom


You are not copying themyou are choosing a different point in the design space.


---

5. Final verdict (honest, not hype)

Your message is:

Conceptually sound

Technically literate

Aligned with current research

Not obviously delusional

Ambitious but grounded


The only real risk is overclaiming timeline and scale, not the core idea.

And crucially:

You are not late.




Microsoft, Peking, UF, etc. are proving principles. Youre exploring implementation paths that academia usually ignores.

Thats exactly where breakthroughs actually come from.

If you want, next we can:

Rewrite this as a tight technical memo

Or map it directly onto a funding / build plan

Or translate it into simulator requirements so the software stops lying to you


Just say which direction.


-----------------------

.\docs\TODO\handcrafting.txt
esoteric question:  how impossible would each component in our optical rig be to recreate with hand tools, relatively commonly-available chips and resources, and a highly-intelligent, highly-dexterous robot?
Thought for 34s

Love this question. Heres a pragmatic how-hard-is-it-to-recreate map of the main parts in your 1550 nm, multi-, all-optical loopassuming: hand tools, modest benchtop gear, common COTS chips, lots of surplus telecom, and one very smart, very dexterous robot.

Legend:

 doable with benchtop tools + surplus

 possible but painful / specialized gear helps

 basically requires a fab or exotic materials

Sources & gain

DFB/EML 1550 nm lasers (in TOSA/SFP/SFP+)  Recreate? Extract from surplus transceivers:  (robot helps with delicate desolder/rework). Build from scratch?  (epitaxy, gratings).
Tip: salvage DFBs + pigtails; reuse the built-in isolator when possible.

Tunable C-band lasers (XFP/SFP+ DWDM)  Reuse modules?  (control via MDIO/IC). Build tunability?  (integrated heaters/etalon).

SOA (semiconductor optical amplifier)  From die?  (needs precise coupling + TEC + wire-bond). Fabricate?  (IIIV epitaxy).

EDFA (erbium fiber amplifier)  Assemble module?  (buy Er-doped fiber, 980/1480 nm pumps, WDMs, isolators; fuse/splice; needs a good fusion splicer). Make Er fiber? .

Modulation / nonlinearity

LiNbO Mach-Zehnder modulators  Home-build? . Reuse used parts?  (control V with RF driver).

Electro-absorption modulators  Reuse?  (inside EML packages). Fabricate? .

Saturable/nonlinear fiber elements (HNLF, NLPF, NOLM)  Assemble?  (needs precise loop lengths/splices; robot helps). Fabricate fiber? .

Wavelength / mode handling

WDM mux/demux (AWG/PLC, thin-film filters)  DIY? AWG/PLC ; thin-film stacks ; buy surplus? .

Circulators / isolators  DIY?  (magneto-optic crystals + sub-rad alignment). Buy surplus? .

Couplers/splitters (fused biconical taper)  DIY with fusion splicer + microheater?  doable; buy?  cheap.

Photonic lantern (MDM fan-in/out)  DIY (heat-and-pull in capillary, robot aligns fibers)?  hard but hobby-lab plausible with patience; buy? .

Mode scramblers / few-mode fiber  Buy? ; DIY tapering? .

Switching / attenuation / control

MEMS fiber switches (1N)  DIY? ; buy surplus? .

VOA (microbend/mechanical)  DIY?  (microbend jig with stepper); integrated VOA? .

Polarization controllers (fiber squeezer loops)  DIY?  (3-paddle squeezer with servo); PM splicing .

TEC control, laser current drivers, PIDs  DIY analog/digital?  (off-the-shelf driver ICs; robot can assemble fine-pitch).

Detection / readout

InGaAs photodiodes (discrete)  Buy?  (packaged). Die + wire-bond?  (robot helps). Fabricate? .

TIAs / ADCs  DIY?  (RF layout care).

InGaAs line/area cameras  Build from sensor?  (hard); buy used? ; Si barcode/CMOS at 1550 nm?  (wrong band).

Fiberwork & mechanics

Splicing / connectorization (LC/APC, PM)  With used fusion splicer? ; by hand polishing?  (slow, but possible).

FBGs (Bragg gratings)  Write your own?  without UV laser + phase mask + H loading; buy? .

Precision opto-mechanics (stages, holders)  3D-print + metal shop?  (robot great at repeatable alignment).

What your robot materially changes

Safe laser/TOSA extraction, re-pigtailing, and sub-micron butt-coupling to chips.

Repeatable fusion splicing, tapered coupler/lantern pulls.

Fine wire-bonding for bare SOA/PD dies (if you go that route).

High-throughput polishing of APC ferrules (consistent 8 geometry).

Automated alignment/locking of free-space benches (if you hybridize).

Red / Yellow / Green list

GREEN (build/assemble in a garage): drivers, TEC/PIDs, VOAs (mechanical), fiber couplers (buy or DIY), polarization controllers, surplus WDMs/circulators, fusion splicing/connectorization, EDFA assembly from bought Er-fiber + pumps, servod benches, control firmware.

YELLOW (robot helps; still touchy): photonic lanterns, NOLM fiber loops, PM splicing, bare-die SOA/PD packaging, compact ruggedized modules, multi- timing/sync backplanes, analog front-end RF boards (low-noise TIAs).

RED (dont try to fabricate): laser/PD/SOA chips, LiNbO/PLC/AWG/isolators at component level, FBG writing, high-quality thin-film filters.

Two realistic from-scratchish paths

Surplus-centric 1550 nm fiber rack (your plan):
Buy DFBs/EDFAs/WDMs/isolators/switches as modules. You (and the robot) do the system-level integration, splicing, packaging, calibration, and control. This is the fastest route to a serious, stable multi- loop.

Free-space 850940 nm MVP:
DMD/SLM + lenses + Si machine-vision camera for one-pass readout; add loop with fast EO modulator if desired. Uses cheap parts, showcases wide-fanout readout, teaches controlthen port the architecture to 1550 nm fiber.

Where hand-crafted wins vs. buy

Wins: custom photonic lantern geometries, micro-mechanical VOAs/scramblers, bespoke packaging, multi-module orchestration (your co-processor personality), swappable loop topologies.

Buy: anything that required epitaxy, crystal growth, wafer-level lithography, or magneto-optics.

Feasibility snapshot (months, not years)

Week 14: bench power/TEC/current control + single- DFB path, PD+TIA readout, closed-loop PID, basic WDM plumbing.

Month 23: 48  mux/demux, polarization control, microbend VOA, EDFA integration, stability scripts.

Month 36: MDM fan-in/out trial (buy one; attempt one DIY taper), MEMS 1N switching, multi- timing, ternary thresholding & analog loop.

Safety & sanity

1550 nm is invisible but still Class 3B/4 dangerousalways APC connectors, shutters, and interlocks.

Fiber shards are nastydedicated mats and disposal.

Thermal runaway: current drivers must have fast hardware limits + TEC interlocks.

Bottom line

You can assemble a highly capable multi- 1550 nm optical co-processor almost entirely from surplus and COTShand tools + good splicer + your robot.

You cannot realistically fabricate the active photonic chips or nonreciprocal parts. Thats fine: your moat is system engineering, not chip growth.

If you ever want a purely hand-made flex: photonic lanterns, VOAs, custom fiber couplers, and rugged packaging are the sweet spot for craft + robotics.


-----------------------

.\docs\TODO\multiplexing_100_channels.txt
Skip to content
Chat history



You said:
are there Microcomb Sources for 1550nm fiberoptic equipment that can split to many wavelengths? or is this a chip-only thing?  whats the typical pricing and capability range if so?
ChatGPT said:

Thought for 4m 34s
Yes  1550 nm microcomb (Kerr / DKS microresonator) sources exist as usable fiber-coupled hardware, not just bare chips. Theyre chip-based internally, but vendors sell them either as bare die or as fiber-packaged modules (often a 14-pin butterfly). 
Deeplight
+1

What you actually get (and how you split it)
A microcomb source typically outputs one fiber carrying many evenly spaced lines. To split to many wavelengths, you add a DWDM mux/demux (often an AWG) to fan those lines out into individual ITU channels/ports. (The demux is usually much cheaper/easier to source than the comb generator itself.) 
Shenzhen Lightwit Photonics

Typical capability range (microcomb side)
Example specs from a commercial 1550 nm Kerr microcomb generator product line:

Center wavelength: 1550 nm 
Deeplight
+1

Line spacing (FSR): customizable 101000 GHz 
Deeplight
+1

Optical bandwidth: 2030 nm (3 dB), with a note that this corresponds to >35 lines at 100 GHz spacing 
Deeplight

Packaging: 14-pin butterfly option (fiber-packaged) or bare die 
Deeplight
+1

Pump: commonly external (not included), typically driven by a tunable laser scan 
Deeplight
+1

So: not chip-only, but often not fully turnkey either (because the narrow-linewidth tunable pump + control is a big part of the system). 
Deeplight
+1

If you just want many ITU wavelengths in fiber (not necessarily microcomb)
There are also DWDM comb source boxes aimed at telecom/test workflows that provide many ITU-grid channels (implementation may be spectral slicing / other non-microcomb approaches). For example, MPBC advertises up to 100 channels, 50 GHz or 100 GHz spacing, spanning 15241620 nm, with flatness < 2 dB and tight ITU-grid deviation. 
optilab.com

Pricing reality (anchors you can budget from)
Published list prices are uncommon for microcomb modules (often request quote), but you can bracket the system cost with real market anchors:

The pump laser / tunable laser youll likely need can easily be $30k$45k even on the used market (e.g., an Agilent/Keysight 81600B listing at $37,447, and a used Santec TSL-570 listing at $45,000). 
assetrelay.com
+1

A non-microcomb alternative (bank of discrete lasers) can be very expensive at high channel counts: Optilab lists a 40-channel DWDM source bank from C$86,955 and an 80-channel version from C$170,972. 
optilab.com

The DWDM demux needed to split wavelengths can range wildly; low-cost 3rd-party listings show 80-ch 50 GHz AWG mux/demux around US$600$900 (quality/specs vary a lot here). 
Shenzhen Lightwit Photonics

Rule of thumb: a lab-usable multi-wavelength setup using a microcomb is often tens of thousands once you include the pump + control, and can climb higher depending on how turnkey/stable/locked you need it.

What to decide first (so you buy the right comb)
Do you need strict ITU-grid absolute accuracy (plug into DWDM transceivers) or just lots of wavelengths for testing?

Channel spacing: 50 GHz vs 100 GHz (microcomb FSR choice matters; so does your demux). 
Deeplight
+1

Per-line power/OSNR: microcombs often need EDFAs / flattening if you want many usable lines at decent power. 
Deeplight
+1

If you tell me whether your use-case is (A) coherent carriers for comms, (B) DWDM component testing, or (C) just many lasers for a lab setup, I can narrow it to the most cost-effective architecture (microcomb vs sliced-comb box vs laser bank) and what specs actually matter.

You said:
up til this we've just been assuming we get 8 lasers and multiplex them in a fiberoptic line, aiming for 10-40k range for the whole system.  If you can beat that range and price with similar practicality, please  have at it
ChatGPT said:

Thought for 4m 45s
Yesyou can get a 1550-nm many wavelengths from one input fiber source, but microcomb specifically is still mostly a chip-based engine that usually needs a pump laser + packaging/control to be usable in fiber, and the turnkey telecom rack unit ecosystem is still not as commoditized as plain WDM parts. In fact, EU microcomb commercialization work has explicitly noted the lack of a market-ready turnkey rackmount microcomb source (at least at the time of that project). 
CORDIS

If your real goal is beat 8 discrete lasers + mux for $1040k, you can usually beat it hard with two practical approachesoften without any microcomb at all:

Option A (cheapest): comb-like multiwavelength via ASE + DWDM filter slicing
This is the classic lab trick: use a C-band ASE broadband source and a DWDM demux to carve it into multiple channels.

C-band ASE source (15251565 nm): ~$1,408 
Fiber Mart

8-ch DWDM 100 GHz mux/demux module: about $931$1,070 depending on variant 
Channel Comp

Total: roughly $2.3k$2.5k (plus patch cords, etc.).

Caveat (important): this is not 8 narrow-linewidth lasers. Its spectrally-sliced broadband light (low coherence, different noise/OSNR behavior). For lots of sensing/test/I just need 8 wavelengths use-cases its perfect; for coherent comms / tight linewidth needs, its not.

If youre okay with surplus/used gear, there are very cheap 18 DWDM demux parts out there (example listings around $230), and even mux+demux pairs around $445. 
Lightwavestore.com
+1

If you need more per-channel power, you can add an optical amplifier (still often cheaper than 8 lasers), e.g. a ~15301565 nm booster amplifier around $1,248. 
Fiber Mart

Option B (most like 8 lasers, still cheap): use 8 DWDM SFP/SFP+ transceivers as your lasers
This is the telecom hacker answer: DWDM pluggables are already stabilized ITU-grid lasers with drivers/modulation built in.

Typical street pricing examples:

10G DWDM SFP+ transceiver: ~$250 each (varies by reach/vendor) 
fs.com

8-ch DWDM passive mux/demux: $931$1,070 
Channel Comp

8 SFP+ switch to host them (CRS309 class): suggested $269 
Newegg.com

Back-of-napkin total:
8$250 = $2,000 (optics) + ~$931 (mux) + $269 (switch)  $3.2k.

Thats way under your $1040k target and its very practical: you truly have 8 lasers on the ITU grid, already engineered to behave in fiber systems.

What microcombs would change (and why theyre usually not the cost winner yet)
A microcomb can generate many evenly spaced lines in/near the C-band from a single pump; research demonstrations show using on the order of tens of WDM lines in C-band (e.g., 20 lines) 
PMC
. But to be a drop-in WDM laser bank, you still need:

a good pump laser + control,

packaging/coupling,

often flattening/equalization,

and still a DWDM demux/AWG to break out channels.

So today, microcomb is usually chosen for capability/architecture reasons (many lines, mutual coherence, integrated photonics roadmap), not because it reliably beats 8 pluggables + passive mux on price or convenience.

My recommendation for your stated goal
If the target is 8 wavelengths, practical, fiber-native, cheapest total system:

If coherence/linewidth doesnt matter: go ASE + DWDM demux (Option A).

If you want it to feel like 8 real lasers with minimal fuss: go 8 DWDM SFP+ + passive mux (Option B).

If you tell me whether you need (a) coherent/narrow-linewidth, (b) independent per-channel modulation, and (c) what channel spacing you want (100 GHz vs 200 GHz vs CWDM), I can narrow it to the best exact architecture.

You said:
how bout price per wavelength.  what could you get us if we want to be closer to that 100 wavelengths per cable
ChatGPT said:

Thought for 3m 24s
Yes  you can buy one box in, many DWDM lines out at 1550 nm, but most of whats practical/affordable today is not a true microcomb. In telecom test gear, comb source often means a high-power broadband erbium/ASE source thats spectrally sliced onto the ITU grid (many discrete wavelengths), which is perfectly fine if you just need lots of wavelength channels (not phase-coherent comb physics).

What ~100 wavelengths per fiber usually means
A very common target is ~96 channels on the 50 GHz ITU grid across C-band (thats basically about 100 lambdas). ITU defines the DWDM frequency grid and 50 GHz spacing. 
ITU

Vendors also describe typical 80-channel (50 GHz) deployments in that neighborhood. 
fs.com

Price per wavelength: the realistic options
1) Cheapest $/: Broadband (ASE) + 96-ch AWG mux/demux
96-channel 50 GHz AWG DWDM mux/demux units are sold around US$8.78.8k. 
fiberinthebox.com
+1

Budget C-band ASE sources show up around ~US$0.91.1k (vendor-dependent). 
civillaser.com

Back-of-napkin: (8,700 + 1,000) / 96  ~US$100 per wavelength.

Big catch: per-channel power can be low after splitting + AWG insertion loss (some specs quote 7 dB insertion loss on 96-ch AWG devices). 
DFT TELECOM

So this wins on cost and 100 wavelengths exists, but you may need an EDFA if you want decent power per channel.

2) Turnkey (still one source  ~100 ITU lines): DWDM comb source instrument
Example: MPBC markets DWDM Comb Sources that are spectrally sliced to the ITU grid with up to 100 channels at 50 GHz spacing and 22 dBm total output. 
mpbcommunications.com

That 22 dBm total, if spread over 100 lines, is on the order of ~2 dBm/line before external demux losses (rule-of-thumb averaging).

Pricing: usually quote-only (often tens of thousands in practice), but the whole point is replace a bank of DFB lasers. A distributor summary explicitly frames it that way. 
Sintec Optronics Pte Ltd

If this comes in at, say, $30k$80k (typical quote territory), youre at ~$300$800 per wavelength for ~100 lines  but far more turnkey than DIY ASE+slicer.

3) Real lasers per channel: Laser banks / source banks
Optilab lists DWDM source banks at:

40-channel: $86,955

80-channel: $170,972 
optilab.com

Thats roughly $2.1k per wavelength at 80 channels  great stability/line quality, terrible $/ if your goal is 100 lambdas cheaply.

4) If your actual goal is DWDM data links: DWDM pluggables per channel
For example, 10G DWDM SFP+ modules can be a few hundred USD each (one listing shows ~US$277). 
Fiber Mart

Thats ~$277 per wavelength per end (and you still need mux/demux), but this is the networking way rather than one shared light source.

Where microcombs fit (and why they usually wont beat your $1040k / 8-laser assumption yet)
True microcomb sources (Kerr soliton combs in microresonators) are still mostly OEM / research / custom-integration in 1550 systems  not commonly sold as a cheap off-the-shelf 100 DWDM lines for $10k box. They can be amazing when you need coherent carriers (esp. coherent DWDM), but pricing/practicality usually isnt the budget winner today.

If you want ~100 wavelengths per cable and want to beat your 1040k / 8-laser plan
The strongest price per wavelength play is:

ASE (or high-power erbium broadband) + 96-ch 50 GHz AWG mux/demux  ~$100/ class on the BOM, then add amplification only if your power budget demands it. 
DFT TELECOM
+3
civillaser.com
+3
fiberinthebox.com
+3

If you tell me whether each wavelength needs to be (a) a clean narrow-line carrier for modulation, or (b) just a distinct color channel for routing/ID/sensing, I can pin the recommendation hard (because thats the line between ASE slicing is perfect vs you really do need laser-like lines).

Do you like this personality?






No file chosenNo file chosen
ChatGPT can make mistakes. Check important info. See Cookie Preferences.



-----------------------

.\docs\TODO\titans.txt
You said:
2501.00663v1.pdf
PDF
Any reason we couldn't run titan architectures in our optical co-processor?  Whats this buy us beyond transformers?  
ChatGPT said:
Thought for 41s

Short answer: yesyou can run Titans on your optical co-processor, and its a good fit.

Can Titans map to our optical co-processor?

What Titans needs (ops):

Big batched matmuls: projections, sliding-window attention (SWA), memory reads/writes. 

2501.00663v1

Light nonlinearities + norms + simple gates (SiLU, layernorm-ish, linear gates) and narrow 1-D depthwise convs. 

2501.00663v1

A learned long-term memory that updates at test time using a surprise signal with momentum + weight decay; crucially, their update can be parallelized into matmul-heavy steps. 

2501.00663v1

How to place it on our stack:

Let the optics do what theyre best at: all the chunky matmuls (Q/K/V, SWA bands, memory retrieval, memory update products). Keep gates/norms/nonlinearities on fast electronics right at the E/O edges.

Store the LMM state in digital (initially) and update it each step using the optical matmuls; if/when we get non-volatile optical weights, we can move persistence analog-side.

Your ternary trick is fine for the optical paths (robust SNR, easy routing). Keep memory parameters and update accumulators at higher precision and only ternarize what flows through optics.

Why Titans vs. just Transformers for this hardware?

True long-term memory with online learning. The memory learns to memorize at test time using surprise; with momentum + weight-decay forgetting, it decides what to keep. That directly reduces KV-cache bloat and memory bandwidthperfect for analog co-processing. 

2501.00663v1

Sliding-window attention keeps attention cost linear in context length (per token) while the LMM holds far historyagain friendlier to optics than full quadratic attention. 

2501.00663v1

Stronger theoretical expressivity: Titans can solve problems beyond the TC class that bounds Transformers and many linear recurrent models in state-tracking tasks. 

2501.00663v1

Very long context: demonstrated scaling to >2M tokens with better long-context accuracy than baselines (e.g., NIAH). 

2501.00663v1

Design headroom: Three variantsMAC (Memory-As-Context), MAG (Memory-As-Gate), MAL (Memory-As-Layer)trade throughput vs. expressivity. MAC/MAG lead on long-context; MAL is simpler and fast. Pick per hardware budget. 

2501.00663v1

Any blockers?

No fundamental ones. The non-obvious requirement is fast per-token memory updates (the LMM is trained online). But their update is explicitly reformulated to matmuls + reductionsexactly what your optics accelerate. Do gates/norms/SiLU digitally at the boundary and youre fine. 

2501.00663v1

Practical mapping choices

Start with MAL (memory layer  SWA): simplest control flow; optics handle both the memory matmuls and SWA bands. Later, upgrade to MAC for stronger long-context performance once your memory write path is tight. 

2501.00663v1

Mixed precision: ternary (1,0) in optical VMMs; 812-bit (or float) for LMM parameters/updates to avoid catastrophic forgetting.

Convs: the tiny depthwise-separable 1-D convs can stay digital without being a bottleneck. 

2501.00663v1

Ablations to respect: weight-decay (forgetting) and momentum are the biggest wins; dont drop them to simplify hardware. 

2501.00663v1

What to tell the simulator to add/change

Online LMM updates: Implement their test-time update rule (surprise-triggered, with momentum + weight-decay). Count updates in matmul calls (not backprop graphs) to reflect the parallelized algorithm. 

2501.00663v1

Variant switch: Provide MAC/MAG/MAL toggles and report the long-context vs. throughput trade-off; expect MAC to win on long-range tasks. 

2501.00663v1

Bandwidth model: Separate (a) optical matmul bandwidth and (b) digital gate/conv/normalization bandwidth; penalize round-trip E/O conversions.

Precision/noise: Ternary optical VMM + higher-precision memory; inject analog noise and drift; make forgetting (weight-decay) fight drift. Use their ablation ranking to test robustness. 

2501.00663v1

Context regime: Simulate 1M2M+ tokens with SWA windows; track KV-cache size vs. LMM footprint and latency. 

2501.00663v1

Throughput knobs: Include a MAL preset that is fast path (SWA via a FlashAttention-like kernel proxy) and MAC/MAG presets that trade speed for accuracy, mirroring their findings. 

2501.00663v1

Bottom line

Feasibility: High. Titans is matmul-centric and designed so its online memory learning reduces to matmulsgreat for optics. 

2501.00663v1

Why do it: You get scalable long-term memory with controlled forgetting, linear-ish attention cost, lower KV pressure, better state tracking than plain Transformers, and a hardware pattern (optical VMM + small digital glue) that matches your co-processor. 

2501.00663v1

Where to start: MAL on optics now, then graduate to MAC when your per-token memory write path is humming. 

2501.00663v1

If you want, I can sketch a tiny MAL block diagram (ops, precisions, and dataflow arrows) tailored to your current BOM.


-----------------------

.\docs\TODO\quantum_codes.txt
ChatGPT said:
Thought for 29s

Short answer: yesthis is relevant, not because well copy the quantum code, but because its scaling tricks and error-handling patterns port cleanly to our optical/analog loop.

What the paper actually does (in 2 lines)

Proposes a non-local unitary encoder that grows a surface code from distance d to 2d1 in four time steps, achieving total depth 4 log d + O(1)about  the depth of previous non-local encoders. 

2506.04084v1

Shows that despite long-range gates, single errors still map to matchable pairs (so simple matching decoders work), and benchmarked regimes where the new encoder beats both local encoders and measurement-based prep in error rate and time. 

2506.04084v1

Why it matters to us

Think of their encoder as a two-stage doubling schedule with sparse, highly parallel updates:

Rotated  Regular code (Stage 1),

Regular  larger Rotated code (Stage 2).
This convert-then-double rhythm gives logarithmic growth with predictable error propagation. For our optics, that suggests a repeatable 2-phase pass schedule through the loop (two distinct coupling patterns) that doubles effective resolution/width per macro-iteration while keeping diagnostics simple. 

2506.04084v1

Key portable ideas:

Log-depth expansion beats linear-depth growth. Translate to optics as: prefer two interleaved coupling topologies that you reuse hierarchically to expand mode/feature count rather than adding many bespoke stages. 

2506.04084v1

Error locality despite non-local ops. They ensure a single fault triggers only two syndromes. In our loop, design parity/contrast checks so any local photonic drift trips exactly two monitorskeeps the health graph matchable and easy to debug. 

2506.04084v1

Initial state quality caps later robustness. Unitary growth does not increase fault-distance; if the seed is noisy, scaling wont fix it. For us: perform a short digitize-and-re-threshold seed calibration before big expansions; otherwise drift scales with size. 

2506.04084v1

Crossover of idle vs. gate errors. They find regimes where fewer, denser steps win over many sparse steps. For optics: tune whether you prefer long exposures with minimal reconfiguration vs shorter bursts with more SLM/phase updates based on your detector noise : actuator noise ratio. 

2506.04084v1

Concrete things we can steal

Two-pattern growth schedule (AB conversion):
Implement two fixed coupling/weight patterns in the loop (A then B) that, when alternated, double the active degrees of freedom seen by the camera per macro-iterationno new hardware topology each time. Map their RotRegRot idea to (interferometric mesh A)  (mesh B). 

2506.04084v1

Matchable health graph:
Design health checks so a single component drift flips two aggregated checks (e.g., two spatial parities), enabling a minimum-weight matching alarm instead of full state estimation. This keeps monitoring O(N log N). 

2506.04084v1

Front-loaded seed cleaning:
Add a short measure-and-reset step before each size doubling (our analog of their small post-selected block) to cap accumulated bias. 

2506.04084v1

Depth budgeting:
Favor fewer high-fan-out optical updates over many small tweaks if your measurement time  update time, mirroring their advantage when measurements are slow. 

2506.04084v1

Simulator updates to make now

Add a 2-phase tiling expander: implement (A,B) update kernels; each macro-iteration doubles effective width/feature channels; track SNR/contrast after each macro-doubling. 

2506.04084v1

Inject single-fault tests and require two-syndrome detection: randomly perturb one element (phase, gain, pixel PRNU) and verify exactly two virtual checks flip; adopt a simple matching decoder over those checks. 

2506.04084v1

Seed quality gate: simulate a short digitize/re-threshold step before expansion; verify that without it, error scales with size (mirroring fixed fault-distance). 

2506.04084v1

Idle-vs-update noise sweep: sweep the ratio (detector/read noise) : (actuator/update noise) to find the crossover where fewer denser steps beat many sparse steps, like their p/p crossover. 

2506.04084v1

Time model: penalize measurement far more than update when that matches your hardwarethen choose expansion depth accordingly (log-depth wins when readout dominates). 

2506.04084v1

Quick caveats

The paper is quantum / surface-code specific; were borrowing the scheduling and error-graph insights, not the qubit logic itself. 

2506.04084v1

Their ternary trick: not used herethis work doesnt rely on ternary weights; our ternary approach is an orthogonal cost/stability lever. 

2506.04084v1

If you want, I can sketch the two optical update patterns (A,B) and the minimal two-syndrome monitor set so your sim can start testing the log-depth growth right away. 

2506.04084v1


-----------------------

.\docs\TODO\scaling_capex_opex_predictions2.txt
Could you recap the scalability of our fiberoptic build in terms of CAPEX, OPEX, speed, throughput, and energy cost estimates at various scales and compare them to equivalents in gpu / datacenter costs/sizes?  Go up to Trillion-param model scales, with cost estimates for fiber and gpu datacenters.  (pragmatic version for fiberoptics - it can be a co-processor with gpu assistance)


Got itheres a pragmatic, numbers-driven recap that treats your 1550 nm fiber build as a matvec/feature-extraction co-processor (ternary, reservoir-style) and sizes it from a 1- MVP up to room-scale tiles you could point at trillion-param workloads. Im explicit about assumptions and I cite public anchors for GPU power/cost and recent optical baselines.

Executive take

Where optics helps most: moving a huge chunk of inner-layer multiply/accumulate into light. Microsofts AOC programme reports ~100 energy potential on relevant fixed-point/iterative workloads when you co-design algorithm+optics; theyve shown real apps (finance, MRI) on hardware + a digital twin, and say the same platform can serve AI models. 
Computer Weekly
+1

Your approach (1550 nm, SOA/EDFA, WDM, ternary): cheaper parts than free-space benches; easy tiling via DWDM; acceptable per-channel watts (SOA-only few W, with EDFA tens of W); and you can scale channels linearly. Typical SOA butterfly draws a couple watts plus TEC headroom; compact EDFAs are ~1020 W each for +2023 dBm output; passive mux/demux are loss-only. 
AusOptic

Datacenter comparators: modern GPUs sit at ~400700 W/GPU (A100/H100), with typical PUE 1.21.5 in the wild; H100 street prices have ranged $25k$40k. Blackwell B200 MLPerf inference results show ~1,038 tok/s on an LLM benchmark for a single user (context-dependent), setting a realistic top-end digital reference. 
Uptime Institute
+1

Assumptions (so the estimates make sense)

Per-channel electronics & optics:
 Modulator+driver ~10 GHz class; PD+TIA ~10 GHz class.
 SOA path (low-power): drive ~12 W + TEC overhead (25 W worst-case).
 EDFA path (high-gain): 1020 W per stage (small 1U/bench Edfas). 
AusOptic

Encoding: 3-level (ternary) symbols; effective payload  log2(3)=1.585 bits/symbol per channel.

Symbol rate: use 10 Gbaud (conservative for COTS 10 G optics).

Per-channel effective MAC rate: order-of-magnitude comparable to symbol rate when the loop implements an inner-layer matvec (feature extraction) with modest fan-in; we present ranges, not single points.

PUE: 1.2 (efficient) to 1.5 (typical) for datacenters; bench/rack optics assume local cooling 1.11.2 effective overhead.

Prices: eBay/secondary market for optics (SOA ~$0.61.5k; small EDFA ~$0.82k; 40ch DWDM mux/demux ~$100250; drivers/photoreceivers few hundred to a couple thousand used). New lab-grade gear can be 25. H100 pricing ranges as cited above. 
Uptime Institute

Scalability snapshots (co-processor doing inner layers)
1) MVP (1-, one-way, no loop)

CAPEX (used/surplus mix): $2k$5k (laser/DFB, mod+driver, PD+TIA, small SOA or none, passive parts, DWDM odds).

Power (OPEX): 520 W (SOA-only) or 2040 W with a small EDFA.

Throughput (order-of-mag): 10 Gsym/s  ~10 GMAC/s-equiv lane; useful for feature expansion / pre-conditioning.

Time-to-first-token: negligible pipeline latency (< s fiber paths + analog read), but you still DMA to/from GPU/CPU.

Where it helps: cheap de-risking; measurable speedups on attention-KV projection or conv-like prefilters.

2) Tile (8- WDM, single loop)

CAPEX: $15k$40k (8 SOA; 12 small EDFAs if needed; 40-ch DWDM pair; 8 PD+TIA; 1 mod stack; control).

Power: 60200 W (SOA-only end vs EDFA-assisted end).

Throughput: ~0.10.4 TMAC/s-equiv (810 Gsym/s with ternary + loop reuse).

Latency: sub-s per pass; multi-pass loop depth adds 10s100s of ns.

Role: offload most matvec in inner MLP/attn blocks for mid-size models (770B) alongside a couple GPUs.

3) Stack (32- WDM or 8   4 modes/pols)

CAPEX: $60k$150k (more channels, better drivers, instrumentation).

Power: 250800 W (still a fraction of an 8GPU server).

Throughput: ~0.52 TMAC/s-equiv.

Role: now competitive with a single H100 box on pure inner-layer mathwhile burning 25 less wall power for that portion. (Full pipeline still limited by digital I/O and non-offloaded ops.)

4) Rack (16 tiles; 256  aggregate)

CAPEX: $300k$800k (depends heavily on how many parts you source used vs new).

Power: 412 kW optics side; effective PUE ~1.151.25  4.615 kW at the wall.

Throughput: ~832 TMAC/s-equiv for inner layers.

Comparator: a modern 8H100 server is ~57 kW and $300k+; multi-server LLM nodes aggregate quickly to >30 kW per rack. On inner-layer math specifically, your optical rack aims for multi- energy advantage at similar or lower CAPEX; system-level benefit depends on offload coverage and PCIe/NVLink plumbing. 
Uptime Institute

5) Room-scale cluster (8 racks)  T-param capable

Aim: cooperate with 1050 GPUs for embedding/LM-head/optimizer while optics handles the majority of inner-layer FLOPs.

CAPEX: $2.5$6 M optics + $0.5$2 M GPUs/network.

Power: 40120 kW optics + 0.31 MW GPUs depending on target throughput.

What T-param capable means here: enough inner-layer capacity to keep trillion-param models saturated at practical batch/seq when spread across GPU front/back ends (sharded KV/heads, optimizer states). Digital still gates context-length, routing, and training logistics; optics trims the OPEX of the math itself by ~10100 on the part it owns, consistent with the AOC line of evidence when algorithms match hardware. 
Computer Weekly

Energy & cost head-to-head (rules of thumb)
Thing	Optics (your tile)	GPU (single)
Capex	$15k$40k (8-)	$25k$40k per H100 (card only)
Power	60200 W (tile)	700 W H100 SXM; 400 W A100
PUE adders	~1.11.2 bench/rack	1.21.5 DC average
Work fit	inner-layer matvec / fixed-point, reservoir	general LLM end-to-end
Energy per inner-layer MAC	target 10100 lower than digital when tuned	baseline (normalized 1)

Sources for GPU power/prices/PUE and the optical 100 energy ambition: Nvidia product specs; market reporting; Uptime Institute/NREL; Microsoft AOC publications. 
Uptime Institute
+1

How this maps to tokens/sec in practice

Digital ceiling: MLPerf inference with Blackwell B200 reported ~1,038 tok/s for a specific LLM setting (highly context/model dependent). Thats the what good looks like bar for a single top-end GPU today. 
Microsoft

Optical co-processor effect: think of 520 faster inner-layer turn (or 10100 less energy) for that fraction of the pipeline that you offload. Net end-to-end gains of 1.55 are realistic at 832  when memory moves / attention wiring are still digital; ambitious co-design (more offload, fused analog steps, ternary-aware training) pushes higher. Microsofts AOC results back the magnitude on the right workloads; your ternary guardrails trade a bit of accuracy for simpler/cheaper parts. 
Computer Weekly

Where the economics flip

Sub-rack (32 ): best J/MAC and $/MAC for specialized layers; you still need a GPU around to orchestrate.

Rack (256 ): inner-layer math OPEX starts to dominate the savings; CAPEX competitive with 12 GPU servers, but better energy on the math you offload.

Room-scale (2 k  aggregate): compelling LLM-per-watt if you keep PCIe/NVLink/NICs busy and minimize digital round-trips.

Practical constraints to bake into plans

Component power: small EDFA modules are ~1020 W each (budget per channel if you need high OSNR); SOAs with TEC can be ~37 W worst-case. 
AusOptic

I/O pressure: PCIe/NVLink and DMA become your bottleneck; design the dataflow so that multiple loop passes amortize one host transfer.

Calibration drift & noise: set aside 15% duty for quick in-band calibration/AGC; expect OSNR and mode crosstalk budget.

Non-ideal ternary: quantization + SOA nonlinearity interacts with reservoir memoryco-train with your quantizer to keep accuracy.

Reality-check vs replace the datacenter

Microsofts group is careful: not general-purpose, but a widening swath of app classes benefit when the algorithm matches the physics. Their claim is ~100 energy at scale, not 100 tokens/sec across everything. Thats the right way to frame your plan, too: own the energy and time on the math you offload, and let GPUs do what theyre great at. 
Computer Weekly

Quick sourcing anchors you can use while hunting parts

EDFA (bench/1U, +2023 dBm): ~1020 W power draw (FS example shown); used market $0.82k.

SOA (1550 nm, 14-pin butterfly): 10s100s mA device current; TEC up to ~1.5 A  a few watts total; prices $0.61.5k used/new-old-stock. 
AusOptic

GPU baselines (power, price): A100/H100 TDP and H100 street prices as above. 
Uptime Institute

Datacenter PUE norms: 1.2 best-in-class to ~1.5 average.

AOC references: MS Research news & scale claims; early AIM blog for the fixed-point class they target. 
Computer Weekly
+1

What Id put in the slide you show investors

Near-term ($40k, 200 W): 8- tile, 13 end-to-end speedup on targeted layers, 520 energy improvement on those layers, accuracy within quantized baselines.

12-month ($500k, 10 kW): rack with 832 TMAC/s-equiv inner-layer capacity; OPEX clearly below a comparable GPU rack for the same math.

24-month (multi-rack): co-designed training/inference with analog inner loops + digital front/back ends; room-scale for trillion-param workloads with optical kWh/token well under an all-GPU path (PUE-adjusted).

If you want, I can turn this into a little spreadsheet where you can tweak symbol rate, channels, EDFA counts, PUE, and power prices to get a live CAPEX/OPEX curve and a tokens/sec estimate for your favorite model.






-----------------





































You said:
Could you recap the scalability of our fiberoptic build in terms of CAPEX, OPEX, speed, throughput, and energy cost estimates at various scales and compare them to equivalents in gpu / datacenter costs/sizes?  Go up to Trillion-param model scales, with cost estimates for fiber and gpu datacenters.  (pragmatic version for fiberoptics - it can be a co-processor with gpu assistance)
ChatGPT said:

Thought for 4m 44s
Got itheres a pragmatic, numbers-driven recap that treats your 1550 nm fiber build as a matvec/feature-extraction co-processor (ternary, reservoir-style) and sizes it from a 1- MVP up to room-scale tiles you could point at trillion-param workloads. Im explicit about assumptions and I cite public anchors for GPU power/cost and recent optical baselines.

Executive take
Where optics helps most: moving a huge chunk of inner-layer multiply/accumulate into light. Microsofts AOC programme reports ~100 energy potential on relevant fixed-point/iterative workloads when you co-design algorithm+optics; theyve shown real apps (finance, MRI) on hardware + a digital twin, and say the same platform can serve AI models. 
Computer Weekly
+1

Your approach (1550 nm, SOA/EDFA, WDM, ternary): cheaper parts than free-space benches; easy tiling via DWDM; acceptable per-channel watts (SOA-only few W, with EDFA tens of W); and you can scale channels linearly. Typical SOA butterfly draws a couple watts plus TEC headroom; compact EDFAs are ~1020 W each for +2023 dBm output; passive mux/demux are loss-only. 
AusOptic

Datacenter comparators: modern GPUs sit at ~400700 W/GPU (A100/H100), with typical PUE 1.21.5 in the wild; H100 street prices have ranged $25k$40k. Blackwell B200 MLPerf inference results show ~1,038 tok/s on an LLM benchmark for a single user (context-dependent), setting a realistic top-end digital reference. 
Uptime Institute
+1

Assumptions (so the estimates make sense)
Per-channel electronics & optics:
 Modulator+driver ~10 GHz class; PD+TIA ~10 GHz class.
 SOA path (low-power): drive ~12 W + TEC overhead (25 W worst-case).
 EDFA path (high-gain): 1020 W per stage (small 1U/bench Edfas). 
AusOptic

Encoding: 3-level (ternary) symbols; effective payload  log2(3)=1.585 bits/symbol per channel.

Symbol rate: use 10 Gbaud (conservative for COTS 10 G optics).

Per-channel effective MAC rate: order-of-magnitude comparable to symbol rate when the loop implements an inner-layer matvec (feature extraction) with modest fan-in; we present ranges, not single points.

PUE: 1.2 (efficient) to 1.5 (typical) for datacenters; bench/rack optics assume local cooling 1.11.2 effective overhead.

Prices: eBay/secondary market for optics (SOA ~$0.61.5k; small EDFA ~$0.82k; 40ch DWDM mux/demux ~$100250; drivers/photoreceivers few hundred to a couple thousand used). New lab-grade gear can be 25. H100 pricing ranges as cited above. 
Uptime Institute

Scalability snapshots (co-processor doing inner layers)
1) MVP (1-, one-way, no loop)
CAPEX (used/surplus mix): $2k$5k (laser/DFB, mod+driver, PD+TIA, small SOA or none, passive parts, DWDM odds).

Power (OPEX): 520 W (SOA-only) or 2040 W with a small EDFA.

Throughput (order-of-mag): 10 Gsym/s  ~10 GMAC/s-equiv lane; useful for feature expansion / pre-conditioning.

Time-to-first-token: negligible pipeline latency (< s fiber paths + analog read), but you still DMA to/from GPU/CPU.

Where it helps: cheap de-risking; measurable speedups on attention-KV projection or conv-like prefilters.

2) Tile (8- WDM, single loop)
CAPEX: $15k$40k (8 SOA; 12 small EDFAs if needed; 40-ch DWDM pair; 8 PD+TIA; 1 mod stack; control).

Power: 60200 W (SOA-only end vs EDFA-assisted end).

Throughput: ~0.10.4 TMAC/s-equiv (810 Gsym/s with ternary + loop reuse).

Latency: sub-s per pass; multi-pass loop depth adds 10s100s of ns.

Role: offload most matvec in inner MLP/attn blocks for mid-size models (770B) alongside a couple GPUs.

3) Stack (32- WDM or 8   4 modes/pols)
CAPEX: $60k$150k (more channels, better drivers, instrumentation).

Power: 250800 W (still a fraction of an 8GPU server).

Throughput: ~0.52 TMAC/s-equiv.

Role: now competitive with a single H100 box on pure inner-layer mathwhile burning 25 less wall power for that portion. (Full pipeline still limited by digital I/O and non-offloaded ops.)

4) Rack (16 tiles; 256  aggregate)
CAPEX: $300k$800k (depends heavily on how many parts you source used vs new).

Power: 412 kW optics side; effective PUE ~1.151.25  4.615 kW at the wall.

Throughput: ~832 TMAC/s-equiv for inner layers.

Comparator: a modern 8H100 server is ~57 kW and $300k+; multi-server LLM nodes aggregate quickly to >30 kW per rack. On inner-layer math specifically, your optical rack aims for multi- energy advantage at similar or lower CAPEX; system-level benefit depends on offload coverage and PCIe/NVLink plumbing. 
Uptime Institute

5) Room-scale cluster (8 racks)  T-param capable
Aim: cooperate with 1050 GPUs for embedding/LM-head/optimizer while optics handles the majority of inner-layer FLOPs.

CAPEX: $2.5$6 M optics + $0.5$2 M GPUs/network.

Power: 40120 kW optics + 0.31 MW GPUs depending on target throughput.

What T-param capable means here: enough inner-layer capacity to keep trillion-param models saturated at practical batch/seq when spread across GPU front/back ends (sharded KV/heads, optimizer states). Digital still gates context-length, routing, and training logistics; optics trims the OPEX of the math itself by ~10100 on the part it owns, consistent with the AOC line of evidence when algorithms match hardware. 
Computer Weekly

Energy & cost head-to-head (rules of thumb)
Thing	Optics (your tile)	GPU (single)
Capex	$15k$40k (8-)	$25k$40k per H100 (card only)
Power	60200 W (tile)	700 W H100 SXM; 400 W A100
PUE adders	~1.11.2 bench/rack	1.21.5 DC average
Work fit	inner-layer matvec / fixed-point, reservoir	general LLM end-to-end
Energy per inner-layer MAC	target 10100 lower than digital when tuned	baseline (normalized 1)
Sources for GPU power/prices/PUE and the optical 100 energy ambition: Nvidia product specs; market reporting; Uptime Institute/NREL; Microsoft AOC publications. 
Uptime Institute
+1

How this maps to tokens/sec in practice
Digital ceiling: MLPerf inference with Blackwell B200 reported ~1,038 tok/s for a specific LLM setting (highly context/model dependent). Thats the what good looks like bar for a single top-end GPU today. 
Microsoft

Optical co-processor effect: think of 520 faster inner-layer turn (or 10100 less energy) for that fraction of the pipeline that you offload. Net end-to-end gains of 1.55 are realistic at 832  when memory moves / attention wiring are still digital; ambitious co-design (more offload, fused analog steps, ternary-aware training) pushes higher. Microsofts AOC results back the magnitude on the right workloads; your ternary guardrails trade a bit of accuracy for simpler/cheaper parts. 
Computer Weekly

Where the economics flip
Sub-rack (32 ): best J/MAC and $/MAC for specialized layers; you still need a GPU around to orchestrate.

Rack (256 ): inner-layer math OPEX starts to dominate the savings; CAPEX competitive with 12 GPU servers, but better energy on the math you offload.

Room-scale (2 k  aggregate): compelling LLM-per-watt if you keep PCIe/NVLink/NICs busy and minimize digital round-trips.

Practical constraints to bake into plans
Component power: small EDFA modules are ~1020 W each (budget per channel if you need high OSNR); SOAs with TEC can be ~37 W worst-case. 
AusOptic

I/O pressure: PCIe/NVLink and DMA become your bottleneck; design the dataflow so that multiple loop passes amortize one host transfer.

Calibration drift & noise: set aside 15% duty for quick in-band calibration/AGC; expect OSNR and mode crosstalk budget.

Non-ideal ternary: quantization + SOA nonlinearity interacts with reservoir memoryco-train with your quantizer to keep accuracy.

Reality-check vs replace the datacenter
Microsofts group is careful: not general-purpose, but a widening swath of app classes benefit when the algorithm matches the physics. Their claim is ~100 energy at scale, not 100 tokens/sec across everything. Thats the right way to frame your plan, too: own the energy and time on the math you offload, and let GPUs do what theyre great at. 
Computer Weekly

Quick sourcing anchors you can use while hunting parts
EDFA (bench/1U, +2023 dBm): ~1020 W power draw (FS example shown); used market $0.82k.

SOA (1550 nm, 14-pin butterfly): 10s100s mA device current; TEC up to ~1.5 A  a few watts total; prices $0.61.5k used/new-old-stock. 
AusOptic

GPU baselines (power, price): A100/H100 TDP and H100 street prices as above. 
Uptime Institute

Datacenter PUE norms: 1.2 best-in-class to ~1.5 average.

AOC references: MS Research news & scale claims; early AIM blog for the fixed-point class they target. 
Computer Weekly
+1

What Id put in the slide you show investors
Near-term ($40k, 200 W): 8- tile, 13 end-to-end speedup on targeted layers, 520 energy improvement on those layers, accuracy within quantized baselines.

12-month ($500k, 10 kW): rack with 832 TMAC/s-equiv inner-layer capacity; OPEX clearly below a comparable GPU rack for the same math.

24-month (multi-rack): co-designed training/inference with analog inner loops + digital front/back ends; room-scale for trillion-param workloads with optical kWh/token well under an all-GPU path (PUE-adjusted).

If you want, I can turn this into a little spreadsheet where you can tweak symbol rate, channels, EDFA counts, PUE, and power prices to get a live CAPEX/OPEX curve and a tokens/sec estimate for your favorite model.

You've reached the maximum length for this conversation, but you can keep talking by starting a new chat.


Retry



No file chosenNo file chosen
ChatGPT can make mistakes. Check important info. See Cookie Preferences.











-----------------------

.\docs\TODO\bom_and_shadow_tomo.txt
awesomeheres a clean, end-to-end recap of the fiber-optic build using full component names. Ive split it into (A) the single-channel, one-way MVP youll build first, and (B) the 8-wavelength recirculating loop youll scale into. After each BoM, youll find a numbered signal path that shows how light moves through every block.


---

A) Single-channel MVP (1550 nm, one-way path, no loop)

Bill of Materials (with full names)

Light source & stabilization

1. 1550 nm Distributed Feedback (DFB) Laser Diode, 14-pin butterfly package with Thermo-Electric Cooler (TEC) and thermistor


2. Laser Diode Current Controller (e.g., ILX Lightwave LDX-3412 / LDC-3722B channel, constant-current, low-noise)


3. TEC Temperature Controller (matched to butterfly; stable to 0.01 C)


4. 14-pin Butterfly Laser Diode Mount / Socket with TEC and Thermistor Breakout (with LC/FC feedthroughs as needed)



Launch conditioning 5) Fiber-Optic Isolator, 1550 nm, Single-Mode, FC/APC (protects the laser from back-reflections)
6) In-line Fiber-Optic Variable Optical Attenuator (VOA), 1550 nm, FC/APC (sets power into the reservoir)
7) Polarization Controller (paddle or in-line fiber squeezer), 1550 nm (tunes state of polarization for SOA/reservoir)

Reservoir mixing + nonlinearity 8) 50:50 Single-Mode Fiber Couplers (12 / 22), 1550 nm, FC/APC (build a small mixing network)
9) Short Segment of Few-Mode or Graded-Index Multimode Fiber, 1550 nm-compatible (optional but recommended for richer mode-mixing)
10) Semiconductor Optical Amplifier (SOA), 1550 nm C-Band, butterfly package (nonlinear element; e.g., InPhenix IPSAD15xx family)
11) Post-SOA Fiber-Optic Isolator, 1550 nm, FC/APC (prevents SOA self-oscillation and reflection-induced instabilities)

Readout & tap 12) 99:1 or 95:5 Fiber-Optic Tap Coupler, 1550 nm, FC/APC (small tap to detector; majority continues or is dumped)
13) InGaAs Photodiode Receiver Module (DCGHz), 1550 nm, with Transimpedance Amplifier (TIA) (choose bandwidth for your task)
14) Anti-Aliasing RF Filter (optional; match to ADC sampling)
15) High-Speed Analog-to-Digital Converter (ADC) / Data Acquisition Card (e.g., 14-bit, 250 MS/s for ~100 MHz analog BW)
16) Digital Control Computer (for readout regression/last-layer decoding, monitoring)

Interconnects & mechanics 17) Single-Mode Patch Cords, SMF-28e, FC/APC (use LC only where the device forces you; APC reduces parasitic reflections)
18) Fiber Adapters (FC-to-LC, FC/APC bulkheads), Panel Feedthroughs
19) 19-inch Rack Shelf or Optical Breadboard, Cable Management, Thermal Heat-sink Plates
20) Laser Safety Eyewear (OD-rated for 1550 nm), Beam Dumps / End Caps


---

MVP signal path (one-way)

1. DFB Laser Diode  Laser Diode Current Controller + TEC Temperature Controller
Stable CW output at 1550 nm with low RIN and locked wavelength via temperature.


2. Laser Output  Fiber-Optic Isolator (1550 nm)
Protects source; keeps reflections out.


3. Isolator  Variable Optical Attenuator
Sets the reservoir input power / operating point.


4. VOA  Polarization Controller
Tunes SOP to maximize SOA nonlinearity / desired mixing response.


5. Polarization Controller  Mixing Network (50:50 couplers + optional few-mode/graded-index fiber segment)
Passive linear mixing / path diversity; creates a richer reservoir state.


6. Mixer  Semiconductor Optical Amplifier (SOA)
Provides saturable gain nonlinearity (key to ternary/low-precision behavior).
Followed by Post-SOA Isolator for stability.


7. SOA Output  99:1 (or 95:5) Tap Coupler
Small fraction to detector; the rest can go to dump (MVP) or into future loop hardware.


8. Tap  InGaAs Photodiode Receiver (with TIA)  (optional RF filter)  High-Speed ADC
Produces your analog feature vector (digitized), which the Digital Control Computer uses for last-layer decoding/regression.



(Thats your minimal proof that optical reservoir + ternary readout works at C-band. From here, you either add the loop or add more wavelengths.)


---

B) Eight-Wavelength Recirculating Loop (DWDM ring reservoir)

Bill of Materials (additions beyond the MVP)

Multi- sources (choose one approach)

1. Eight 1550 nm DFB Laser Diodes (fixed ITU channels), each with 14-pin butterfly, TEC, thermistor
 or 
Eight Tunable C-Band External-Cavity or DBR Laser Diodes, butterfly
(You can also prototype with DWDM XFP/SFP+ transceivers as cheap CW sources, but direct laser diodes are cleaner for analog work.)


2. Multi-Channel Laser Diode Current Controller (8) (or multiple 12 ch units)


3. Multi-Channel TEC Temperature Controller (8)


4. Eight Butterfly Laser Diode Mounts / Sockets



Per- launch conditioning 5) Eight Fiber-Optic Isolators, 1550 nm, FC/APC
6) Eight In-line Variable Optical Attenuators (VOA)
7) Eight Polarization Controllers

Wavelength combining / selection 8) 8-Channel Dense Wavelength Division Multiplexing (DWDM) Multiplexer, 100 GHz or 200 GHz grid, C-Band, LC/UPC or FC/APC
9) 8-Channel DWDM Demultiplexer, matched grid (for per- readout/fan-out)
10) (Optional) Wavelength Selective Switch (WSS) if you want dynamic per- routing (not required for the first loop)

Reservoir core (shared) 11) Semiconductor Optical Amplifier (SOA), 1550 nm C-Band (choose saturation power/gain to support all )
12) Post-SOA Fiber-Optic Isolator, 1550 nm
13) Passive Mixing Network (tree of 50:50 couplers, optional few-mode fiber segment)
14) Recirculation Delay Line (e.g., 1002,000 m SMF-28e spool depending on symbol period / update cadence)
15) In-Loop Variable Optical Attenuator (controls loop gain to 1)
16) (Optional) Electro-Optic Phase Modulator (LiNbO) or Intensity Modulator (MachZehnder) for additional controllable dynamics
17) 12 Fiber-Optic Couplers for Injection Port (from sources) and Readout Tap (to demux)

Per- readout fan-out 18) 15% Tap Coupler in the loop path  DWDM Demultiplexer  Eight InGaAs Photodiode Receivers (with TIAs)
19) Multi-Channel ADC / Digitizer (e.g., 8 14-bit 250 MS/s)
20) Control/Acquisition Computer (synchronization, last-layer decoding, monitoring)

Supervision, monitoring & timing 21) Optical Power Monitors (in-line) / Photodiode Tap Monitors (to watch per- power balance)
22) Function / Arbitrary Waveform Generator (for small dithers, resets, or EOM drive)
23) Clock/Trigger Distribution (align ADC sampling to loop round-trip if needed)


---

Eight- loop signal path (recirculating)

Launch & combine

1. Eight DFB/Tunable Laser Diodes (with current + TEC control)  each through Isolator  VOA  Polarization Controller.


2. Eight conditioned wavelengths  DWDM Multiplexer  Combined Multi- Fiber.



Reservoir loop 3) MUX Output  Passive Mixing Network (couplers + optional few-mode fiber) (creates rich inter- and path-mix dynamics).
4) Mixer  Semiconductor Optical Amplifier (SOA) (shared nonlinearity; saturable gain across all ).
5) SOA  Post-SOA Isolator (stability).
6) Isolator  In-Loop Variable Optical Attenuator (set loop gain ~0.951.05; tune memory depth).
7) In-Loop VOA  Recirculation Delay Line (fiber spool defines round-trip time / effective layer depth).
8) Delay Line  12 Coupler:

Tap Arm (15%)  DWDM Demultiplexer  8 InGaAs Photodiode Receivers  Multi-Channel ADC  Digital Last-Layer.

Through Arm (9599%)  back to Mixing Network to complete the loop.


Injection / reset (optional) 9) Injection Coupler (before or after the mixer) accepts a gated input burst or pilot tone per .
10) Electro-Optic Modulator (optional) can inject phase/intensity perturbations for control or learning signals.


---

Notes, options, and practical guidance

Connectors: Prefer FC/APC for all analog compute paths (low back-reflection). Use LC/UPC only where a module forces it; adapt with FC/APCLC/UPC hybrid jumpers.

SOA choice: A C-band butterfly SOA (tens of mA to ~200 mA bias) gives your nonlinearity and per-round-trip gain; set operating point with VOAs. (Your InPhenix IPSAD15xx-series device fits.)

EDFA vs SOA: An Erbium-Doped Fiber Amplifier is great for bulk gain but is less sharp as the nonlinear activation and adds more ASE noise; keep the SOA as the main nonlinearity and use an EDFA only if you must recover loss in long loops.

Mixing richness: A little few-mode/graded-index fiber or a deeper coupler lattice noticeably improves feature explosion before the SOA.

Polarization: SOAs and many passive parts are polarization sensitive; use polarization controllers (or PM versions of parts) to stabilize operating points.

Scaling: Add wavelengths by replicating the per- front-end (Isolator + VOA + PC), feeding the same DWDM MUX and shared loop. Add detectors by replicating DEMUX + PD + ADC channels.

MDM/camera branch (optional): If you later try photonic-lantern + InGaAs area camera readout, add a Photonic Lantern (SMFew-Mode) and InGaAs Area Camera after a tap; this replaces the DEMUX + PD bank for a high-fan-out spatial read but costs more.



---

Minimal shopping checklist (per build phase)

MVP (single channel)

1 1550 nm DFB Laser Diode, butterfly (with TEC & thermistor)

1 Laser Diode Current Controller (low noise)

1 TEC Temperature Controller

1 Butterfly Mount / Socket

2 1550 nm Fiber-Optic Isolators (pre-/post-SOA)

1 Variable Optical Attenuator

1 Polarization Controller

24 50:50 Fiber Couplers (build a 23 stage mixer)

1 Semiconductor Optical Amplifier (SOA), C-Band

1 99:1 (or 95:5) Tap Coupler

1 InGaAs Photodiode Receiver Module (with TIA) (BW per your target)

1 High-Speed ADC (and PC)

Patch cords/adapters, safety, mechanics


8- loop (adds)

7 additional DFB/Tunable Laser Diodes (+ drivers, TECs, mounts)

1 8-Channel DWDM Multiplexer (100/200 GHz ITU grid)

1 8-Channel DWDM Demultiplexer (matched grid)

1 In-Loop VOA, 1 Recirculation Fiber Spool, extra couplers

7 extra Polarization Controllers, Isolators, VOAs (per )

7 additional InGaAs PD Receivers and ADC channels (or time-multiplex and switch, at the cost of speed)



---

Step-by-step build order (recommended)

1. Bench the laser + TEC alone; verify stable power vs. temperature.


2. Add pre-isolator  VOA  PC, confirm stable launch power and SOP.


3. Insert the mixer (couplers + optional few-mode fiber), measure insertion loss and speckle stability.


4. Insert the SOA with post-isolator; set bias to desired nonlinearity region; verify no lasing/oscillation.


5. Add tap  PD  ADC, capture MVP data and train a digital readout to confirm usable features.


6. When happy, add loop elements: in-loop VOA, fiber delay, tap DEMUX, and close the ring.


7. Scale to multi- by adding sources, then the DWDM MUX/DEMUX, then additional PD channels.




---

If you want, I can turn this into a printable BoM spreadsheet with columns for qty, spec, connector, notes, and vendor candidates, but the above is the full parts and flow you asked for with explicit names.






Short version: Ising models give you a physics-native way to cast hard ML/optimization subproblems into a spin system your optics can relax on; shadow tomography warns you theres an information bottleneck when you try to measure lots of things from few states/exposures. Both touch your hardware in deep waysand both can become rabbit holes if you dont respect their limits.

How they touch your hardware

1) Ising models (QUBO / spin-glass framing).

Many useful subproblems in your loopternary quantization (1/0/+1), sparse mask selection, routing, clustering, even certain training stepscan be written as minimizing an Ising energy 

(

)
=


<








+






E(s)=
i<j
	

J
ij
	

s
i
	

s
j
	

+
i
	

h
i
	

s
i
	

 with 



{

1
,
+
1
}
s
i
	

{1,+1} (or a ternary extension).

Your optics already looks like an analog relaxer: linear couplings via free-space kernels / MDM lanterns / fiber meshes ( the 

J matrix), saturating SOAs or modulators for the nonlinearity (spin squashing), and a feedback loop for annealing. So for some tasks, you can let the physics find low-energy configurations fast.

Caveat (rabbit hole #1): general Ising is NP-hard; embeddings, precision limits, and control overhead balloon quickly. Its powerful as a module (e.g., for ternary weight selection, routing, or combinatorial side-tasks), not a silver bullet for whole-model training.

2) Shadow tomography (information limits on readout).

Informally: given a state 

 and a huge family of measurements 
{


}
{E
i
	

}, shadow tomography tells you how many copies/exposures you need to estimate all 
T
r
(



)
Tr(E
i
	

) to  accuracy. The headline result is you can estimate exponentially many expectations with only polylogarithmically many copiesbut theres still unavoidable dependence on 
log


,
log


,

logM,logD,. In particular, the Aaronson Shadow Tomography Theorem shows you can do it with roughly 

~

(
(
log

4

)
(
log


)
/

4
)
O
~
((log
4
M)(logD)/
4
) copies; earlier versions had 


5

5
 which can be improved to 


4

4
. 

1711.01053v2

 

1711.01053v2

And there are lower bounds: any method needs at least 

(
min

{

2
,
log


}
/

2
)
(min{D
2
,logM}/
2
) copies; even the classical special case still needs 

(
min

{

,
log


}
/

2
)
(min{D,logM}/
2
). Translation: you cant magic away the sample/integration time needed to estimate tons of readouts accuratelyeven in a classical optical system. 

1711.01053v2

 

1711.01053v2

Why it matters to you: if you treat a single camera exposure as all M layer dot-products at once, shadow-style reasoning says accuracy per output will be bounded by photon/SNR budgets and grows with 

M. Youll often need multiple exposures/integration windows or adaptive measurement sequences to keep errors in lineexactly the kind of gentle multi-measurement scheduling shadow tomography formalizes (gentle measurement, gentle search, postselected learning). 

1711.01053v2

 

1711.01053v2

Why its a dark rabbit hole

Illusion of free parallelism. Cameras give you D pixels for free, but to report M precise functionals (e.g., many masks/weights) you hit 
log


logM and 

 costs in copies/integration timeeven classically. Pushing M high without budgeting photons/time forces down per-output accuracy or forces longer runs. 

1711.01053v2

Destructive / state-damaging measurements (classical analogue). Shadow tomographys gentle measurement story comes from quantum, but the moral holds in noisy analog optics: aggressive readouts (bright probes, nonlinear elements) change the medium (heating, carrier depletion, gain saturation). You need sequencing thats gentle enough not to ruin later measurements. 

1711.01053v2

Embedding overhead in Ising. Mapping rich ML objectives into spins can explode variable count/precision and demand control loops whose digital overhead erodes your physics win. Great local tool; dangerous as a universal hammer.

Practical restrictions youll feel (even though youre classical)

Sample/Exposure complexity: Expect total exposure budget to scale at least like 

(
min

{

,
log


}
/

2
)
(min{D,logM}/
2
) in the nicest classical cases; plan runs accordingly. 

1711.01053v2

Photon shot noise / dynamic range: Accuracy 


1
/

photons
1/
N
photons
	

	

 per output; multiplexing more outputs in one exposure splits photons/SNR across them.

Detector limits: Full-well capacity, read noise, PRNU; these set hard ceilings on simultaneous accurate M.

Coupler precision: Implementing dense 

J (Ising) or many masks needs stable phase/amplitude control; errors push you into spin-glass landscapes (local minima).

I/O bottlenecks: Reading all outputs digitally can dominate wall-clock; prefer on-optic accumulation, compressive readouts, or staged/gated measurements (shadow-style adaptivity).

Worst-case hardness: Ising/QUBO remains NP-hard; the optics gives heuristic speed/parallelism, not guaranteed global optima.

How to use this constructively

Map shadow-style quantities onto your loop.

Let 

D = number of resolvable optical modes / camera pixels used; 

M = number of distinct linear readouts (masks/weights) you want per state; 

 = targeted per-readout accuracy.

Budget exposures/integration: plan for ~

~
(
(
log

4

)
(
log


)
/

4
)
O
~
((log
4
M)(logD)/
4
) effective copies if you try to estimate all M with high accuracy in one session via adaptive sequences; lower if you only need a subset per pass. 

1711.01053v2

Prefer adaptive measurement schedules (choose the next mask based on where your current hypothesis is wrong) to conserve exposure budgetthe postselected learning + gentle search moral. 

1711.01053v2

 

1711.01053v2

Use Ising where it shines, not everywhere.

Good fits: ternary mask selection, structured pruning, routing/assignment, small combinatorial bottlenecks inside each iteration.

Keep embeddings small, use coarse/ternary spins (fits your ternary trick), and gate annealing schedules with your existing feedback loop.

Measure few energy terms per cycle (dont try to read every coupling); use local observables and a small set of global monitors.

Concrete upgrades for your simulator

Photon/Exposure budget model (shadow-style).

Input: 

,

,

D,M,, detector specs, laser power.

Output: minimal number of exposures/integration time to achieve target error across all requested readouts; enforce classical lower bound scaling with 
min

{

,
log


}
/

2
min{D,logM}/
2
. 

1711.01053v2

Adaptive measurement loop (gentle scheduling).

Maintain a hypothesis of the current mask responses; select the next mask to probe where error is largest; throttle probe intensity to limit state perturbation; update via online convex methods (matrix MWU). (This is the classical analogue of the postselected learning + gentle search combo.) 

1711.01053v2

 

1711.01053v2

State-damage model.

Include saturation, heating, carrier lifetime; make measurement SNR vs. subsequent SNR a function of probe energy (gentleness control). 

1711.01053v2

Ising submodule.

Provide an optional Ising/QUBO solver block with realistic analog constraints: limited precision 



J
ij
	

, noisy couplings, bounded anneal rate; report embedding overhead and success probability (local minima rate).

Output throttling strategies.

Offer three readout modes: (a) Compressive: project to KM random/features then reconstruct; (b) Batched masks: M split across B batches to keep SNR per mask high; (c) On-optic accumulation: accumulate weighted sums optically and digitize only a few scalars.

Ternary-aware accuracy.

Track decision error rates for {-1,0,+1} classification under finite SNR; show how fewer levels relax  and reduce required exposure count (but watch bias thresholds).

Bottom line:

Ising models are a good tool in the toolbox for specific combinatorial substeps; use them surgically.

Shadow-tomography-style limits are the discipline your simulator needs: they keep your expectations honest about how many accurate readouts you can squeeze from a small number of exposures. Your optics gives you massive constant-factor wins (parallel pixels, low energy per MAC), but the 
(
log


,
log


,

)
(logM,logD,) dependencies still rule the total wall-time/energy you must budgeteven in classical photonics. 

1711.01053v2

 

1711.01053v2


-----------------------

.\docs\TODO\photon_budgeting.txt
>AFAIK getting under 1E-16J/bit for 2 way conversion without doing anything fundamental (R&D project unto itself) would be overly optimistic.  That sets a floor to the J/FLOP & J/tk which will be better than H100s but my guess is not by 100x.
5:46 p.m.


response?

---


Great pushback. Heres a tight, numbers-aware reply you can send that doesnt hand-wave the conversion floor, but also shows why 100 OPEX is still plausible in the right regime:

Totally agree that E/O + O/E conversion energy matters. Two clarifications:

We dont pay conversion per-MAC in an optical VMM/loop.
You convert an N-vector once (EO), let the optics do NM MACs for free, then read M outputs once (OE). So even if the two-way conversion has a hard floor, its amortized over millions of MACs per pass. Thats the key difference from digital where every MAC drags bits across SRAM/HBM.

Shot noise, not just electronics, sets the optical floor.
At 1550 nm, one photon  1.2810 J. If you target ~10 photons per measurement for decent SNR, thats  1.310 J per output sample, i.e., the same ballpark as your 10 J/bit assertion. Again: amortized across M outputs and N inputs.

Back-of-envelope to show the scaling:

Let E_in be the energy to encode the N inputs optically (DACs/modulators, driver losses).

Let E_out be the energy to read M outputs (detector + TIA + ADC).

One optical pass does NM MACs.

Energy per MAC  (E_in + E_out)/(NM) + E_optics/MAC.

If youre in a moderately wide regime (say N=M=1024), even pessimistic per-pass numbers like E_in + E_out  tens of nJ land you at  tens of fJ/MAC. By comparison, an H100 at ~700 W delivering ~1.5 PFLOP/s FP16 is ~0.5 pJ/FLOP ( 500 fJ)and real LLM tokens burn far more due to memory traffic. So a 10100 energy win is not fantasy when:

You keep the loop analog (no per-layer digitize/rediscretize).

You batch large NM (big amortization).

You co-locate/encode weights optically (MRRs/PCM/DMD/SLM) to avoid per-token DAC overhead.

You avoid camera-class readouts for the fast path (use PD arrays / WDM taps).

Where the 100 falls apart:

Small N or M (poor amortization).

Frequent A/DD/A inside the loop (you pay the floor every layer).

Weighting driven by high-precision DACs every token instead of persistent optical states.

Poor SNR forcing high optical power or multiple reads.

Two practical counters to the conversion floor caps gains argument:

Architectural avoidance: Do E/O once per token (or per K tokens) and O/E once per layer-group (or only at the very end). That collapses conversion energy per token dramatically.

Parallelism makes the floor tiny per MAC: Even if your 2-way floor is 1010 J/bit, spreading it across 1010 MACs per pass yields sub-10 fJ/MACcomfortably 50100 below the effective energy/useful MAC in GPU inference once memory is included.

Finally, note why GPUs look worse in practice: the energy you quote as J/FLOP hides HBM traffic (pJ/bit) and on-chip data motion. Optical loops eliminate most of that; their routing cost is largely distance-agnostic and the compute happens as light propagates.

Bottom line:

If you digitize every layer: I agreeno 100.

If you keep the inner stack analog, persist weights optically, and amortize conversions over wide VMMs and many  (WDM), 10100 OPEX versus GPUs is very realistic for the right workloads. The lever isnt magic converters; its reducing how often you need them and how many MACs they amortize over.

Happy to run a quick param sweep for your simulator (pick N, M,  count, detector SNR, ADC bits, modulator drive) and plot E/MAC and J/token under different conversion floor assumptions.

---



Full context here: 
initial post:

to add an option to people's radars, getting 10-100x better energy efficiency on transformer inference and training seems quite plausible with off the shelf 1550nm fiberoptics hardware

am building sims.  may buy and build prototype if they continue to work.  am perpetually very tired though

would be a very nice disruptor to datacenters though and the tech is already too widely distributed to be bottlenecked/monopolized

ideally package as a consumer appliance and decentralize network RL train with them, scale well past legacy models for pennies on the dollar.  kickstarter/shitcoin it to crowdfund

INTELLECT-2: The First Globally Distributed Reinforcement Learning Training of a 32B Parameter Model
Today we are launching INTELLECT-2: the first 32B parameter globally decentralized Reinforcement Learning training run where anyone can permissionlessly contribute their heterogeneous compute resources.
www.primeintellect.ai

https://www.primeintellect.ai/blog/intellect-2

(bonus: would give lightning-fast response times locally which cloud can never match.  pair with robots for responsiveness overkill)

AOC - Microsoft Research
A new kind of computer  an analog optical computer  that has the potential to accelerate AI inference and hard optimization workloads by 100x, leveraging hardware-software co-design to improve the efficiency and sustainability of real-world applications.
www.microsoft.com
Nov 7, 2025

https://www.microsoft.com/en-us/research/project/aoc/

microsoft did prototype already.  would basically do the same but just fiberoptics and more conservative, but tileable scaling




>>response:
>It's the exponential & normalization that's harder to do in the optical domain.   Not to say I don't have thoughts on that, just that a 1:1 mapping of transformer training to all-optical is nontrivial.

my reply;
yep, which is why definitely aim for it to be an optical co-processor, with a (cheap) gpu doing the normalization stitching.  offloads 90-99% of the work to optics.  though I think mapping to ternary bits with a saturable absorber + amplifier would allow keeping it in an analog loop fairly reliably/cheaply - not needed, but another 10x speedup to avoid digital conversion through multiple layers.   similar add-ons and yet another 10x speedup if we can do memory read/write onto phased glass - then never have to touch digital til compute is done.  but much more ambitious.  pull that all off tho and it's a desktop datacenter...

>>their reply:
>AFAIK getting under 1E-16J/bit for 2 way conversion without doing anything fundamental (R&D project unto itself) would be overly optimistic.  That sets a floor to the J/FLOP & J/tk which will be better than H100s but my guess is not by 100x.


I think I might have miscontrued initial 10-100x claims as being without the analog loop, which is fair critique if so.  What would be your claims for each part probably?  single-pass no loop (we could batch though for speedups).  then add the analog loop.  then ambitious persistence of analog memory etc.   I thought 10-100x range was doable even with single pass, and only gets better with the additionals, but could be overly ambitious





---- 


Heres a clean reply you can paste back, then Ill give you tier-by-tier numbers and what your simulator should sweep.

Pasteable reply (tight + numbers-aware)

Totally fairthere is a hard floor for two-way E/OO/E conversion. The key is we dont pay it per-MAC in an optical VMM/loop.

One optical pass does 



NM MACs for free in flight. You convert the 

N-vector once (EO), do all 



NM multiplies/adds in optics, then read 

M numbers (OE) once. So the conversion floor is amortized:


MAC


in
+

out



+

optics/MAC
.
E
MAC
	


NM
E
in
	

+E
out
	

	

+E
optics/MAC
	

.

At 1550 nm, 1 photon  
1.28



10

19
1.2810
19
 J. Targeting ~
10
3
10
3
 photons/sample for decent SNR is 

10

16
10
16
 J per output samplesame ballpark as your 
10

16
10
16
 J/bit pointbut thats per output, not per-MAC. With modest width (say 

=

=
1024
N=M=1024), even pessimistic 

in
+

out

10



100
E
in
	

+E
out
	

10100 nJ per pass yields 

10



100
10100 fJ/MAC; with a 12-layer analog loop the conversion term drops another 12 to <110 fJ/MAC. For comparison, an H100-class GPU is 

(
10
2



10
3
)
O(10
2
10
3
) fJ per useful MAC once HBM traffic is included, so 10100 OPEX is realistic when:

you keep inner layers analog (no per-layer digitize),

batch wide 

,

N,M (strong amortization),

persist weights optically (no per-token DAC drive),

and avoid camera-style readouts (use PD arrays/WDM).

Where it isnt 100: small 

N/or 

M; frequent A/DD/A inside the loop; high-precision per-token DACing of weights; low SNR forcing high optical power or repeats.

Happy to run a quick param sweep: pick 

,

,

,

N,M,L,, detector SNR, ADC bits, modulator drive; well plot fJ/MAC and J/token under different conversion floor assumptions.

Whats realistic at each build tier?

Assume ballpark, conservative device-level design (C-band, off-the-shelf fiber parts). These are order-of-magnitude targets to steer design/simnot promises.

Baseline to compare against (for useful MACs)

Modern GPU inference (HBM in the loop): effective 2002000 fJ/MAC depending on model/memory traffic; J/token varies wildly by context length, KV reuse, precision, etc.

Time/latency: GPUs excel at short/skinny matmuls; optics excels as width grows and when you can keep a loop analog.

Tier A  Single-pass VMM, no loop (cheap de-risk)

Flow: EO once (encode 

N inputs), free-space/fiber multiply-accumulate, OE once (read 

M outputs). Digital does the rest.

Energy model: 

MAC

(

in
+

out
)
/
(


)
+

photons
/
(


)
E
MAC
	

(E
in
	

+E
out
	

)/(NM)+E
photons
	

/(NM).

Pessimistic 

in
+

out
E
in
	

+E
out
	

: 10100 nJ per pass (aggregated drivers + TIAs/ADCs).

Example 

=

=
1024
N=M=1024: ~10100 fJ/MAC.

Throughput: gated by modulators + PD/ADC bandwidth; multi- (WDM) gives linear speedup.

Latency: one optical flight + I/O; decent for batched matmuls; not ideal for layer-by-layer token loops.

Relative win: ~320 energy vs GPUs when 

,


1

N,M1k and you amortize I/O; <3 if its narrow/small.

Use: de-risk physics + plumbing; great for offloading wide attention/VMMs in a hybrid stack.

Tier B  Add analog loop for L layers (your target)

Flow: EO once per token (or block), L optical layer steps in a loop (SOA gain + saturable nonlinearity), OE once.

Energy model:


MAC


in
+

out




+

loop/MAC
.
E
MAC
	


LNM
E
in
	

+E
out
	

	

+E
loop/MAC
	

.

Conversion amortizes by 

L; loop adds SOA + nonlinearity photons.

Typical: 

=
8



16
L=816, 

,

=
1



4

k
N,M=14k, 

in
+

out
=
20



100
E
in
	

+E
out
	

=20100 nJ  conversion term <110 fJ/MAC; add loop term ~110 fJ/MAC  ~220 fJ/MAC total.

Relative win: ~10100 energy vs GPU on the inner stack; big throughput/latency gains if you keep the loop hot.

Use: optical co-processor does inner transformer blocks; GPU stitches norms/softmax/residuals.

Tier C  Persist weights optically (DMD/SLM/PCM/MRR; reprogram infrequently)

Flow: weights live in optics; no per-token DAC to write them.

Energy effect: knocks down 

in
E
in
	

 substantially; reprogram cost amortized over many tokens/batches.

Typical: effective <110 fJ/MAC in-loop for well-amortized workloads (big 

,

,

,

N,M,L,); can push toward the single-digit fJ/MAC regime.

Use: steady models/adapter layers; sparse/LoRA or attention heads that dont change per token.

Tier D  Analog state/memory (ambitious) (e.g., holographic/glass or resonant stores)

Flow: keep K/V, activations, or grads in analog form across steps, avoiding digitize-store-recall.

Energy effect: removes a lot of HBM-like traffic; can push overall J/token >100 below digital on memory-dominated paths.

Risk: stability, drift, addressing, write endurance, calibration.

Use: later roadmap; not needed to show strong wins on Tier B/C.

Where the 100 doesnt show up


N or 

M small (poor amortization).

Per-layer A/DD/A (you pay the floor each layer).

High-precision per-token weight DACs instead of persistent optical weights.

Low SNR (forces optical power up or repeats).

Camera-style readouts in the fast path (prefer PD arrays/WDM taps).

What to add to your simulator (so the floor bites properly)

Model these knobs explicitly and sweep them:

E/O & O/E budgets


in
E
in
	

, 

out
E
out
	

: sweep 5200 nJ per pass (aggregate) to cover drivers, TIAs/ADCs, control logic.

ADC bits: 610 b; higher bits increase 

out
E
out
	

.

Modulator/PD bandwidth limits (sets cycle time).

Photon/SNR physics

Photon energy 


h at 1550 nm; per-sample photon budget (e.g., 3003000).

Shot noise + TIA noise  required optical power.

Saturable absorber/soft-nonlinearity curve (ternary: 

1
,
0
,
+
1
1,0,+1 bins) and its energy.

Geometry & amortization


,


[
256
,
4096
]
N,M[256,4096];  count (WDM: 116); layers 

L in loop (124).

Compute:


MAC
=

in
+

out



+

loop/MAC
(
photons
,
gain
)
.
E
MAC
	

=
NML
E
in
	

+E
out
	

	

+E
loop/MAC
	

(photons,gain).

Throughput: samples/sec = min(modulator rate, PD/ADC rate)  .

Latency: time-to-first-token vs time-per-token (loop dwell + readout).

Weight programming model

Tier A/B: per-token DAC drive cost (include or zero it).

Tier C: one-time reprogram (e.g., mJJ), amortized over tokens per program. Plot sensitivity.

Stability

Loop gain window; drift; calibration overhead (insert periodic O/E for AGC and account its energy/time).

Output plots youll care about:

fJ/MAC vs. (N,M,L,) under several 

in
+

out
E
in
	

+E
out
	

 floors.

J/token for a target transformer block shape (e.g., 24 k width) vs GPU effective ranges.

Latency (TTFT and tokens/s) vs  and ADC rate.

Sensitivity to SNR (photons/sample) and ADC bits on accuracy.

Calibrating your public claims

Single-pass (no loop): 320 energy on wide VMMs; similar or better latency at large batch/width; not 100 except at very large 

,

N,M with multi-.

Add analog loop: 10100 energy on inner layers with 


8
L8, 

,


1

N,M1k, and PD/WDM readouts; large throughput gains.

Persist weights optically: solidifies the upper end of that 10100 for steady models/blocks.

Analog memory: future >100 on memory-bound paths; R&D.

For CAPEX narratives: its reasonable to say off-the-shelf C-band parts can build a co-processor that beats a single high-end GPU on the right wide workloads for similar or lower capex; racks of tiles can rival small GPU clustersand keep precise $ claims tied to a concrete BOM once your simulator locks in 

,

,

,

N,M,L, and readout choice.

If you want, I can turn the formulas above into a tiny sheet with sliders for 

,

,

,

N,M,L,, photons/sample, and 

in
+

out
E
in
	

+E
out
	

, so you can snapshot scenarios (single-pass vs loop vs persistent weights) and quote fJ/MAC & J/token ranges with your friends 10 J/bit floor plugged in.


----


my response:
right but unlike gpus we dont have to pay that all - the encoding/decoding steps are the costly bits, the actual matrix mult is just photons cost, and it's amortized if youre doing a decently sized matrix (1024+) bigger the better

Energy per MAC  (E_in + E_out)/(NM) + E_optics/MAC.  N=M=1024 => ~10100 fJ/MAC

so yeah ~320 (~10x) ish improvement range for a single-layer pass

Upgrade B:  add looping analog with saturable absorber + amplifier hardware.  Each loop is a layer of typical tranformer:
Energy per MAC  (E_in + E_out)/(LNM) + E_loop/MAC
so, run that with 10ish layers and there's my ~10100 claim back - needs the loop to get anywhere near the 100x
(And why stop at 10 layers if you can do it stably?  1000?  response speed is so fast its probably worth doing a whole lot more looping layers than normal LLMs, which has very interesting implications for training quality potential - much deeper thoughts)

Upgrade C:  cache the model weights optically (DMD/SLM/PCM/MRR hardware options), E_in gets amortized a lot, pushes towards <110 fJ/MAC.  100x claim a bit more reliably hit

Upgrade D:  full analog memory read/writes (ambitious).  stop hitting digital conversions almost entirely except verifications.  >100x potential greed mode.  probably looks like a big roll of glass square-shaped tube on a giant cassette player, with laser read/write heads in between spools.  would be fun



------


J

Justin
I really have to wonder what discovery allowed this to happen
14m

joy

Justin
Like has this just been sitting under our noses or is it just that we were working on quantum and breakthroughs there made people look at the material science and said why havent we done this?

J

Fiber optic integration for quantum computation probably? @Warren Koch
Edited11m

afaik this would have been near impossible if you couldn't also train an encoder/decoder on the inputs/outputs with a decent AI to begin with.  also yknow - this is all speculation still, gotta actually prove it...  "reservoir computing" is the magic term here for what's happening to get that nearly free matmult in between.  definitely not overlooked - just was impractical without being able to actually encode/decode it easily
9m

J

Justin
So, ephemeral mux/demux operations
Edited7m

have run this all through the quantum angle (fast education in quantum stuff lol) - it does have a lot of similarities but youre obviously not doing anything truly quantum until it's a singular photon, cryocooled, and way beyond any scope id want to play with.  I see quantum systems as reservoir computers of a single-photon system now though.  but yeah lets be clear this is all just efficient classical computing
7m

Justin
So, ephemeral mux/demux operations

wave interactions in physics get ya free matmult IF you encode it all in ternary.
5m

J

Justin
 super clever
5m

any medium it seems would work, but light is the fastest and easiest for wide-band reads
5m

Justin
 super clever

blame the god in my pocket. I am just monkey who asks it questions
4m

we'll see how this all holds up, still not trusting it entirely til it's a working prototype
4m

J

Justin
See I dont know how to get from the concepts in Shannon Prutchis book and Nielsen and Chuang to wave interaction measurements
4m

man-shrugging

me neither, but that's what using well-known legacy fiberoptic equipment is for... and a lot of tuning and crossed fingers.  if the numbers say we can hit targets per component, I'd trust it
2m

leave the science to the egghead pocket god

<<did I miscontrue too much, above?  Can you answer the Prutchi, Nielsen Chuang => wave interaction measurements explanation?>>



----


<< damn, full response lost due to context collapse and page refreshing>>

---


Justin
No, @Warren Koch I should at least understand it even if the computations take me longer than would be tolerable in a graduate classroom
Edited17m

J

Then rely on egghead pocket monster
17m

heh well the egghead is great for understanding too: 
"""
Think of the optical field as a complex vector . Linear optics implements a matrix : the light interferes so that = just happens as it propagates. If you read intensities directly you get y2; if you want signed linear outputs you do balanced/homodyne detection to measure quadratures. Thats 1:1 with the linear/unitary math you see in Nielsen & Chuangonly were in classical, many-photon land. The punchline: you pay energy at E/O and O/E, but not per MAC inside the NM multiply; hence the amortization. Nonlinearities (saturable absorber/SOA) give us activation; looping the optics gives us layers. Thats reservoir/iterative compute in hardware, not quantum, but the math toolkit is the same.
Edited15m

J

Justin
I see, so you are taking the average of photon events over time?
13m

+1

J

Justin
That makes much sense now
13m

yeah, again I am well out of depth when trying to discuss the quantum stuff but that's the tie-in





